
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bookman: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">/Users/didi/spring-core/gs/examples/bookman/main.go (85.0%)</option>
				
				<option value="file1">github.com/go-spring/spring-core/conf/bind.go (46.2%)</option>
				
				<option value="file2">github.com/go-spring/spring-core/conf/conf.go (82.8%)</option>
				
				<option value="file3">github.com/go-spring/spring-core/conf/expr.go (0.0%)</option>
				
				<option value="file4">github.com/go-spring/spring-core/conf/reader/json/json.go (0.0%)</option>
				
				<option value="file5">github.com/go-spring/spring-core/conf/reader/prop/prop.go (100.0%)</option>
				
				<option value="file6">github.com/go-spring/spring-core/conf/reader/toml/toml.go (0.0%)</option>
				
				<option value="file7">github.com/go-spring/spring-core/conf/reader/yaml/yaml.go (0.0%)</option>
				
				<option value="file8">github.com/go-spring/spring-core/conf/storage/path.go (32.8%)</option>
				
				<option value="file9">github.com/go-spring/spring-core/conf/storage/store.go (78.6%)</option>
				
				<option value="file10">github.com/go-spring/spring-core/gs/examples/bookman/src/app/bootstrap/bootstrap.go (73.9%)</option>
				
				<option value="file11">github.com/go-spring/spring-core/gs/examples/bookman/src/app/common/handlers/log/log.go (87.5%)</option>
				
				<option value="file12">github.com/go-spring/spring-core/gs/examples/bookman/src/app/common/httpsvr/httpsvr.go (100.0%)</option>
				
				<option value="file13">github.com/go-spring/spring-core/gs/examples/bookman/src/app/controller/controller-book.go (12.0%)</option>
				
				<option value="file14">github.com/go-spring/spring-core/gs/examples/bookman/src/app/controller/controller.go (100.0%)</option>
				
				<option value="file15">github.com/go-spring/spring-core/gs/examples/bookman/src/biz/job/job.go (66.7%)</option>
				
				<option value="file16">github.com/go-spring/spring-core/gs/examples/bookman/src/biz/service/book_service/book_service.go (43.8%)</option>
				
				<option value="file17">github.com/go-spring/spring-core/gs/examples/bookman/src/dao/book_dao/book_dao.go (36.4%)</option>
				
				<option value="file18">github.com/go-spring/spring-core/gs/examples/bookman/src/idl/http/proto/proto.go (100.0%)</option>
				
				<option value="file19">github.com/go-spring/spring-core/gs/examples/bookman/src/sdk/book_sdk/book_sdk.go (100.0%)</option>
				
				<option value="file20">github.com/go-spring/spring-core/gs/gs.go (64.4%)</option>
				
				<option value="file21">github.com/go-spring/spring-core/gs/http.go (94.1%)</option>
				
				<option value="file22">github.com/go-spring/spring-core/gs/internal/gs/gs.go (47.2%)</option>
				
				<option value="file23">github.com/go-spring/spring-core/gs/internal/gs_app/app.go (75.7%)</option>
				
				<option value="file24">github.com/go-spring/spring-core/gs/internal/gs_app/boot.go (55.2%)</option>
				
				<option value="file25">github.com/go-spring/spring-core/gs/internal/gs_app/signal.go (77.8%)</option>
				
				<option value="file26">github.com/go-spring/spring-core/gs/internal/gs_arg/arg.go (62.5%)</option>
				
				<option value="file27">github.com/go-spring/spring-core/gs/internal/gs_bean/bean.go (54.4%)</option>
				
				<option value="file28">github.com/go-spring/spring-core/gs/internal/gs_cond/cond.go (17.5%)</option>
				
				<option value="file29">github.com/go-spring/spring-core/gs/internal/gs_cond/expr.go (0.0%)</option>
				
				<option value="file30">github.com/go-spring/spring-core/gs/internal/gs_conf/cmd.go (42.1%)</option>
				
				<option value="file31">github.com/go-spring/spring-core/gs/internal/gs_conf/conf.go (68.0%)</option>
				
				<option value="file32">github.com/go-spring/spring-core/gs/internal/gs_conf/env.go (64.5%)</option>
				
				<option value="file33">github.com/go-spring/spring-core/gs/internal/gs_core/core.go (75.0%)</option>
				
				<option value="file34">github.com/go-spring/spring-core/gs/internal/gs_core/injecting/injecting.go (52.2%)</option>
				
				<option value="file35">github.com/go-spring/spring-core/gs/internal/gs_core/resolving/resolving.go (44.0%)</option>
				
				<option value="file36">github.com/go-spring/spring-core/gs/internal/gs_dync/dync.go (77.1%)</option>
				
				<option value="file37">github.com/go-spring/spring-core/gs/internal/gs_util/util.go (66.7%)</option>
				
				<option value="file38">github.com/go-spring/spring-core/gs/pprof.go (100.0%)</option>
				
				<option value="file39">github.com/go-spring/spring-core/gs/prop.go (30.0%)</option>
				
				<option value="file40">github.com/go-spring/spring-core/util/errutil/errutil.go (0.0%)</option>
				
				<option value="file41">github.com/go-spring/spring-core/util/flat.go (28.0%)</option>
				
				<option value="file42">github.com/go-spring/spring-core/util/goutil/goutil.go (27.5%)</option>
				
				<option value="file43">github.com/go-spring/spring-core/util/iterutil/iterutil.go (15.4%)</option>
				
				<option value="file44">github.com/go-spring/spring-core/util/list.go (0.0%)</option>
				
				<option value="file45">github.com/go-spring/spring-core/util/map.go (100.0%)</option>
				
				<option value="file46">github.com/go-spring/spring-core/util/sysconf/sysconf.go (50.0%)</option>
				
				<option value="file47">github.com/go-spring/spring-core/util/syslog/syslog.go (86.7%)</option>
				
				<option value="file48">github.com/go-spring/spring-core/util/type.go (70.4%)</option>
				
				<option value="file49">github.com/go-spring/spring-core/util/value.go (31.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/go-spring/spring-core/gs"
        "github.com/go-spring/spring-core/util/iterutil"
        "github.com/go-spring/spring-core/util/syslog"

        _ "github.com/go-spring/spring-core/gs/examples/bookman/src/app"
        _ "github.com/go-spring/spring-core/gs/examples/bookman/src/biz"
)

const banner = `
  ____                 _     __  __               
 | __ )   ___    ___  | | __|  \/  |  __ _  _ __  
 |  _ \  / _ \  / _ \ | |/ /| |\/| | / _' || '_ \ 
 | |_) || (_) || (_) ||   &lt; | |  | || (_| || | | |
 |____/  \___/  \___/ |_|\_\|_|  |_| \__,_||_| |_|
`

func init() <span class="cov1" title="1">{
        gs.Banner(banner)
        gs.SetActiveProfiles("online")
        gs.EnableSimplePProfServer(true)
}</span>

func init() <span class="cov1" title="1">{
        gs.FuncJob(runTest).Name("#job")
}</span>

func main() <span class="cov1" title="1">{
        // Start the application and log errors if startup fails
        if err := gs.Run(); err != nil </span><span class="cov0" title="0">{
                syslog.Errorf("app run failed: %s", err.Error())
        }</span>
}

// runTest performs a simple test.
func runTest(ctx context.Context) error <span class="cov1" title="1">{
        time.Sleep(time.Millisecond * 500)

        iterutil.Times(5, func(_ int) </span><span class="cov10" title="5">{
                url := "http://127.0.0.1:9090/books"
                resp, err := http.Get(url)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov10" title="5">b, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov10" title="5">defer resp.Body.Close()
                fmt.Print(string(b))
                time.Sleep(time.Millisecond * 400)</span>
        })

        // Shut down the application gracefully
        <span class="cov1" title="1">gs.ShutDown()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package conf

import (
        "errors"
        "fmt"
        "reflect"
        "strconv"
        "strings"

        "github.com/go-spring/spring-core/util"
        "github.com/go-spring/spring-core/util/errutil"
)

var (
        ErrNotExist      = errors.New("not exist")
        ErrInvalidSyntax = errors.New("invalid syntax")
)

// ParsedTag represents a parsed configuration tag, including key,
// default value, and optional custom splitter for list parsing.
type ParsedTag struct {
        Key      string // short property key
        Def      string // default value
        HasDef   bool   // has default value
        Splitter string // splitter's name
}

func (tag ParsedTag) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString("${")
        sb.WriteString(tag.Key)
        if tag.HasDef </span><span class="cov0" title="0">{
                sb.WriteString(":=")
                sb.WriteString(tag.Def)
        }</span>
        <span class="cov0" title="0">sb.WriteString("}")
        if tag.Splitter != "" </span><span class="cov0" title="0">{
                sb.WriteString("&gt;&gt;")
                sb.WriteString(tag.Splitter)
        }</span>
        <span class="cov0" title="0">return sb.String()</span>
}

// ParseTag parses a tag string in the format `${key:=default}&gt;&gt;splitter`
// into a ParsedTag struct. Returns an error if the format is invalid.
func ParseTag(tag string) (ret ParsedTag, err error) <span class="cov6" title="41">{
        i := strings.LastIndex(tag, "&gt;&gt;")
        if i == 0 </span><span class="cov0" title="0">{
                err = fmt.Errorf("parse tag '%s' error: %w", tag, ErrInvalidSyntax)
                return
        }</span>
        <span class="cov6" title="41">j := strings.LastIndex(tag, "}")
        if j &lt;= 0 </span><span class="cov0" title="0">{
                err = fmt.Errorf("parse tag '%s' error: %w", tag, ErrInvalidSyntax)
                return
        }</span>
        <span class="cov6" title="41">k := strings.Index(tag, "${")
        if k &lt; 0 </span><span class="cov0" title="0">{
                err = fmt.Errorf("parse tag '%s' error: %w", tag, ErrInvalidSyntax)
                return
        }</span>
        <span class="cov6" title="41">if i &gt; j </span><span class="cov0" title="0">{
                ret.Splitter = strings.TrimSpace(tag[i+2:])
        }</span>
        <span class="cov6" title="41">ss := strings.SplitN(tag[k+2:j], ":=", 2)
        ret.Key = ss[0]
        if len(ss) &gt; 1 </span><span class="cov5" title="34">{
                ret.HasDef = true
                ret.Def = ss[1]
        }</span>
        <span class="cov6" title="41">return</span>
}

// BindParam holds binding metadata for a single configuration value.
type BindParam struct {
        Key      string            // full key
        Path     string            // full path
        Tag      ParsedTag         // parsed tag
        Validate reflect.StructTag // full field tag
}

// BindTag parses and binds the configuration tag to the BindParam.
// It handles default values and nested key expansion.
func (param *BindParam) BindTag(tag string, validate reflect.StructTag) error <span class="cov6" title="41">{
        param.Validate = validate
        parsedTag, err := ParseTag(tag)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="41">if parsedTag.Key == "" </span><span class="cov0" title="0">{ // ${:=} 默认值语法
                if parsedTag.HasDef </span><span class="cov0" title="0">{
                        param.Tag = parsedTag
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("parse tag '%s' error: %w", tag, ErrInvalidSyntax)</span>
        }
        <span class="cov6" title="41">if parsedTag.Key == "ROOT" </span><span class="cov0" title="0">{
                parsedTag.Key = ""
        }</span>
        <span class="cov6" title="41">if param.Key == "" </span><span class="cov5" title="35">{
                param.Key = parsedTag.Key
        }</span> else<span class="cov3" title="6"> if parsedTag.Key != "" </span><span class="cov3" title="6">{
                param.Key = param.Key + "." + parsedTag.Key
        }</span>
        <span class="cov6" title="41">param.Tag = parsedTag
        return nil</span>
}

// Filter defines an interface for filtering configuration fields during binding.
type Filter interface {
        Do(i interface{}, param BindParam) (bool, error)
}

// BindValue binds a value from properties `p` to the reflect.Value `v` of type `t`
// using metadata in `param`. It supports primitives, structs, maps, and slices.
func BindValue(p Properties, v reflect.Value, t reflect.Type, param BindParam, filter Filter) (RetErr error) <span class="cov5" title="22">{

        if !util.IsPropBindingTarget(t) </span><span class="cov0" title="0">{
                err := errors.New("target should be value type")
                return fmt.Errorf("bind path=%s type=%s error: %w", param.Path, v.Type().String(), err)
        }</span>

        <span class="cov5" title="22">defer func() </span><span class="cov5" title="22">{
                if RetErr == nil </span><span class="cov5" title="22">{
                        tag, ok := param.Validate.Lookup("expr")
                        if ok &amp;&amp; len(tag) &gt; 0 </span><span class="cov0" title="0">{
                                err := validateField(tag, v.Interface())
                                if err != nil </span><span class="cov0" title="0">{
                                        RetErr = err
                                }</span>
                        }
                }
        }()

        <span class="cov5" title="22">switch v.Kind() </span>{
        case reflect.Map:<span class="cov1" title="1">
                return bindMap(p, v, t, param, filter)</span>
        case reflect.Slice:<span class="cov0" title="0">
                return bindSlice(p, v, t, param, filter)</span>
        case reflect.Array:<span class="cov0" title="0">
                err := errors.New("use slice instead of array")
                return fmt.Errorf("bind path=%s type=%s error: %w", param.Path, v.Type().String(), err)</span>
        default:<span class="cov5" title="21"></span> // for linter
        }

        <span class="cov5" title="21">fn := converters[t]
        if fn == nil &amp;&amp; v.Kind() == reflect.Struct </span><span class="cov2" title="3">{
                if err := bindStruct(p, v, t, param, filter); err != nil </span><span class="cov0" title="0">{
                        return err // no wrap
                }</span>
                <span class="cov2" title="3">return nil</span>
        }

        <span class="cov4" title="18">val, err := resolve(p, param)
        if err != nil </span><span class="cov0" title="0">{
                return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())
        }</span>

        <span class="cov4" title="18">if fn != nil </span><span class="cov2" title="3">{
                fnValue := reflect.ValueOf(fn)
                out := fnValue.Call([]reflect.Value{reflect.ValueOf(val)})
                if !out[1].IsNil() </span><span class="cov0" title="0">{
                        err = out[1].Interface().(error)
                        return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())
                }</span>
                <span class="cov2" title="3">v.Set(out[0])
                return nil</span>
        }

        <span class="cov4" title="15">switch v.Kind() </span>{
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                var u uint64
                if u, err = strconv.ParseUint(val, 0, 0); err == nil </span><span class="cov0" title="0">{
                        v.SetUint(u)
                        return nil
                }</span>
                <span class="cov0" title="0">return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov3" title="5">
                var i int64
                if i, err = strconv.ParseInt(val, 0, 0); err == nil </span><span class="cov3" title="5">{
                        v.SetInt(i)
                        return nil
                }</span>
                <span class="cov0" title="0">return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                var f float64
                if f, err = strconv.ParseFloat(val, 64); err == nil </span><span class="cov0" title="0">{
                        v.SetFloat(f)
                        return nil
                }</span>
                <span class="cov0" title="0">return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())</span>
        case reflect.Bool:<span class="cov1" title="2">
                var b bool
                if b, err = strconv.ParseBool(val); err == nil </span><span class="cov1" title="2">{
                        v.SetBool(b)
                        return nil
                }</span>
                <span class="cov0" title="0">return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())</span>
        default:<span class="cov3" title="8">
                v.SetString(val)
                return nil</span>
        }
}

// bindSlice binds properties to a slice value.
func bindSlice(p Properties, v reflect.Value, t reflect.Type, param BindParam, filter Filter) error <span class="cov0" title="0">{

        et := t.Elem()
        p, err := getSlice(p, et, param)
        if err != nil </span><span class="cov0" title="0">{
                return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())
        }</span>

        <span class="cov0" title="0">slice := reflect.MakeSlice(t, 0, 0)
        defer func() </span><span class="cov0" title="0">{ v.Set(slice) }</span>()

        <span class="cov0" title="0">if p == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for i := 0; ; i++ </span><span class="cov0" title="0">{
                ev := reflect.New(et).Elem()
                subParam := BindParam{
                        Key:  fmt.Sprintf("%s[%d]", param.Key, i),
                        Path: fmt.Sprintf("%s[%d]", param.Path, i),
                }
                err = BindValue(p, ev, et, subParam, filter)
                if errors.Is(err, ErrNotExist) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())
                }</span>
                <span class="cov0" title="0">slice = reflect.Append(slice, ev)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// getSlice retrieves and splits a string into slice elements,
// creating a new Properties instance if necessary.
func getSlice(p Properties, et reflect.Type, param BindParam) (Properties, error) <span class="cov0" title="0">{

        // properties that defined as list.
        if p.Has(param.Key + "[0]") </span><span class="cov0" title="0">{
                return p, nil
        }</span>

        // properties that defined as string and needs to split into []string.
        <span class="cov0" title="0">var strVal string
        </span><span class="cov0" title="0">{
                if p.Has(param.Key) </span><span class="cov0" title="0">{
                        strVal = p.Get(param.Key)
                }</span> else<span class="cov0" title="0"> {
                        if !param.Tag.HasDef </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("property %q %w", param.Key, ErrNotExist)
                        }</span>
                        <span class="cov0" title="0">if param.Tag.Def == "" </span><span class="cov0" title="0">{
                                return nil, nil
                        }</span>
                        <span class="cov0" title="0">if !util.IsPrimitiveValueType(et) &amp;&amp; converters[et] == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("can't find converter for %s", et.String())
                        }</span>
                        <span class="cov0" title="0">strVal = param.Tag.Def</span>
                }
        }
        <span class="cov0" title="0">if strVal == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">var (
                err    error
                arrVal []string
        )

        if s := param.Tag.Splitter; s == "" </span><span class="cov0" title="0">{
                arrVal = strings.Split(strVal, ",")
                for i := range arrVal </span><span class="cov0" title="0">{
                        arrVal[i] = strings.TrimSpace(arrVal[i])
                }</span>
        } else<span class="cov0" title="0"> if fn, ok := splitters[s]; ok &amp;&amp; fn != nil </span><span class="cov0" title="0">{
                if arrVal, err = fn(strVal); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("split error: %w, value: %q", err, strVal)
                }</span>
        } else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("unknown splitter '%s'", s)
        }</span>

        <span class="cov0" title="0">r := New()
        for i, s := range arrVal </span><span class="cov0" title="0">{
                k := fmt.Sprintf("%s[%d]", param.Key, i)
                _ = r.Set(k, s) // always no error
        }</span>
        <span class="cov0" title="0">return r, nil</span>
}

// bindMap binds properties to a map value.
func bindMap(p Properties, v reflect.Value, t reflect.Type, param BindParam, filter Filter) error <span class="cov1" title="1">{

        if param.Tag.HasDef &amp;&amp; param.Tag.Def != "" </span><span class="cov0" title="0">{
                err := errors.New("map can't have a non-empty default value")
                return fmt.Errorf("bind path=%s type=%s error: %w", param.Path, v.Type().String(), err)
        }</span>

        <span class="cov1" title="1">et := t.Elem()
        ret := reflect.MakeMap(t)
        defer func() </span><span class="cov1" title="1">{ v.Set(ret) }</span>()

        // 当成默认值处理
        <span class="cov1" title="1">if param.Tag.Key == "" </span><span class="cov0" title="0">{
                if param.Tag.HasDef </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov1" title="1">if !p.Has(param.Key) </span><span class="cov0" title="0">{
                if param.Tag.HasDef </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("property %q %w", param.Key, ErrNotExist)</span>
        }

        <span class="cov1" title="1">keys, err := p.SubKeys(param.Key)
        if err != nil </span><span class="cov0" title="0">{
                return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())
        }</span>

        <span class="cov1" title="1">for _, key := range keys </span><span class="cov2" title="3">{
                e := reflect.New(et).Elem()
                subKey := key
                if param.Key != "" </span><span class="cov2" title="3">{
                        subKey = param.Key + "." + key
                }</span>
                <span class="cov2" title="3">subParam := BindParam{
                        Key:  subKey,
                        Path: param.Path,
                }
                if err = BindValue(p, e, et, subParam, filter); err != nil </span><span class="cov0" title="0">{
                        return err // no wrap
                }</span>
                <span class="cov2" title="3">ret.SetMapIndex(reflect.ValueOf(key), e)</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// bindStruct binds properties to a struct value.
func bindStruct(p Properties, v reflect.Value, t reflect.Type, param BindParam, filter Filter) error <span class="cov2" title="3">{

        if param.Tag.HasDef &amp;&amp; param.Tag.Def != "" </span><span class="cov0" title="0">{
                err := errors.New("struct can't have a non-empty default value")
                return fmt.Errorf("bind path=%s type=%s error: %w", param.Path, v.Type().String(), err)
        }</span>

        <span class="cov2" title="3">for i := 0; i &lt; t.NumField(); i++ </span><span class="cov3" title="6">{
                ft := t.Field(i)
                fv := v.Field(i)

                if !fv.CanInterface() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov3" title="6">subParam := BindParam{
                        Key:  param.Key,
                        Path: param.Path + "." + ft.Name,
                }

                if tag, ok := ft.Tag.Lookup("value"); ok </span><span class="cov3" title="6">{
                        if err := subParam.BindTag(tag, ft.Tag); err != nil </span><span class="cov0" title="0">{
                                return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())
                        }</span>
                        <span class="cov3" title="6">if filter != nil </span><span class="cov0" title="0">{
                                ret, err := filter.Do(fv.Addr().Interface(), subParam)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if ret </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                        <span class="cov3" title="6">if err := BindValue(p, fv, ft.Type, subParam, filter); err != nil </span><span class="cov0" title="0">{
                                return err // no wrap
                        }</span>
                        <span class="cov3" title="6">continue</span>
                }

                <span class="cov0" title="0">if ft.Anonymous </span><span class="cov0" title="0">{
                        // embed pointer type may lead to infinite recursion.
                        if ft.Type.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if err := bindStruct(p, fv, ft.Type, subParam, filter); err != nil </span><span class="cov0" title="0">{
                                return err // no wrap
                        }</span>
                }
        }
        <span class="cov2" title="3">return nil</span>
}

// resolve returns property references processed property value.
func resolve(p Properties, param BindParam) (string, error) <span class="cov6" title="44">{
        const defVal = "@@def@@"
        val := p.Get(param.Key, defVal)
        if val != defVal </span><span class="cov5" title="22">{
                return resolveString(p, val)
        }</span>
        <span class="cov5" title="22">if p.Has(param.Key) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("property %s isn't simple value", param.Key)
        }</span>
        <span class="cov5" title="22">if param.Tag.HasDef </span><span class="cov5" title="22">{
                return resolveString(p, param.Tag.Def)
        }</span>
        <span class="cov0" title="0">return "", fmt.Errorf("property %s %w", param.Key, ErrNotExist)</span>
}

// resolveString returns property references processed string.
func resolveString(p Properties, s string) (string, error) <span class="cov8" title="192">{

        // If there is no property reference, return the original string.
        start := strings.Index(s, "${")
        if start &lt; 0 </span><span class="cov7" title="166">{
                return s, nil
        }</span>

        <span class="cov5" title="26">var (
                length = len(s)
                count  = 1
                end    = -1
        )

        for i := start + 2; i &lt; length; i++ </span><span class="cov10" title="797">{
                if s[i] == '$' </span><span class="cov0" title="0">{
                        if i+1 &lt; length &amp;&amp; s[i+1] == '{' </span><span class="cov0" title="0">{
                                count++
                        }</span>
                } else<span class="cov10" title="797"> if s[i] == '}' </span><span class="cov5" title="26">{
                        count--
                        if count == 0 </span><span class="cov5" title="26">{
                                end = i
                                break</span>
                        }
                }
        }

        <span class="cov5" title="26">if end &lt; 0 </span><span class="cov0" title="0">{
                err := ErrInvalidSyntax
                return "", fmt.Errorf("resolve string %q error: %w", s, err)
        }</span>

        <span class="cov5" title="26">var param BindParam
        _ = param.BindTag(s[start:end+1], "")

        s1, err := resolve(p, param)
        if err != nil </span><span class="cov0" title="0">{
                return "", errutil.WrapError(err, "resolve string %q error", s)
        }</span>

        <span class="cov5" title="26">s2, err := resolveString(p, s[end+1:])
        if err != nil </span><span class="cov0" title="0">{
                return "", errutil.WrapError(err, "resolve string %q error", s)
        }</span>

        <span class="cov5" title="26">return s[:start] + s1 + s2, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package conf

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "reflect"
        "strings"
        "time"

        "github.com/go-spring/spring-core/conf/reader/json"
        "github.com/go-spring/spring-core/conf/reader/prop"
        "github.com/go-spring/spring-core/conf/reader/toml"
        "github.com/go-spring/spring-core/conf/reader/yaml"
        "github.com/go-spring/spring-core/conf/storage"
        "github.com/go-spring/spring-core/util"
        "github.com/spf13/cast"
)

var (
        readers    = map[string]Reader{}
        splitters  = map[string]Splitter{}
        converters = map[reflect.Type]interface{}{}
)

func init() <span class="cov1" title="1">{

        RegisterReader(json.Read, ".json")
        RegisterReader(prop.Read, ".properties")
        RegisterReader(yaml.Read, ".yaml", ".yml")
        RegisterReader(toml.Read, ".toml", ".tml")

        RegisterConverter(func(s string) (time.Time, error) </span><span class="cov0" title="0">{
                return cast.ToTimeE(strings.TrimSpace(s))
        }</span>)

        <span class="cov1" title="1">RegisterConverter(func(s string) (time.Duration, error) </span><span class="cov2" title="3">{
                return time.ParseDuration(strings.TrimSpace(s))
        }</span>)
}

// Reader parses []byte into nested map[string]interface{}.
type Reader func(b []byte) (map[string]interface{}, error)

// RegisterReader registers its Reader for some kind of file extension.
func RegisterReader(r Reader, ext ...string) <span class="cov3" title="4">{
        for _, s := range ext </span><span class="cov3" title="6">{
                readers[s] = r
        }</span>
}

// Splitter splits string into []string by some characters.
type Splitter func(string) ([]string, error)

// RegisterSplitter registers a Splitter and named it.
func RegisterSplitter(name string, fn Splitter) <span class="cov0" title="0">{
        splitters[name] = fn
}</span>

// Converter converts a string to a target type T.
type Converter[T any] func(string) (T, error)

// RegisterConverter registers its converter for non-primitive type such as
// time.Time, time.Duration, or other user-defined value type.
func RegisterConverter[T any](fn Converter[T]) <span class="cov2" title="2">{
        t := reflect.TypeOf(fn)
        converters[t.Out(0)] = fn
}</span>

// Properties is the interface for read-only properties.
type Properties interface {
        // Data returns key-value pairs of the properties.
        Data() map[string]string
        // Keys returns keys of the properties.
        Keys() []string
        // SubKeys returns the sorted sub keys of the key.
        SubKeys(key string) ([]string, error)
        // Has returns whether the key exists.
        Has(key string) bool
        // Get returns key's value.
        Get(key string, def ...string) string
        // Resolve resolves string that contains references.
        Resolve(s string) (string, error)
        // Bind binds properties into a value.
        Bind(i interface{}, tag ...string) error
        // CopyTo copies properties into another by override.
        CopyTo(out *MutableProperties) error
}

var _ Properties = (*MutableProperties)(nil)

// MutableProperties stores the data with map[string]string and the keys are case-sensitive,
// you can get one of them by its key, or bind some of them to a value.
// There are too many formats of configuration files, and too many conflicts between
// them. Each format of configuration file provides its special characteristics, but
// usually they are not all necessary, and complementary. For example, `conf` disabled
// Java properties' expansion when reading file, but also provides similar function
// when getting or binding properties.
// A good rule of thumb is that treating application configuration as a tree, but not
// all formats of configuration files designed as a tree or not ideal, for instance
// Java properties isn't strictly verified. Although configuration can store as a tree,
// but it costs more CPU time when getting properties because it reads property node
// by node. So `conf` uses a tree to strictly verify and a flat map to store.
type MutableProperties struct {
        *storage.Storage
}

// New creates empty *MutableProperties.
func New() *MutableProperties <span class="cov6" title="35">{
        return &amp;MutableProperties{
                Storage: storage.NewStorage(),
        }
}</span>

// Load creates *MutableProperties from file.
func Load(file string) (*MutableProperties, error) <span class="cov7" title="88">{
        b, err := os.ReadFile(file)
        if err != nil </span><span class="cov7" title="78">{
                return nil, err
        }</span>
        <span class="cov4" title="10">ext := filepath.Ext(file)
        r, ok := readers[ext]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported file type %s", ext)
        }</span>
        <span class="cov4" title="10">m, err := r(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="10">return Map(m), nil</span>
}

// Map creates *MutableProperties from map.
func Map(m map[string]interface{}) *MutableProperties <span class="cov4" title="10">{
        p := New()
        _ = p.merge(util.FlattenMap(m))
        return p
}</span>

// merge flattens the map and sets all keys and values.
func (p *MutableProperties) merge(m map[string]string) error <span class="cov6" title="44">{
        for key, val := range m </span><span class="cov8" title="138">{
                if err := p.Set(key, val); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov6" title="44">return nil</span>
}

// Data returns key-value pairs of the properties.
func (p *MutableProperties) Data() map[string]string <span class="cov0" title="0">{
        m := make(map[string]string)
        for k, v := range p.RawData() </span><span class="cov0" title="0">{
                m[k] = v
        }</span>
        <span class="cov0" title="0">return m</span>
}

// Keys returns keys of the properties.
func (p *MutableProperties) Keys() []string <span class="cov4" title="8">{
        return util.OrderedMapKeys(p.RawData())
}</span>

// Get returns key's value, using Def to return a default value.
func (p *MutableProperties) Get(key string, def ...string) string <span class="cov10" title="468">{
        val, ok := p.RawData()[key]
        if !ok &amp;&amp; len(def) &gt; 0 </span><span class="cov5" title="22">{
                return def[0]
        }</span>
        <span class="cov9" title="446">return val</span>
}

// Resolve resolves string value that contains references to other
// properties, the references are defined by ${key:=def}.
func (p *MutableProperties) Resolve(s string) (string, error) <span class="cov8" title="122">{
        return resolveString(p, s)
}</span>

// Bind binds properties to a value, the bind value can be primitive type,
// map, slice, struct. When binding to struct, the tag 'value' indicates
// which properties should be bind. The 'value' tag are defined by
// value:"${a:=b}&gt;&gt;splitter", 'a' is the key, 'b' is the default value,
// 'splitter' is the Splitter's name when you want split string value
// into []string value.
func (p *MutableProperties) Bind(i interface{}, tag ...string) error <span class="cov3" title="5">{

        var v reflect.Value
        </span><span class="cov3" title="5">{
                switch e := i.(type) </span>{
                case reflect.Value:<span class="cov3" title="4">
                        v = e</span>
                default:<span class="cov1" title="1">
                        v = reflect.ValueOf(i)
                        if v.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                                return errors.New("should be a ptr")
                        }</span>
                        <span class="cov1" title="1">v = v.Elem()</span>
                }
        }

        <span class="cov3" title="5">t := v.Type()
        typeName := t.Name()
        if typeName == "" </span><span class="cov1" title="1">{ // primitive type has no name
                typeName = t.String()
        }</span>

        <span class="cov3" title="5">s := "${ROOT}"
        if len(tag) &gt; 0 </span><span class="cov3" title="5">{
                s = tag[0]
        }</span>

        <span class="cov3" title="5">var param BindParam
        err := param.BindTag(s, "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="5">param.Path = typeName
        return BindValue(p, v, t, param, nil)</span>
}

// CopyTo copies properties into another by override.
func (p *MutableProperties) CopyTo(out *MutableProperties) error <span class="cov6" title="34">{
        return out.merge(p.RawData())
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package conf

import (
        "fmt"

        "github.com/expr-lang/expr"
)

// ValidateFunc defines a type for validation functions, which accept
// a value of type T and return a boolean result.
type ValidateFunc[T any] func(T) bool

// validateFuncs holds a map of registered validation functions.
var validateFuncs = map[string]interface{}{}

// RegisterValidateFunc registers a validation function with a specific name.
// The function can then be used in validation expressions.
func RegisterValidateFunc[T any](name string, fn ValidateFunc[T]) <span class="cov0" title="0">{
        validateFuncs[name] = fn
}</span>

// validateField validates a field using a validation expression (tag) and the field value (i).
// It evaluates the expression and checks if the result is true (i.e., the validation passes).
// If any error occurs during evaluation or if the validation fails, an error is returned.
func validateField(tag string, i interface{}) error <span class="cov0" title="0">{
        env := map[string]interface{}{"$": i}
        for k, v := range validateFuncs </span><span class="cov0" title="0">{
                env[k] = v
        }</span>
        <span class="cov0" title="0">r, err := expr.Eval(tag, env)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("eval %q returns error, %w", tag, err)
        }</span>
        <span class="cov0" title="0">ret, ok := r.(bool)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("eval %q doesn't return bool value", tag)
        }</span>
        <span class="cov0" title="0">if !ret </span><span class="cov0" title="0">{
                return fmt.Errorf("validate failed on %q for value %v", tag, i)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package json

import (
        "encoding/json"
)

// Read parses []byte in the json format into map.
func Read(b []byte) (map[string]interface{}, error) <span class="cov0" title="0">{
        var ret map[string]interface{}
        err := json.Unmarshal(b, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package prop

import "github.com/magiconair/properties"

// Read parses []byte in the properties format into map.
func Read(b []byte) (map[string]interface{}, error) <span class="cov6" title="10">{

        p := properties.NewProperties()
        p.DisableExpansion = true
        _ = p.Load(b, properties.UTF8) // always no error

        ret := make(map[string]interface{})
        for k, v := range p.Map() </span><span class="cov10" title="45">{
                ret[k] = v
        }</span>
        <span class="cov6" title="10">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package toml

import (
        "github.com/pelletier/go-toml"
)

// Read parses []byte in the toml format into map.
func Read(b []byte) (map[string]interface{}, error) <span class="cov0" title="0">{
        tree, err := toml.LoadBytes(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tree.ToMap(), nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package yaml

import (
        "gopkg.in/yaml.v2"
)

// Read parses []byte in the yaml format into map.
func Read(b []byte) (map[string]interface{}, error) <span class="cov0" title="0">{
        ret := make(map[string]interface{})
        err := yaml.Unmarshal(b, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package storage

import (
        "errors"
        "fmt"
        "strconv"
        "strings"
)

// PathType represents the type of a path segment.
type PathType int

const (
        PathTypeKey   PathType = iota // PathTypeKey indicates a named key in a map.
        PathTypeIndex                 // PathTypeIndex indicates a numeric index in a list.
)

// Path represents a segment of a hierarchical path.
// Each segment is either a key (e.g., "user") or an index (e.g., "0").
type Path struct {
        Type PathType // Type determines whether the segment is a key or index.
        Elem string   // Elem holds the actual key or index value as a string.
}

// JoinPath constructs a string representation from a slice of Path segments.
// Keys are joined with '.', and indices are represented as '[i]'.
func JoinPath(path []Path) string <span class="cov0" title="0">{
        var sb strings.Builder
        for i, p := range path </span><span class="cov0" title="0">{
                switch p.Type </span>{
                case PathTypeKey:<span class="cov0" title="0">
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                sb.WriteString(".")
                        }</span>
                        <span class="cov0" title="0">sb.WriteString(p.Elem)</span>
                case PathTypeIndex:<span class="cov0" title="0">
                        sb.WriteString("[")
                        sb.WriteString(p.Elem)
                        sb.WriteString("]")</span>
                }
        }
        <span class="cov0" title="0">return sb.String()</span>
}

// SplitPath parses a string path into a slice of Path segments.
// It supports keys separated by '.' and indices enclosed in brackets (e.g., "users[0].name").
func SplitPath(key string) (_ []Path, err error) <span class="cov7" title="671">{
        if key == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid key '%s'", key)
        }</span>
        <span class="cov7" title="671">var (
                path        []Path
                lastPos     int
                lastChar    int32
                openBracket bool
        )
        for i, c := range key </span><span class="cov10" title="8011">{
                switch c </span>{
                case ' ':<span class="cov0" title="0">
                        return nil, fmt.Errorf("invalid key '%s'", key)</span>
                case '.':<span class="cov6" title="301">
                        if openBracket || lastChar == '.' </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid key '%s'", key)
                        }</span>
                        <span class="cov6" title="301">if lastChar != ']' </span><span class="cov6" title="301">{
                                path, err = appendKey(path, key[lastPos:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("invalid key '%s'", key)
                                }</span>
                        }
                        <span class="cov6" title="301">lastPos = i + 1
                        lastChar = c</span>
                case '[':<span class="cov0" title="0">
                        if openBracket || lastChar == '.' </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid key '%s'", key)
                        }</span>
                        <span class="cov0" title="0">if i &gt; 0 &amp;&amp; lastChar != ']' </span><span class="cov0" title="0">{
                                path, err = appendKey(path, key[lastPos:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("invalid key '%s'", key)
                                }</span>
                        }
                        <span class="cov0" title="0">openBracket = true
                        lastPos = i + 1
                        lastChar = c</span>
                case ']':<span class="cov0" title="0">
                        if !openBracket </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid key '%s'", key)
                        }</span>
                        <span class="cov0" title="0">path, err = appendIndex(path, key[lastPos:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid key '%s'", key)
                        }</span>
                        <span class="cov0" title="0">openBracket = false
                        lastPos = i + 1
                        lastChar = c</span>
                default:<span class="cov9" title="7710">
                        if lastChar == ']' </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid key '%s'", key)
                        }</span>
                        <span class="cov9" title="7710">lastChar = c</span>
                }
        }
        <span class="cov7" title="671">if openBracket || lastChar == '.' </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid key '%s'", key)
        }</span>
        <span class="cov7" title="671">if lastChar != ']' </span><span class="cov7" title="671">{
                path, err = appendKey(path, key[lastPos:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid key '%s'", key)
                }</span>
        }
        <span class="cov7" title="671">return path, nil</span>
}

// appendKey appends a key segment to the path.
func appendKey(path []Path, s string) ([]Path, error) <span class="cov7" title="972">{
        path = append(path, Path{PathTypeKey, s})
        return path, nil
}</span>

// appendIndex appends an index segment to the path.
func appendIndex(path []Path, s string) ([]Path, error) <span class="cov0" title="0">{
        _, err := strconv.ParseUint(s, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid key")
        }</span>
        <span class="cov0" title="0">path = append(path, Path{PathTypeIndex, s})
        return path, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package storage

import (
        "errors"
        "fmt"

        "github.com/go-spring/spring-core/util"
)

// treeNode represents a node in the hierarchical key path tree.
// Each node tracks the type of its path segment and its child nodes.
type treeNode struct {
        Type PathType
        Data map[string]*treeNode
}

// Storage stores hierarchical key-value pairs and tracks their structure using a tree.
// It supports nested paths and detects structural conflicts when paths differ in type.
type Storage struct {
        root *treeNode         // Root of the hierarchical key path tree
        data map[string]string // Flat key-value storage for exact key matches
}

// NewStorage creates and initializes a new Storage instance.
func NewStorage() *Storage <span class="cov5" title="35">{
        return &amp;Storage{
                data: make(map[string]string),
        }
}</span>

// RawData returns the underlying flat key-value map.
// Note: This exposes internal state; use with caution.
func (s *Storage) RawData() map[string]string <span class="cov9" title="510">{
        return s.data
}</span>

// SubKeys returns the immediate subkeys under the given key path.
// It walks the tree structure and returns child elements if the path exists.
// Returns an error if there's a type conflict along the path.
func (s *Storage) SubKeys(key string) (_ []string, err error) <span class="cov1" title="1">{
        var path []Path
        if key != "" </span><span class="cov1" title="1">{
                if path, err = SplitPath(key); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov1" title="1">if s.root == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov1" title="1">n := s.root
        for i, pathNode := range path </span><span class="cov1" title="1">{
                if n == nil || pathNode.Type != n.Type </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("property conflict at path %s", JoinPath(path[:i+1]))
                }</span>
                <span class="cov1" title="1">v, ok := n.Data[pathNode.Elem]
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov1" title="1">n = v</span>
        }

        <span class="cov1" title="1">if n == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("property conflict at path %s", key)
        }</span>
        <span class="cov1" title="1">return util.OrderedMapKeys(n.Data), nil</span>
}

// Has returns true if the given key exists in the storage,
// either as a direct value or as a valid path in the hierarchical tree structure.
func (s *Storage) Has(key string) bool <span class="cov5" title="27">{
        if key == "" || s.root == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov5" title="27">if _, ok := s.data[key]; ok </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov5" title="26">path, err := SplitPath(key)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov5" title="26">n := s.root
        for _, node := range path </span><span class="cov6" title="48">{
                if n == nil || node.Type != n.Type </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov6" title="48">v, ok := n.Data[node.Elem]
                if !ok </span><span class="cov5" title="25">{
                        return false
                }</span>
                <span class="cov5" title="23">n = v</span>
        }
        <span class="cov1" title="1">return true</span>
}

// Set inserts a key-value pair into the storage.
// It also constructs or extends the corresponding hierarchical path in the tree.
// Returns an error if there is a type conflict or if the key is empty.
func (s *Storage) Set(key, val string) error <span class="cov9" title="644">{
        if key == "" </span><span class="cov0" title="0">{
                return errors.New("key is empty")
        }</span>

        <span class="cov9" title="644">path, err := SplitPath(key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Initialize tree root if empty
        <span class="cov9" title="644">if s.root == nil </span><span class="cov5" title="35">{
                s.root = &amp;treeNode{
                        Type: path[0].Type,
                        Data: make(map[string]*treeNode),
                }
        }</span>

        <span class="cov9" title="644">n := s.root
        for i, pathNode := range path </span><span class="cov10" title="884">{
                if n == nil || pathNode.Type != n.Type </span><span class="cov0" title="0">{
                        return fmt.Errorf("property conflict at path %s", JoinPath(path[:i+1]))
                }</span>
                <span class="cov10" title="884">v, ok := n.Data[pathNode.Elem]
                if !ok </span><span class="cov9" title="769">{
                        if i &lt; len(path)-1 </span><span class="cov7" title="130">{
                                v = &amp;treeNode{
                                        Type: path[i+1].Type,
                                        Data: make(map[string]*treeNode),
                                }
                        }</span>
                        <span class="cov9" title="769">n.Data[pathNode.Elem] = v</span>
                }
                <span class="cov10" title="884">n = v</span>
        }
        <span class="cov9" title="644">if n != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("property conflict at path %s", key)
        }</span>

        <span class="cov9" title="644">s.data[key] = val
        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package bootstrap

import (
        "context"
        "fmt"
        "os"
        "time"

        "github.com/go-spring/spring-core/gs"
)

func init() <span class="cov1" title="1">{
        gs.B.FuncRunner(initRemoteConfig).OnProfiles("online")
}</span>

// initRemoteConfig initializes the remote configuration setup
func initRemoteConfig() error <span class="cov1" title="1">{
        if err := getRemoteConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">gs.FuncJob(refreshRemoteConfig)
        return nil</span>
}

// refreshRemoteConfig periodically refreshes the remote configuration
func refreshRemoteConfig(ctx context.Context) error <span class="cov1" title="1">{
        for </span><span class="cov10" title="5">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        fmt.Println("config updater exit")
                        return nil</span>
                case &lt;-time.After(time.Millisecond * 500):<span class="cov8" title="4">
                        if err := getRemoteConfig(); err != nil </span><span class="cov0" title="0">{
                                fmt.Println("get remote config error:", err)
                                return err
                        }</span>
                        <span class="cov8" title="4">if err := gs.RefreshProperties(); err != nil </span><span class="cov0" title="0">{
                                fmt.Println("refresh properties error:", err)
                                return err
                        }</span>
                        <span class="cov8" title="4">fmt.Println("refresh properties success")</span>
                }
        }
}

// getRemoteConfig fetches and writes the remote configuration to a local file
func getRemoteConfig() error <span class="cov10" title="5">{
        err := os.MkdirAll("./conf/remote", os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="5">const data = `
server.addr=0.0.0.0:9090

log.access.name=access.log
log.access.dir=./log

log.biz.name=biz.log
log.biz.dir=./log

log.dao.name=dao.log
log.dao.dir=./log

refresh_time=%v`

        const file = "conf/remote/app-online.properties"
        str := fmt.Sprintf(data, time.Now().UnixMilli())
        return os.WriteFile(file, []byte(str), os.ModePerm)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package log

import (
        "log/slog"
        "os"
        "path/filepath"

        "github.com/go-spring/spring-core/conf"
        "github.com/go-spring/spring-core/gs"
)

func init() <span class="cov1" title="1">{
        gs.GroupRegister(func(p conf.Properties) ([]*gs.BeanDefinition, error) </span><span class="cov1" title="1">{
                var loggers map[string]struct {
                        Name string `value:"${name}"`
                        Dir  string `value:"${dir}"`
                }
                err := p.Bind(&amp;loggers, "${log}")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">var ret []*gs.BeanDefinition
                for k, l := range loggers </span><span class="cov10" title="3">{
                        var (
                                f    *os.File
                                flag = os.O_WRONLY | os.O_CREATE | os.O_APPEND
                        )
                        f, err = os.OpenFile(filepath.Join(l.Dir, l.Name), flag, os.ModePerm)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov10" title="3">o := slog.New(slog.NewTextHandler(f, nil))
                        b := gs.NewBean(o).Name(k).Destroy(func(_ *slog.Logger) </span><span class="cov10" title="3">{
                                _ = f.Close()
                        }</span>)
                        <span class="cov10" title="3">ret = append(ret, b)</span>
                }
                <span class="cov1" title="1">return ret, nil</span>
        })
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package httpsvr

import (
        "fmt"
        "log/slog"
        "net/http"

        "github.com/go-spring/spring-core/gs"
        "github.com/go-spring/spring-core/gs/examples/bookman/src/app/controller"
        "github.com/go-spring/spring-core/gs/examples/bookman/src/idl/http/proto"
)

func init() <span class="cov1" title="1">{
        gs.Provide(NewServeMux, gs.IndexArg(1, gs.TagArg("access")))
}</span>

// NewServeMux Creates a new HTTP request multiplexer and registers
// routes with access logging middleware.
func NewServeMux(c *controller.Controller, logger *slog.Logger) *http.ServeMux <span class="cov1" title="1">{
        mux := http.NewServeMux()
        proto.RegisterRouter(mux, c, Access(logger))
        return mux
}</span>

// Access is a middleware to log incoming HTTP requests.
func Access(logger *slog.Logger) func(http.Handler) http.Handler <span class="cov1" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="4">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="5">{
                        logger.Info(fmt.Sprintf("access %s %s", r.Method, r.URL.Path))
                        next.ServeHTTP(w, r)
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package controller

import (
        "encoding/json"
        "net/http"

        "github.com/go-spring/spring-core/gs/examples/bookman/src/biz/service/book_service"
        "github.com/go-spring/spring-core/gs/examples/bookman/src/dao/book_dao"
)

type BookController struct {
        BookService *book_service.BookService `autowire:""`
}

// ListBooks handles the HTTP request to list all books.
func (c *BookController) ListBooks(w http.ResponseWriter, r *http.Request) <span class="cov10" title="5">{
        books, err := c.BookService.ListBooks()
        if err != nil </span><span class="cov0" title="0">{
                _, _ = w.Write([]byte(err.Error()))
                return
        }</span>
        <span class="cov10" title="5">_ = json.NewEncoder(w).Encode(books)</span>
}

// GetBook handles the HTTP request to get details of a specific book by ISBN.
func (c *BookController) GetBook(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        isbn := r.PathValue("isbn")
        book, err := c.BookService.GetBook(isbn)
        if err != nil </span><span class="cov0" title="0">{
                _, _ = w.Write([]byte(err.Error()))
                return
        }</span>
        <span class="cov0" title="0">_ = json.NewEncoder(w).Encode(book)</span>
}

// SaveBook handles the HTTP request to save a new book.
func (c *BookController) SaveBook(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var book book_dao.Book
        if err := json.NewDecoder(r.Body).Decode(&amp;book); err != nil </span><span class="cov0" title="0">{
                _, _ = w.Write([]byte(err.Error()))
                return
        }</span>
        <span class="cov0" title="0">if err := c.BookService.SaveBook(book); err != nil </span><span class="cov0" title="0">{
                _, _ = w.Write([]byte(err.Error()))
                return
        }</span>
        <span class="cov0" title="0">_ = json.NewEncoder(w).Encode("OK!")</span>
}

// DeleteBook handles the HTTP request to delete a book by ISBN.
func (c *BookController) DeleteBook(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        isbn := r.PathValue("isbn")
        err := c.BookService.DeleteBook(isbn)
        if err != nil </span><span class="cov0" title="0">{
                _, _ = w.Write([]byte(err.Error()))
                return
        }</span>
        <span class="cov0" title="0">_ = json.NewEncoder(w).Encode("OK!")</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package controller

import (
        "github.com/go-spring/spring-core/gs"
)

func init() <span class="cov8" title="1">{
        gs.Object(&amp;Controller{})
}</span>

type Controller struct {
        BookController
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package job

import (
        "context"
        "fmt"
        "time"

        "github.com/go-spring/spring-core/gs"
)

func init() <span class="cov1" title="1">{
        gs.Object(&amp;Job{}).AsJob()
}</span>

type Job struct{}

// Run executes the background job until the context is canceled.
func (x *Job) Run(ctx context.Context) error <span class="cov1" title="1">{
        for </span><span class="cov10" title="9">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0"> // Gracefully exit when context is canceled
                        fmt.Println("job exit")
                        return nil</span>
                default:<span class="cov10" title="9">
                        if gs.Exiting() </span><span class="cov0" title="0">{ // Check if the system is shutting down
                                return nil
                        }</span>
                        <span class="cov10" title="9">time.Sleep(time.Millisecond * 300)
                        fmt.Println(time.Now().UnixMilli(), "job sleep end")</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package book_service

import (
        "fmt"
        "log/slog"
        "strconv"

        "github.com/go-spring/spring-core/gs"
        "github.com/go-spring/spring-core/gs/examples/bookman/src/dao/book_dao"
        "github.com/go-spring/spring-core/gs/examples/bookman/src/idl/http/proto"
        "github.com/go-spring/spring-core/gs/examples/bookman/src/sdk/book_sdk"
)

func init() <span class="cov1" title="1">{
        gs.Object(&amp;BookService{})
}</span>

type BookService struct {
        BookDao     *book_dao.BookDao `autowire:""`
        BookSDK     *book_sdk.BookSDK `autowire:""`
        Logger      *slog.Logger      `autowire:"biz"`
        RefreshTime gs.Dync[int64]    `value:"${refresh_time:=0}"`
}

// ListBooks retrieves all books from the database and enriches them with
// pricing and refresh time.
func (s *BookService) ListBooks() ([]proto.Book, error) <span class="cov10" title="5">{
        books, err := s.BookDao.ListBooks()
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error(fmt.Sprintf("ListBooks return err: %s", err.Error()))
                return nil, err
        }</span>
        <span class="cov10" title="5">ret := make([]proto.Book, 0, len(books))
        for _, book := range books </span><span class="cov10" title="5">{
                ret = append(ret, proto.Book{
                        ISBN:        book.ISBN,
                        Title:       book.Title,
                        Author:      book.Author,
                        Publisher:   book.Publisher,
                        Price:       s.BookSDK.GetPrice(book.ISBN),
                        RefreshTime: strconv.FormatInt(s.RefreshTime.Value(), 10),
                })
        }</span>
        <span class="cov10" title="5">return ret, nil</span>
}

// GetBook retrieves a single book by its ISBN and enriches it with
// pricing and refresh time.
func (s *BookService) GetBook(isbn string) (proto.Book, error) <span class="cov0" title="0">{
        book, err := s.BookDao.GetBook(isbn)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error(fmt.Sprintf("GetBook return err: %s", err.Error()))
                return proto.Book{}, err
        }</span>
        <span class="cov0" title="0">return proto.Book{
                ISBN:        book.ISBN,
                Title:       book.Title,
                Author:      book.Author,
                Publisher:   book.Publisher,
                Price:       s.BookSDK.GetPrice(book.ISBN),
                RefreshTime: strconv.FormatInt(s.RefreshTime.Value(), 10),
        }, nil</span>
}

// SaveBook stores a new book in the database.
func (s *BookService) SaveBook(book book_dao.Book) error <span class="cov0" title="0">{
        return s.BookDao.SaveBook(book)
}</span>

// DeleteBook removes a book from the database by its ISBN.
func (s *BookService) DeleteBook(isbn string) error <span class="cov0" title="0">{
        return s.BookDao.DeleteBook(isbn)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package book_dao

import (
        "log/slog"
        "maps"
        "slices"
        "sort"

        "github.com/go-spring/spring-core/gs"
)

func init() <span class="cov1" title="1">{
        gs.Object(&amp;BookDao{Store: map[string]Book{
                "978-0134190440": {
                        Title:     "The Go Programming Language",
                        Author:    "Alan A. A. Donovan, Brian W. Kernighan",
                        ISBN:      "978-0134190440",
                        Publisher: "Addison-Wesley",
                },
        }})
}</span>

type Book struct {
        Title     string `json:"title"`
        Author    string `json:"author"`
        ISBN      string `json:"isbn"`
        Publisher string `json:"publisher"`
}

type BookDao struct {
        Store  map[string]Book
        Logger *slog.Logger `autowire:"dao"`
}

// ListBooks returns a sorted list of all books in the store.
func (dao *BookDao) ListBooks() ([]Book, error) <span class="cov10" title="5">{
        r := slices.Collect(maps.Values(dao.Store))
        sort.Slice(r, func(i, j int) bool </span><span class="cov0" title="0">{
                return r[i].ISBN &lt; r[j].ISBN
        }</span>)
        <span class="cov10" title="5">return r, nil</span>
}

// GetBook retrieves a book by its ISBN.
func (dao *BookDao) GetBook(isbn string) (Book, error) <span class="cov0" title="0">{
        r, _ := dao.Store[isbn]
        return r, nil
}</span>

// SaveBook adds or updates a book in the store.
func (dao *BookDao) SaveBook(book Book) error <span class="cov0" title="0">{
        dao.Store[book.ISBN] = book
        return nil
}</span>

// DeleteBook removes a book from the store by its ISBN.
func (dao *BookDao) DeleteBook(isbn string) error <span class="cov0" title="0">{
        delete(dao.Store, isbn)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package proto

import (
        "net/http"
)

type Book struct {
        Title       string `json:"title"`
        Author      string `json:"author"`
        ISBN        string `json:"isbn"`
        Publisher   string `json:"publisher"`
        Price       string `json:"price"`
        RefreshTime string `json:"refreshTime"`
}

type Controller interface {
        ListBooks(w http.ResponseWriter, r *http.Request)
        GetBook(w http.ResponseWriter, r *http.Request)
        SaveBook(w http.ResponseWriter, r *http.Request)
        DeleteBook(w http.ResponseWriter, r *http.Request)
}

func RegisterRouter(mux *http.ServeMux, c Controller, wrap func(next http.Handler) http.Handler) <span class="cov8" title="1">{
        mux.Handle("GET /books", wrap(http.HandlerFunc(c.ListBooks)))
        mux.Handle("GET /books/{isbn}", wrap(http.HandlerFunc(c.GetBook)))
        mux.Handle("POST /books", wrap(http.HandlerFunc(c.SaveBook)))
        mux.Handle("DELETE /books/{isbn}", wrap(http.HandlerFunc(c.DeleteBook)))
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package book_sdk

import (
        "github.com/go-spring/spring-core/gs"
)

func init() <span class="cov1" title="1">{
        gs.Object(&amp;BookSDK{})
}</span>

type BookSDK struct{}

// GetPrice returns a fixed price for any book.
func (s *BookSDK) GetPrice(isbn string) string <span class="cov10" title="5">{
        return "￥10"
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs

import (
        "context"
        "fmt"
        "reflect"
        "strings"

        "github.com/go-spring/spring-core/conf"
        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/gs/internal/gs_app"
        "github.com/go-spring/spring-core/gs/internal/gs_arg"
        "github.com/go-spring/spring-core/gs/internal/gs_bean"
        "github.com/go-spring/spring-core/gs/internal/gs_cond"
        "github.com/go-spring/spring-core/gs/internal/gs_conf"
        "github.com/go-spring/spring-core/gs/internal/gs_dync"
)

const (
        Version = "go-spring@v1.2.0.rc2"
        Website = "https://go-spring.com/"
)

// As returns the [reflect.Type] of the given interface type.
func As[T any]() reflect.Type <span class="cov0" title="0">{
        return gs.As[T]()
}</span>

/************************************ arg ***********************************/

type Arg = gs.Arg

// TagArg returns a TagArg with the specified tag.
func TagArg(tag string) Arg <span class="cov6" title="5">{
        return gs_arg.Tag(tag)
}</span>

// ValueArg returns a ValueArg with the specified value.
func ValueArg(v interface{}) Arg <span class="cov0" title="0">{
        return gs_arg.Value(v)
}</span>

// IndexArg returns an IndexArg with the specified index and argument.
func IndexArg(n int, arg Arg) Arg <span class="cov5" title="4">{
        return gs_arg.Index(n, arg)
}</span>

// BindArg returns an BindArg for the specified function and arguments.
func BindArg(fn interface{}, args ...Arg) *gs_arg.BindArg <span class="cov4" title="3">{
        return gs_arg.Bind(fn, args...)
}</span>

/************************************ cond ***********************************/

type (
        CondFunc    = gs.CondFunc
        Condition   = gs.Condition
        CondContext = gs.CondContext
)

// OnFunc creates a Condition based on the provided function.
func OnFunc(fn CondFunc) Condition <span class="cov0" title="0">{
        return gs_cond.OnFunc(fn)
}</span>

// OnProperty creates a Condition based on a property name and options.
func OnProperty(name string) gs_cond.OnPropertyInterface <span class="cov5" title="4">{
        return gs_cond.OnProperty(name)
}</span>

// OnMissingProperty creates a Condition that checks for a missing property.
func OnMissingProperty(name string) Condition <span class="cov0" title="0">{
        return gs_cond.OnMissingProperty(name)
}</span>

// OnBean creates a Condition for when a specific bean exists.
func OnBean[T any](name ...string) Condition <span class="cov1" title="1">{
        return gs_cond.OnBean[T](name...)
}</span>

// OnMissingBean creates a Condition for when a specific bean is missing.
func OnMissingBean[T any](name ...string) Condition <span class="cov0" title="0">{
        return gs_cond.OnMissingBean[T](name...)
}</span>

// OnSingleBean creates a Condition for when only one instance of a bean exists.
func OnSingleBean[T any](name ...string) Condition <span class="cov0" title="0">{
        return gs_cond.OnSingleBean[T](name...)
}</span>

// RegisterExpressFunc registers a custom expression function.
func RegisterExpressFunc(name string, fn interface{}) <span class="cov0" title="0">{
        gs_cond.RegisterExpressFunc(name, fn)
}</span>

// OnExpression creates a Condition based on a custom expression.
func OnExpression(expression string) Condition <span class="cov0" title="0">{
        return gs_cond.OnExpression(expression)
}</span>

// Not creates a Condition that negates the given Condition.
func Not(c Condition) Condition <span class="cov0" title="0">{
        return gs_cond.Not(c)
}</span>

// Or creates a Condition that is true if any of the given Conditions are true.
func Or(conditions ...Condition) Condition <span class="cov0" title="0">{
        return gs_cond.Or(conditions...)
}</span>

// And creates a Condition that is true if all the given Conditions are true.
func And(conditions ...Condition) Condition <span class="cov0" title="0">{
        return gs_cond.And(conditions...)
}</span>

// None creates a Condition that is true if none of the given Conditions are true.
func None(conditions ...Condition) Condition <span class="cov0" title="0">{
        return gs_cond.None(conditions...)
}</span>

/************************************ ioc ************************************/

type (
        Dync[T any] = gs_dync.Value[T]
)

type (
        RegisteredBean = gs.RegisteredBean
        BeanDefinition = gs.BeanDefinition
)

type (
        BeanSelector    = gs.BeanSelector
        BeanInitFunc    = gs.BeanInitFunc
        BeanDestroyFunc = gs.BeanDestroyFunc
)

// NewBean creates a new BeanDefinition.
func NewBean(objOrCtor interface{}, ctorArgs ...gs.Arg) *gs.BeanDefinition <span class="cov4" title="3">{
        return gs_bean.NewBean(objOrCtor, ctorArgs...).Caller(1)
}</span>

// BeanSelectorFor returns a BeanSelector for the given type.
func BeanSelectorFor[T any](name ...string) BeanSelector <span class="cov0" title="0">{
        return gs.BeanSelectorFor[T](name...)
}</span>

/*********************************** app *************************************/

type (
        Runner      = gs.Runner
        Job         = gs.Job
        Server      = gs.Server
        ReadySignal = gs.ReadySignal
)

var B = gs_app.NewBoot()

// funcRunner is a function type that implements the Runner interface.
type funcRunner func() error

func (f funcRunner) Run() error <span class="cov0" title="0">{
        return f()
}</span>

// FuncRunner creates a Runner from a function.
func FuncRunner(fn func() error) *RegisteredBean <span class="cov0" title="0">{
        return Object(funcRunner(fn)).AsRunner().Caller(1)
}</span>

// funcJob is a function type that implements the Job interface.
type funcJob func(ctx context.Context) error

func (f funcJob) Run(ctx context.Context) error <span class="cov3" title="2">{
        return f(ctx)
}</span>

// FuncJob creates a Job from a function.
func FuncJob(fn func(ctx context.Context) error) *RegisteredBean <span class="cov3" title="2">{
        return Object(funcJob(fn)).AsJob().Caller(1)
}</span>

// Run runs the app and waits for an interrupt signal to exit.
func Run() error <span class="cov1" title="1">{
        printBanner()
        if err := B.(*gs_app.BootImpl).Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">B = nil
        return gs_app.GS.Run()</span>
}

// Exiting returns a boolean indicating whether the application is exiting.
func Exiting() bool <span class="cov8" title="9">{
        return gs_app.GS.Exiting()
}</span>

// ShutDown shuts down the app with an optional message.
func ShutDown() <span class="cov1" title="1">{
        gs_app.GS.ShutDown()
}</span>

// Config returns the app configuration.
func Config() *gs_conf.AppConfig <span class="cov5" title="4">{
        return gs_app.GS.P
}</span>

// Object registers a bean definition for a given object.
func Object(i interface{}) *RegisteredBean <span class="cov7" title="7">{
        b := gs_bean.NewBean(reflect.ValueOf(i))
        return gs_app.GS.C.Register(b).Caller(1)
}</span>

// Provide registers a bean definition for a given constructor.
func Provide(ctor interface{}, args ...Arg) *RegisteredBean <span class="cov4" title="3">{
        b := gs_bean.NewBean(ctor, args...)
        return gs_app.GS.C.Register(b).Caller(1)
}</span>

// Register registers a bean definition.
func Register(b *BeanDefinition) *RegisteredBean <span class="cov0" title="0">{
        return gs_app.GS.C.Register(b)
}</span>

// GroupRegister registers a group of bean definitions.
func GroupRegister(fn func(p conf.Properties) ([]*BeanDefinition, error)) <span class="cov1" title="1">{
        gs_app.GS.C.GroupRegister(fn)
}</span>

// RefreshProperties refreshes the app configuration.
func RefreshProperties() error <span class="cov5" title="4">{
        p, err := Config().Refresh()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="4">return gs_app.GS.C.RefreshProperties(p)</span>
}

/********************************** banner ***********************************/

var appBanner = `
   ____    ___            ____    ____    ____    ___   _   _    ____ 
  / ___|  / _ \          / ___|  |  _ \  |  _ \  |_ _| | \ | |  / ___|
 | |  _  | | | |  _____  \___ \  | |_) | | |_) |  | |  |  \| | | |  _ 
 | |_| | | |_| | |_____|  ___) | |  __/  |  _ &lt;   | |  | |\  | | |_| |
  \____|  \___/          |____/  |_|     |_| \_\ |___| |_| \_|  \____| 
`

// Banner sets a custom app banner.
func Banner(banner string) <span class="cov1" title="1">{
        appBanner = banner
}</span>

// printBanner prints the app banner.
func printBanner() <span class="cov1" title="1">{
        if len(appBanner) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">if appBanner[0] != '\n' </span><span class="cov0" title="0">{
                fmt.Println()
        }</span>

        <span class="cov1" title="1">maxLength := 0
        for _, s := range strings.Split(appBanner, "\n") </span><span class="cov7" title="7">{
                fmt.Printf("\x1b[36m%s\x1b[0m\n", s) // CYAN
                if len(s) &gt; maxLength </span><span class="cov1" title="1">{
                        maxLength = len(s)
                }</span>
        }

        <span class="cov1" title="1">if appBanner[len(appBanner)-1] != '\n' </span><span class="cov0" title="0">{
                fmt.Println()
        }</span>

        <span class="cov1" title="1">var padding []byte
        if n := (maxLength - len(Version)) / 2; n &gt; 0 </span><span class="cov1" title="1">{
                padding = make([]byte, n)
                for i := range padding </span><span class="cov10" title="15">{
                        padding[i] = ' '
                }</span>
        }
        <span class="cov1" title="1">fmt.Println(string(padding) + Version + "\n")</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs

import (
        "context"
        "net"
        "net/http"
        "time"
)

func init() <span class="cov1" title="1">{
        Provide(
                NewSimpleHttpServer,
                IndexArg(1, BindArg(SetHttpServerAddr, TagArg("${http.server.addr:=0.0.0.0:9090}"))),
                IndexArg(1, BindArg(SetHttpServerReadTimeout, TagArg("${http.server.readTimeout:=5s}"))),
                IndexArg(1, BindArg(SetHttpServerWriteTimeout, TagArg("${http.server.writeTimeout:=5s}"))),
        ).Condition(
                OnBean[*http.ServeMux](),
                OnProperty(EnableServersProp).HavingValue("true").MatchIfMissing(),
                OnProperty(EnableSimpleHttpServerProp).HavingValue("true").MatchIfMissing(),
        ).AsServer()
}</span>

// HttpServerConfig holds configuration options for the HTTP server.
type HttpServerConfig struct {
        Address      string        // The address to bind the server to.
        ReadTimeout  time.Duration // The read timeout duration.
        WriteTimeout time.Duration // The write timeout duration.
}

// HttpServerOption is a function type for setting options on HttpServerConfig.
type HttpServerOption func(arg *HttpServerConfig)

// SetHttpServerAddr sets the address of the HTTP server.
func SetHttpServerAddr(addr string) HttpServerOption <span class="cov5" title="2">{
        return func(arg *HttpServerConfig) </span><span class="cov5" title="2">{
                arg.Address = addr
        }</span>
}

// SetHttpServerReadTimeout sets the read timeout for the HTTP server.
func SetHttpServerReadTimeout(timeout time.Duration) HttpServerOption <span class="cov1" title="1">{
        return func(arg *HttpServerConfig) </span><span class="cov1" title="1">{
                arg.ReadTimeout = timeout
        }</span>
}

// SetHttpServerWriteTimeout sets the write timeout for the HTTP server.
func SetHttpServerWriteTimeout(timeout time.Duration) HttpServerOption <span class="cov1" title="1">{
        return func(arg *HttpServerConfig) </span><span class="cov1" title="1">{
                arg.WriteTimeout = timeout
        }</span>
}

// SimpleHttpServer wraps a [http.Server] instance.
type SimpleHttpServer struct {
        svr *http.Server // The HTTP server instance.
}

// NewSimpleHttpServer creates a new instance of SimpleHttpServer.
func NewSimpleHttpServer(mux *http.ServeMux, opts ...HttpServerOption) *SimpleHttpServer <span class="cov5" title="2">{
        arg := &amp;HttpServerConfig{
                Address:      "0.0.0.0:9090",
                ReadTimeout:  time.Second * 5,
                WriteTimeout: time.Second * 5,
        }
        for _, opt := range opts </span><span class="cov10" title="4">{
                opt(arg)
        }</span>
        <span class="cov5" title="2">return &amp;SimpleHttpServer{svr: &amp;http.Server{
                Addr:         arg.Address,
                Handler:      mux,
                ReadTimeout:  arg.ReadTimeout,
                WriteTimeout: arg.WriteTimeout,
        }}</span>
}

// ListenAndServe starts the HTTP server and listens for incoming connections.
func (s *SimpleHttpServer) ListenAndServe(sig ReadySignal) error <span class="cov5" title="2">{
        ln, err := net.Listen("tcp", s.svr.Addr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="2">&lt;-sig.TriggerAndWait()
        return s.svr.Serve(ln)</span>
}

// Shutdown gracefully shuts down the HTTP server with the given context.
func (s *SimpleHttpServer) Shutdown(ctx context.Context) error <span class="cov5" title="2">{
        return s.svr.Shutdown(ctx)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//go:generate mockgen -build_flags="-mod=mod" -package=gs -source=gs.go -destination=gs_test_test.go -exclude_interfaces=BeanSelector,Condition,CondBean,Arg,ReadySignal,BeanInitFunc,BeanDestroyFunc

package gs

import (
        "context"
        "reflect"
        "strings"
        "unsafe"
)

// anyType is the [reflect.Type] of the [any] type.
var anyType = reflect.TypeFor[any]()

// As returns the [reflect.Type] of the given interface type.
// It ensures that the provided generic type parameter T is an interface.
// If T is not an interface, the function panics.
func As[T any]() reflect.Type <span class="cov6" title="6">{
        t := reflect.TypeFor[T]()
        if t.Kind() != reflect.Interface </span><span class="cov0" title="0">{
                panic("T must be interface")</span>
        }
        <span class="cov6" title="6">return t</span>
}

// BeanSelector is an interface for selecting beans.
type BeanSelector interface {
        // TypeAndName returns the type and name of the bean.
        TypeAndName() (reflect.Type, string)
}

// BeanSelectorImpl is an implementation of BeanSelector.
type BeanSelectorImpl struct {
        Type reflect.Type // The type of the bean
        Name string       // The name of the bean
}

// BeanSelectorFor returns a BeanSelectorImpl for the given type.
// If a name is provided, it is set; otherwise, only the type is used.
func BeanSelectorFor[T any](name ...string) BeanSelector <span class="cov1" title="1">{
        if len(name) == 0 </span><span class="cov1" title="1">{
                return BeanSelectorImpl{Type: reflect.TypeFor[T]()}
        }</span>
        <span class="cov0" title="0">return BeanSelectorImpl{Type: reflect.TypeFor[T](), Name: name[0]}</span>
}

// TypeAndName returns the type and name of the bean.
func (s BeanSelectorImpl) TypeAndName() (reflect.Type, string) <span class="cov1" title="1">{
        return s.Type, s.Name
}</span>

func (s BeanSelectorImpl) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString("{")
        if s.Type != nil &amp;&amp; s.Type != anyType </span><span class="cov0" title="0">{
                sb.WriteString("Type:")
                sb.WriteString(s.Type.String())
        }</span>
        <span class="cov0" title="0">if s.Name != "" </span><span class="cov0" title="0">{
                if sb.Len() &gt; 1 </span><span class="cov0" title="0">{
                        sb.WriteString(",")
                }</span>
                <span class="cov0" title="0">sb.WriteString("Name:")
                sb.WriteString(s.Name)</span>
        }
        <span class="cov0" title="0">sb.WriteString("}")
        return sb.String()</span>
}

/************************************ cond ***********************************/

// Condition is an interface used for defining conditional logic
// when registering beans in the IoC container.
type Condition interface {
        // Matches checks whether the condition is satisfied.
        Matches(ctx CondContext) (bool, error)
}

// CondBean represents a bean with Name and Type.
type CondBean interface {
        Name() string
        Type() reflect.Type
}

// CondContext defines methods for the IoC container used by conditions.
type CondContext interface {
        // Has checks whether the IoC container has a property with the given key.
        Has(key string) bool
        // Prop retrieves the value of a property from the IoC container.
        Prop(key string, def ...string) string
        // Find searches for bean definitions matching the given BeanSelector.
        Find(s BeanSelector) ([]CondBean, error)
}

// CondFunc is a function type that determines whether a condition is satisfied.
type CondFunc func(ctx CondContext) (bool, error)

/************************************* arg ***********************************/

// Arg is an interface for retrieving argument values in function parameter binding.
type Arg interface {
        // GetArgValue retrieves the argument value based on the type.
        GetArgValue(ctx ArgContext, t reflect.Type) (reflect.Value, error)
}

// ArgContext defines methods for the IoC container used by Arg types.
type ArgContext interface {
        // Check checks if the given condition is met.
        Check(c Condition) (bool, error)
        // Bind binds property values to the provided [reflect.Value].
        Bind(v reflect.Value, tag string) error
        // Wire wires dependent beans to the provided [reflect.Value].
        Wire(v reflect.Value, tag string) error
}

/*********************************** app ************************************/

// Runner defines an interface for components that should run after
// all beans are injected but before the application servers start.
type Runner interface {
        Run() error
}

// Job defines an interface for components that run tasks with a given context
// after all beans are injected but before the application servers start.
type Job interface {
        Run(ctx context.Context) error
}

// ReadySignal defines an interface for components that can trigger a signal
// when the application is ready to serve requests.
type ReadySignal interface {
        TriggerAndWait() &lt;-chan struct{}
}

// Server defines an interface for managing the lifecycle of application servers,
// such as HTTP, gRPC, Thrift, or MQ servers. It includes methods for starting
// and shutting down the server gracefully.
type Server interface {
        ListenAndServe(sig ReadySignal) error
        Shutdown(ctx context.Context) error
}

/*********************************** bean ************************************/

// BeanID represents the unique identifier for a bean.
type BeanID struct {
        Type reflect.Type
        Name string
}

// BeanInitFunc defines the prototype for initialization functions.
// Examples: `func(bean)` or `func(bean) error`.
type BeanInitFunc = interface{}

// BeanDestroyFunc defines the prototype for destruction functions.
// Examples: `func(bean)` or `func(bean) error`.
type BeanDestroyFunc = interface{}

// Configuration holds parameters for bean setup configuration.
type Configuration struct {
        Includes []string // Methods to include
        Excludes []string // Methods to exclude
}

// BeanRegistration provides methods for configuring and registering bean metadata.
type BeanRegistration interface {
        Name() string
        Type() reflect.Type
        Value() reflect.Value
        SetName(name string)
        SetInit(fn BeanInitFunc)
        SetDestroy(fn BeanDestroyFunc)
        SetInitMethod(method string)
        SetDestroyMethod(method string)
        SetCondition(c ...Condition)
        SetDependsOn(selectors ...BeanSelector)
        SetExport(exports ...reflect.Type)
        SetConfiguration(c ...Configuration)
        SetCaller(skip int)
        OnProfiles(profiles string)
}

// beanBuilder helps configure a bean during its creation.
type beanBuilder[T any] struct {
        b BeanRegistration
}

// TypeAndName returns the type and name of the bean.
func (d *beanBuilder[T]) TypeAndName() (reflect.Type, string) <span class="cov0" title="0">{
        return d.b.Type(), d.b.Name()
}</span>

// GetArgValue returns the value of the bean.
func (d *beanBuilder[T]) GetArgValue(ctx ArgContext, t reflect.Type) (reflect.Value, error) <span class="cov0" title="0">{
        return d.b.Value(), nil
}</span>

// BeanRegistration returns the underlying BeanRegistration instance.
func (d *beanBuilder[T]) BeanRegistration() BeanRegistration <span class="cov9" title="16">{
        return d.b
}</span>

// Name sets the name of the bean.
func (d *beanBuilder[T]) Name(name string) *T <span class="cov5" title="4">{
        d.b.SetName(name)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// Init sets the initialization function for the bean.
func (d *beanBuilder[T]) Init(fn BeanInitFunc) *T <span class="cov0" title="0">{
        d.b.SetInit(fn)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// Destroy sets the destruction function for the bean.
func (d *beanBuilder[T]) Destroy(fn BeanDestroyFunc) *T <span class="cov4" title="3">{
        d.b.SetDestroy(fn)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// InitMethod sets the initialization function for the bean by method name.
func (d *beanBuilder[T]) InitMethod(method string) *T <span class="cov0" title="0">{
        d.b.SetInitMethod(method)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// DestroyMethod sets the destruction function for the bean by method name.
func (d *beanBuilder[T]) DestroyMethod(method string) *T <span class="cov0" title="0">{
        d.b.SetDestroyMethod(method)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// Condition sets the conditions for the bean.
func (d *beanBuilder[T]) Condition(c ...Condition) *T <span class="cov3" title="2">{
        d.b.SetCondition(c...)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// DependsOn sets the beans that this bean depends on.
func (d *beanBuilder[T]) DependsOn(selectors ...BeanSelector) *T <span class="cov0" title="0">{
        d.b.SetDependsOn(selectors...)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// AsRunner marks the bean as a Runner.
func (d *beanBuilder[T]) AsRunner() *T <span class="cov1" title="1">{
        d.b.SetExport(As[Runner]())
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// AsJob marks the bean as a Job.
func (d *beanBuilder[T]) AsJob() *T <span class="cov4" title="3">{
        d.b.SetExport(As[Job]())
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// AsServer marks the bean as a Server.
func (d *beanBuilder[T]) AsServer() *T <span class="cov3" title="2">{
        d.b.SetExport(As[Server]())
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// Export sets the interfaces that the bean will export.
func (d *beanBuilder[T]) Export(exports ...reflect.Type) *T <span class="cov0" title="0">{
        d.b.SetExport(exports...)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// Configuration applies the configuration parameters to the bean.
func (d *beanBuilder[T]) Configuration(c ...Configuration) *T <span class="cov0" title="0">{
        d.b.SetConfiguration(c...)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// Caller sets the caller information for the bean.
func (d *beanBuilder[T]) Caller(skip int) *T <span class="cov10" title="18">{
        d.b.SetCaller(skip)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// OnProfiles sets the profiles that the bean will be active in.
func (d *beanBuilder[T]) OnProfiles(profiles string) *T <span class="cov1" title="1">{
        d.b.OnProfiles(profiles)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// RegisteredBean represents a bean that has been registered in the IoC container.
type RegisteredBean struct {
        beanBuilder[RegisteredBean]
}

// NewRegisteredBean creates a new RegisteredBean instance.
func NewRegisteredBean(d BeanRegistration) *RegisteredBean <span class="cov8" title="13">{
        return &amp;RegisteredBean{
                beanBuilder: beanBuilder[RegisteredBean]{d},
        }
}</span>

// BeanDefinition represents a bean that has not yet been registered.
type BeanDefinition struct {
        beanBuilder[BeanDefinition]
}

// NewBeanDefinition creates a new BeanDefinition instance.
func NewBeanDefinition(d BeanRegistration) *BeanDefinition <span class="cov9" title="16">{
        return &amp;BeanDefinition{
                beanBuilder: beanBuilder[BeanDefinition]{d},
        }
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_app

import (
        "context"
        "errors"
        "net/http"
        "os"
        "os/signal"
        "sync"
        "sync/atomic"
        "syscall"
        "time"

        "github.com/go-spring/spring-core/conf"
        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/gs/internal/gs_conf"
        "github.com/go-spring/spring-core/gs/internal/gs_core"
        "github.com/go-spring/spring-core/util/goutil"
        "github.com/go-spring/spring-core/util/syslog"
)

// GS is the global application instance.
var GS = NewApp()

// App represents the core application, managing its lifecycle,
// configuration, and dependency injection.
type App struct {
        C *gs_core.Container
        P *gs_conf.AppConfig

        exiting atomic.Bool
        ctx     context.Context
        cancel  context.CancelFunc
        wg      sync.WaitGroup

        Runners []gs.Runner `autowire:"${spring.app.runners:=?}"`
        Jobs    []gs.Job    `autowire:"${spring.app.jobs:=?}"`
        Servers []gs.Server `autowire:"${spring.app.servers:=?}"`

        EnableJobs    bool `value:"${spring.app.enable-jobs:=true}"`
        EnableServers bool `value:"${spring.app.enable-servers:=true}"`

        ShutDownTimeout time.Duration `value:"${spring.app.shutdown-timeout:=15s}"`
}

// NewApp creates and initializes a new application instance.
func NewApp() *App <span class="cov1" title="1">{
        ctx, cancel := context.WithCancel(context.Background())
        return &amp;App{
                C:      gs_core.New(),
                P:      gs_conf.NewAppConfig(),
                ctx:    ctx,
                cancel: cancel,
        }
}</span>

// Run starts the application and listens for termination signals
// (e.g., SIGINT, SIGTERM). Upon receiving a signal, it initiates
// a graceful shutdown.
func (app *App) Run() error <span class="cov1" title="1">{
        app.C.Object(app)

        if err := app.Start(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // listens for OS termination signals
        <span class="cov1" title="1">go func() </span><span class="cov1" title="1">{
                ch := make(chan os.Signal, 1)
                signal.Notify(ch, os.Interrupt, syscall.SIGTERM)
                sig := &lt;-ch
                syslog.Infof("Received signal: %v", sig)
                app.ShutDown()
        }</span>()

        // waits for the shutdown signal
        <span class="cov1" title="1">&lt;-app.ctx.Done()
        app.Stop()
        return nil</span>
}

// Start initializes and starts the application. It performs configuration
// loading, IoC container refreshing, dependency injection, and runs
// runners, jobs and servers.
func (app *App) Start() error <span class="cov1" title="1">{
        var p conf.Properties

        // loads the layered app properties
        </span><span class="cov1" title="1">{
                var err error
                if p, err = app.P.Refresh(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // refreshes the container
        <span class="cov1" title="1">if err := app.C.Refresh(p); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // runs all runners
        <span class="cov1" title="1">for _, r := range app.Runners </span><span class="cov0" title="0">{
                if err := r.Run(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // runs all jobs
        <span class="cov1" title="1">if app.EnableJobs </span><span class="cov1" title="1">{
                for _, job := range app.Jobs </span><span class="cov5" title="3">{
                        goutil.GoFunc(func() </span><span class="cov5" title="3">{
                                defer func() </span><span class="cov3" title="2">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                app.ShutDown()
                                                panic(r)</span>
                                        }
                                }()
                                <span class="cov5" title="3">if err := job.Run(app.ctx); err != nil </span><span class="cov0" title="0">{
                                        syslog.Errorf("job run error: %s", err.Error())
                                        app.ShutDown()
                                }</span>
                        })
                }
        }

        // starts all servers
        <span class="cov1" title="1">if app.EnableServers </span><span class="cov1" title="1">{
                sig := NewReadySignal()
                for _, svr := range app.Servers </span><span class="cov3" title="2">{
                        sig.Add()
                        app.wg.Add(1)
                        goutil.GoFunc(func() </span><span class="cov3" title="2">{
                                defer app.wg.Done()
                                defer func() </span><span class="cov3" title="2">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                sig.Intercept()
                                                app.ShutDown()
                                                panic(r)</span>
                                        }
                                }()
                                <span class="cov3" title="2">err := svr.ListenAndServe(sig)
                                if err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                                        syslog.Errorf("server serve error: %s", err.Error())
                                        sig.Intercept()
                                        app.ShutDown()
                                }</span>
                        })
                }
                <span class="cov1" title="1">sig.Wait()
                if sig.Intercepted() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov1" title="1">syslog.Infof("ready to serve requests")
                sig.Close()</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// Stop gracefully shuts down the application, ensuring all servers and
// resources are properly closed.
func (app *App) Stop() <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), app.ShutDownTimeout)
        defer cancel()

        waitChan := make(chan struct{})
        goutil.GoFunc(func() </span><span class="cov1" title="1">{
                for _, svr := range app.Servers </span><span class="cov3" title="2">{
                        goutil.GoFunc(func() </span><span class="cov3" title="2">{
                                if err := svr.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                                        syslog.Errorf("shutdown server failed: %s", err.Error())
                                }</span>
                        })
                }
                <span class="cov1" title="1">app.wg.Wait()
                app.C.Close()
                waitChan &lt;- struct{}{}</span>
        })

        <span class="cov1" title="1">select </span>{
        case &lt;-waitChan:<span class="cov1" title="1">
                syslog.Infof("shutdown complete")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                syslog.Infof("shutdown timeout")</span>
        }
}

// Exiting returns a boolean indicating whether the application is exiting.
func (app *App) Exiting() bool <span class="cov10" title="9">{
        return app.exiting.Load()
}</span>

// ShutDown gracefully terminates the application. This method should
// be called to trigger a proper shutdown process.
func (app *App) ShutDown() <span class="cov1" title="1">{
        app.exiting.Store(true)
        app.cancel()
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_app

import (
        "reflect"

        "github.com/go-spring/spring-core/conf"
        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/gs/internal/gs_bean"
        "github.com/go-spring/spring-core/gs/internal/gs_conf"
        "github.com/go-spring/spring-core/gs/internal/gs_core"
)

// funcRunner is a function type that implements the Runner interface.
type funcRunner func() error

func (f funcRunner) Run() error <span class="cov8" title="1">{
        return f()
}</span>

// Boot defines the interface for application bootstrapping.
type Boot interface {
        Config() *gs_conf.BootConfig
        Object(i interface{}) *gs.RegisteredBean
        Provide(ctor interface{}, args ...gs.Arg) *gs.RegisteredBean
        Register(bd *gs.BeanDefinition) *gs.RegisteredBean
        FuncRunner(fn func() error) *gs.RegisteredBean
}

// BootImpl is the bootstrapper of the application.
type BootImpl struct {
        c *gs_core.Container
        p *gs_conf.BootConfig

        // flag indicates whether the bootstrapper has been used.
        flag bool

        Runners []gs.Runner `autowire:"${spring.boot.runners:=?}"`
}

// NewBoot creates a new Boot instance.
func NewBoot() Boot <span class="cov8" title="1">{
        return &amp;BootImpl{
                c: gs_core.New(),
                p: gs_conf.NewBootConfig(),
        }
}</span>

// Config returns the boot configuration.
func (b *BootImpl) Config() *gs_conf.BootConfig <span class="cov0" title="0">{
        return b.p
}</span>

// Object registers an object bean.
func (b *BootImpl) Object(i interface{}) *gs.RegisteredBean <span class="cov0" title="0">{
        b.flag = true
        bd := gs_bean.NewBean(reflect.ValueOf(i))
        return b.c.Register(bd).Caller(1)
}</span>

// Provide registers a bean using a constructor function.
func (b *BootImpl) Provide(ctor interface{}, args ...gs.Arg) *gs.RegisteredBean <span class="cov0" title="0">{
        b.flag = true
        bd := gs_bean.NewBean(ctor, args...)
        return b.c.Register(bd).Caller(1)
}</span>

// Register registers a BeanDefinition instance.
func (b *BootImpl) Register(bd *gs.BeanDefinition) *gs.RegisteredBean <span class="cov0" title="0">{
        b.flag = true
        return b.c.Register(bd)
}</span>

// FuncRunner creates a Runner from a function.
func (b *BootImpl) FuncRunner(fn func() error) *gs.RegisteredBean <span class="cov8" title="1">{
        b.flag = true
        bd := gs_bean.NewBean(reflect.ValueOf(funcRunner(fn)))
        return b.c.Register(bd).AsRunner().Caller(1)
}</span>

// Run executes the application's boot process.
func (b *BootImpl) Run() error <span class="cov8" title="1">{
        if !b.flag </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">b.c.Object(b)

        var p conf.Properties

        // Refresh the boot configuration.
        </span><span class="cov8" title="1">{
                var err error
                if p, err = b.p.Refresh(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Refresh the container.
        <span class="cov8" title="1">if err := b.c.Refresh(p); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Execute all registered runners.
        <span class="cov8" title="1">for _, r := range b.Runners </span><span class="cov8" title="1">{
                if err := r.Run(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">b.c.Close()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_app

import (
        "sync"
        "sync/atomic"
)

// ReadySignal is used to notify that the application is ready to serve requests.
type ReadySignal struct {
        wg sync.WaitGroup
        ch chan struct{}
        b  atomic.Bool
}

// NewReadySignal creates a new ReadySignal instance.
func NewReadySignal() *ReadySignal <span class="cov1" title="1">{
        return &amp;ReadySignal{
                ch: make(chan struct{}),
        }
}</span>

// Add increments the WaitGroup counter.
func (s *ReadySignal) Add() <span class="cov10" title="2">{
        s.wg.Add(1)
}</span>

// TriggerAndWait marks an operation as done by decrementing the WaitGroup counter,
// and then returns the readiness signal channel for waiting.
func (s *ReadySignal) TriggerAndWait() &lt;-chan struct{} <span class="cov10" title="2">{
        s.wg.Done()
        return s.ch
}</span>

// Intercepted returns true if the signal has been intercepted.
func (s *ReadySignal) Intercepted() bool <span class="cov1" title="1">{
        return s.b.Load()
}</span>

// Intercept marks the signal as intercepted.
func (s *ReadySignal) Intercept() <span class="cov0" title="0">{
        s.b.Store(true)
        s.wg.Done()
}</span>

// Wait blocks until all WaitGroup counters reach zero.
func (s *ReadySignal) Wait() <span class="cov1" title="1">{
        s.wg.Wait()
}</span>

// Close closes the signal channel, notifying all goroutines waiting on it.
func (s *ReadySignal) Close() <span class="cov1" title="1">{
        close(s.ch)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_arg

import (
        "errors"
        "fmt"
        "reflect"
        "runtime"

        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/util"
        "github.com/go-spring/spring-core/util/errutil"
)

// TagArg represents an argument resolved using a tag for property binding or dependency injection.
type TagArg struct {
        Tag string
}

// Tag creates a TagArg with the given tag.
func Tag(tag string) gs.Arg <span class="cov10" title="12">{
        return TagArg{Tag: tag}
}</span>

// GetArgValue resolves the tag to a value based on the target type.
// For primitive types (int, string), it binds from configuration.
// For structs/interfaces, it wires dependencies from the container.
// It returns an error if the type is neither bindable nor injectable.
func (arg TagArg) GetArgValue(ctx gs.ArgContext, t reflect.Type) (reflect.Value, error) <span class="cov8" title="7">{

        // Binds property values based on the argument type.
        if util.IsPropBindingTarget(t) </span><span class="cov6" title="4">{
                v := reflect.New(t).Elem()
                if err := ctx.Bind(v, arg.Tag); err != nil </span><span class="cov0" title="0">{
                        return reflect.Value{}, errutil.WrapError(err, "TagArg::GetArgValue error")
                }</span>
                <span class="cov6" title="4">return v, nil</span>
        }

        // Wires dependent beans based on the argument type.
        <span class="cov4" title="3">if util.IsBeanInjectionTarget(t) </span><span class="cov4" title="3">{
                v := reflect.New(t).Elem()
                if err := ctx.Wire(v, arg.Tag); err != nil </span><span class="cov0" title="0">{
                        return reflect.Value{}, errutil.WrapError(err, "TagArg::GetArgValue error")
                }</span>
                <span class="cov4" title="3">return v, nil</span>
        }

        <span class="cov0" title="0">err := fmt.Errorf("unsupported argument type: %s", t.String())
        return reflect.Value{}, errutil.WrapError(err, "TagArg::GetArgValue error")</span>
}

// IndexArg represents an argument with an explicit positional index in the function signature.
type IndexArg struct {
        Idx int    //The positional index (0-based).
        Arg gs.Arg //The wrapped argument value.
}

// Index creates an IndexArg with the given index and argument.
func Index(n int, arg gs.Arg) gs.Arg <span class="cov6" title="4">{
        return IndexArg{Idx: n, Arg: arg}
}</span>

// GetArgValue panics if called directly. IndexArg must be processed by ArgList.
func (arg IndexArg) GetArgValue(ctx gs.ArgContext, t reflect.Type) (reflect.Value, error) <span class="cov0" title="0">{
        panic(util.UnimplementedMethod)</span>
}

// ValueArg represents a fixed-value argument.
type ValueArg struct {
        v interface{}
}

// Value creates a fixed-value argument.
func Value(v interface{}) gs.Arg <span class="cov0" title="0">{
        return ValueArg{v: v}
}</span>

// GetArgValue returns the fixed value and validates type compatibility.
// It returns an error if the value type is incompatible with the target type.
func (arg ValueArg) GetArgValue(ctx gs.ArgContext, t reflect.Type) (reflect.Value, error) <span class="cov0" title="0">{
        if arg.v == nil </span><span class="cov0" title="0">{
                return reflect.Zero(t), nil
        }</span>
        <span class="cov0" title="0">v := reflect.ValueOf(arg.v)
        if !v.Type().AssignableTo(t) </span><span class="cov0" title="0">{
                err := fmt.Errorf("cannot assign type:%T to type:%s", arg.v, t.String())
                return reflect.Value{}, errutil.WrapError(err, "ValueArg::GetArgValue error")
        }</span>
        <span class="cov0" title="0">return v, nil</span>
}

// ArgList manages arguments for a function, supporting both fixed and variadic parameters.
type ArgList struct {
        fnType reflect.Type // The reflected type of the target function.
        args   []gs.Arg     // The argument list (indexed or non-indexed).
}

// NewArgList validates and creates an ArgList for a function. It returns errors
// for invalid function types, mixed indexed/non-indexed args, or out-of-bounds indexes.
func NewArgList(fnType reflect.Type, args []gs.Arg) (*ArgList, error) <span class="cov7" title="6">{
        if fnType.Kind() != reflect.Func </span><span class="cov0" title="0">{
                err := fmt.Errorf("invalid function type:%s", fnType.String())
                return nil, errutil.WrapError(err, "NewArgList error")
        }</span>

        // Calculates the number of fixed arguments in the function.
        <span class="cov7" title="6">fixedArgCount := fnType.NumIn()
        if fnType.IsVariadic() </span><span class="cov1" title="1">{
                fixedArgCount--
        }</span>

        <span class="cov7" title="6">fnArgs := make([]gs.Arg, fixedArgCount)
        for i := range fnArgs </span><span class="cov8" title="7">{
                fnArgs[i] = Tag("")
        }</span>

        <span class="cov7" title="6">var (
                useIdx bool
                notIdx bool
        )

        for i := range args </span><span class="cov8" title="8">{
                switch arg := args[i].(type) </span>{
                case IndexArg:<span class="cov6" title="4">
                        useIdx = true
                        if notIdx </span><span class="cov0" title="0">{
                                err := errors.New("arguments must be all indexed or non-indexed")
                                return nil, errutil.WrapError(err, "NewArgList error")
                        }</span>
                        <span class="cov6" title="4">if arg.Idx &lt; 0 || arg.Idx &gt;= fnType.NumIn() </span><span class="cov0" title="0">{
                                err := fmt.Errorf("invalid argument index %d", arg.Idx)
                                return nil, errutil.WrapError(err, "NewArgList error")
                        }</span>
                        <span class="cov6" title="4">if arg.Idx &lt; fixedArgCount </span><span class="cov1" title="1">{
                                fnArgs[arg.Idx] = arg.Arg
                        }</span> else<span class="cov4" title="3"> {
                                fnArgs = append(fnArgs, arg.Arg)
                        }</span>
                default:<span class="cov6" title="4">
                        notIdx = true
                        if useIdx </span><span class="cov0" title="0">{
                                err := errors.New("arguments must be all indexed or non-indexed")
                                return nil, errutil.WrapError(err, "NewArgList error")
                        }</span>
                        <span class="cov6" title="4">if i &lt; fixedArgCount </span><span class="cov6" title="4">{
                                fnArgs[i] = arg
                        }</span> else<span class="cov0" title="0"> {
                                fnArgs = append(fnArgs, arg)
                        }</span>
                }
        }

        <span class="cov7" title="6">return &amp;ArgList{fnType: fnType, args: fnArgs}, nil</span>
}

// get resolves all arguments and returns their reflected values.
func (r *ArgList) get(ctx gs.ArgContext) ([]reflect.Value, error) <span class="cov7" title="6">{

        fnType := r.fnType
        numIn := fnType.NumIn()
        variadic := fnType.IsVariadic()
        result := make([]reflect.Value, 0, len(r.args))

        // Processes each argument and converts it to a [reflect.Value].
        for idx, arg := range r.args </span><span class="cov9" title="10">{

                var t reflect.Type
                if variadic &amp;&amp; idx &gt;= numIn-1 </span><span class="cov4" title="3">{
                        t = fnType.In(numIn - 1).Elem()
                }</span> else<span class="cov8" title="7"> {
                        t = fnType.In(idx)
                }</span>

                <span class="cov9" title="10">v, err := arg.GetArgValue(ctx, t)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov9" title="10">if v.IsValid() </span><span class="cov9" title="10">{
                        result = append(result, v)
                }</span>
        }
        <span class="cov7" title="6">return result, nil</span>
}

// CallableFunc is a function that can be called.
type CallableFunc = interface{}

// Callable wraps a function and its bound arguments for invocation.
type Callable struct {
        fn      CallableFunc
        argList *ArgList
}

// NewCallable binds arguments to a function and creates a Callable. It
// returns errors for invalid function types or argument validation failures.
func NewCallable(fn CallableFunc, args []gs.Arg) (*Callable, error) <span class="cov7" title="6">{
        fnType := reflect.TypeOf(fn)
        argList, err := NewArgList(fnType, args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="6">return &amp;Callable{fn: fn, argList: argList}, nil</span>
}

// Call invokes the function with resolved arguments.
func (r *Callable) Call(ctx gs.ArgContext) ([]reflect.Value, error) <span class="cov7" title="6">{
        ret, err := r.argList.get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="6">return reflect.ValueOf(r.fn).Call(ret), nil</span>
}

// BindArg represents a bound function with conditions for conditional execution.
type BindArg struct {
        r          *Callable      // The wrapped Callable.
        fileline   string         // Source location of the Bind call (for debugging).
        conditions []gs.Condition // Conditions that must be met to execute the function.
}

// validBindFunc validates if a function is a valid binding target.
// Valid signatures:
//   - func(...) error
//   - func(...) (T, error)
func validBindFunc(fn CallableFunc) error <span class="cov4" title="3">{
        t := reflect.TypeOf(fn)
        if t.Kind() != reflect.Func </span><span class="cov0" title="0">{
                return errors.New("invalid function type")
        }</span>
        <span class="cov4" title="3">if numOut := t.NumOut(); numOut == 1 </span><span class="cov4" title="3">{
                if o := t.Out(0); !util.IsErrorType(o) </span><span class="cov4" title="3">{
                        return nil
                }</span>
        } else<span class="cov0" title="0"> if numOut == 2 </span><span class="cov0" title="0">{
                if o := t.Out(t.NumOut() - 1); util.IsErrorType(o) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return errors.New("invalid function type")</span>
}

// Bind creates a binding for an option function. It panics on validation errors.
// `fn` is The target function (must return error or (T, error)). `args` is the
// bound arguments (indexed or non-indexed).
func Bind(fn CallableFunc, args ...gs.Arg) *BindArg <span class="cov4" title="3">{
        if err := validBindFunc(fn); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov4" title="3">r, err := NewCallable(fn, args)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov4" title="3">arg := &amp;BindArg{r: r}
        _, file, line, _ := runtime.Caller(1)
        arg.SetFileLine(file, line)
        return arg</span>
}

// SetFileLine sets the source location of the Bind call.
func (arg *BindArg) SetFileLine(file string, line int) <span class="cov4" title="3">{
        arg.fileline = fmt.Sprintf("%s:%d", file, line)
}</span>

// Condition adds pre-execution conditions to the binding.
func (arg *BindArg) Condition(c ...gs.Condition) *BindArg <span class="cov0" title="0">{
        arg.conditions = append(arg.conditions, c...)
        return arg
}</span>

// GetArgValue executes the function if all conditions are met and returns the result.
// It returns an invalid [reflect.Value] if conditions are not met. It also propagates
// errors from the function or condition checks.
func (arg *BindArg) GetArgValue(ctx gs.ArgContext, t reflect.Type) (reflect.Value, error) <span class="cov4" title="3">{

        // Checks if the condition is met.
        for _, c := range arg.conditions </span><span class="cov0" title="0">{
                ok, err := ctx.Check(c)
                if err != nil </span><span class="cov0" title="0">{
                        return reflect.Value{}, err
                }</span> else<span class="cov0" title="0"> if !ok </span><span class="cov0" title="0">{
                        return reflect.Value{}, nil
                }</span>
        }

        // Calls the function and returns its result.
        <span class="cov4" title="3">out, err := arg.r.Call(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return reflect.Value{}, err
        }</span>
        <span class="cov4" title="3">if len(out) == 1 </span><span class="cov4" title="3">{
                return out[0], nil
        }</span>
        <span class="cov0" title="0">err, _ = out[1].Interface().(error)
        return out[0], err</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_bean

import (
        "fmt"
        "reflect"
        "runtime"
        "slices"
        "strings"

        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/gs/internal/gs_arg"
        "github.com/go-spring/spring-core/gs/internal/gs_cond"
        "github.com/go-spring/spring-core/util"
)

// BeanStatus represents the different lifecycle statuses of a bean.
type BeanStatus int8

const (
        StatusDeleted   = BeanStatus(-1)   // Bean has been deleted.
        StatusDefault   = BeanStatus(iota) // Default status of the bean.
        StatusResolving                    // Bean is being resolved.
        StatusResolved                     // Bean has been resolved.
        StatusCreating                     // Bean is being created.
        StatusCreated                      // Bean has been created.
        StatusWired                        // Bean has been wired.
)

// String returns a human-readable string of the bean status.
func (status BeanStatus) String() string <span class="cov0" title="0">{
        switch status </span>{
        case StatusDeleted:<span class="cov0" title="0">
                return "deleted"</span>
        case StatusDefault:<span class="cov0" title="0">
                return "default"</span>
        case StatusResolving:<span class="cov0" title="0">
                return "resolving"</span>
        case StatusResolved:<span class="cov0" title="0">
                return "resolved"</span>
        case StatusCreating:<span class="cov0" title="0">
                return "creating"</span>
        case StatusCreated:<span class="cov0" title="0">
                return "created"</span>
        case StatusWired:<span class="cov0" title="0">
                return "wired"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// BeanMetadata holds the metadata information of a bean.
type BeanMetadata struct {
        f             *gs_arg.Callable
        init          gs.BeanInitFunc
        destroy       gs.BeanDestroyFunc
        dependsOn     []gs.BeanSelector
        exports       []reflect.Type
        conditions    []gs.Condition
        status        BeanStatus
        mocked        bool
        fileLine      string
        configuration *gs.Configuration
}

// Mocked returns true if the bean is mocked.
func (d *BeanMetadata) Mocked() bool <span class="cov5" title="16">{
        return d.mocked
}</span>

// validLifeCycleFunc checks whether the provided function is a valid lifecycle function.
func validLifeCycleFunc(fnType reflect.Type, beanType reflect.Type) bool <span class="cov2" title="3">{
        if !util.IsFuncType(fnType) || fnType.NumIn() != 1 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="3">if t := fnType.In(0); t.Kind() == reflect.Interface </span><span class="cov0" title="0">{
                if !beanType.Implements(t) </span><span class="cov0" title="0">{
                        return false
                }</span>
        } else<span class="cov2" title="3"> if t != beanType </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="3">return util.ReturnNothing(fnType) || util.ReturnOnlyError(fnType)</span>
}

// Init returns the initialization function of the bean.
func (d *BeanMetadata) Init() gs.BeanInitFunc <span class="cov5" title="16">{
        return d.init
}</span>

// Destroy returns the destruction function of the bean.
func (d *BeanMetadata) Destroy() gs.BeanDestroyFunc <span class="cov6" title="33">{
        return d.destroy
}</span>

// DependsOn returns the list of dependencies for the bean.
func (d *BeanMetadata) DependsOn() []gs.BeanSelector <span class="cov5" title="16">{
        return d.dependsOn
}</span>

// SetDependsOn sets the list of dependencies for the bean.
func (d *BeanMetadata) SetDependsOn(selectors ...gs.BeanSelector) <span class="cov0" title="0">{
        d.dependsOn = append(d.dependsOn, selectors...)
}</span>

// Exports returns the list of exported types for the bean.
func (d *BeanMetadata) Exports() []reflect.Type <span class="cov7" title="44">{
        return d.exports
}</span>

// Conditions returns the list of conditions for the bean.
func (d *BeanMetadata) Conditions() []gs.Condition <span class="cov5" title="16">{
        return d.conditions
}</span>

// SetCondition adds a condition to the list of conditions for the bean.
func (d *BeanMetadata) SetCondition(c ...gs.Condition) <span class="cov2" title="3">{
        d.conditions = append(d.conditions, c...)
}</span>

// Configuration returns the configuration parameters for the bean.
func (d *BeanMetadata) Configuration() *gs.Configuration <span class="cov5" title="16">{
        return d.configuration
}</span>

// SetConfiguration sets the configuration flag and parameters for the bean.
func (d *BeanDefinition) SetConfiguration(c ...gs.Configuration) <span class="cov0" title="0">{
        var cfg gs.Configuration
        if len(c) &gt; 0 </span><span class="cov0" title="0">{
                cfg = c[0]
        }</span>
        <span class="cov0" title="0">d.configuration = &amp;gs.Configuration{
                Includes: cfg.Includes,
                Excludes: cfg.Excludes,
        }</span>
}

// SetCaller sets the caller for the bean.
func (d *BeanMetadata) SetCaller(skip int) <span class="cov5" title="18">{
        _, file, line, _ := runtime.Caller(skip)
        d.SetFileLine(file, line)
}</span>

// FileLine returns the file and line number for the bean.
func (d *BeanMetadata) FileLine() string <span class="cov0" title="0">{
        return d.fileLine
}</span>

// SetFileLine sets the file and line number for the bean.
func (d *BeanMetadata) SetFileLine(file string, line int) <span class="cov5" title="18">{
        d.fileLine = fmt.Sprintf("%s:%d", file, line)
}</span>

// BeanRuntime holds runtime information about the bean.
type BeanRuntime struct {
        v    reflect.Value // The value of the bean.
        t    reflect.Type  // The type of the bean.
        name string        // The name of the bean.
}

// Name returns the name of the bean.
func (d *BeanRuntime) Name() string <span class="cov8" title="75">{
        return d.name
}</span>

// Type returns the type of the bean.
func (d *BeanRuntime) Type() reflect.Type <span class="cov8" title="76">{
        return d.t
}</span>

// Value returns the value of the bean as [reflect.Value].
func (d *BeanRuntime) Value() reflect.Value <span class="cov7" title="39">{
        return d.v
}</span>

// Interface returns the underlying value of the bean.
func (d *BeanRuntime) Interface() interface{} <span class="cov0" title="0">{
        return d.v.Interface()
}</span>

// Callable returns the callable for the bean.
func (d *BeanRuntime) Callable() *gs_arg.Callable <span class="cov0" title="0">{
        return nil
}</span>

// Status returns the current status of the bean.
func (d *BeanRuntime) Status() BeanStatus <span class="cov0" title="0">{
        return StatusWired
}</span>

// String returns a string representation of the bean.
func (d *BeanRuntime) String() string <span class="cov0" title="0">{
        return d.name
}</span>

// BeanDefinition contains both metadata and runtime information of a bean.
type BeanDefinition struct {
        *BeanMetadata
        *BeanRuntime
}

// makeBean creates a new bean definition.
func makeBean(t reflect.Type, v reflect.Value, f *gs_arg.Callable, name string) *BeanDefinition <span class="cov5" title="16">{
        return &amp;BeanDefinition{
                BeanMetadata: &amp;BeanMetadata{
                        f:      f,
                        status: StatusDefault,
                },
                BeanRuntime: &amp;BeanRuntime{
                        t:    t,
                        v:    v,
                        name: name,
                },
        }
}</span>

// SetMock sets the mock object for the bean, replacing its runtime information.
func (d *BeanDefinition) SetMock(obj interface{}) <span class="cov0" title="0">{
        *d = BeanDefinition{
                BeanMetadata: &amp;BeanMetadata{
                        exports: d.exports,
                        mocked:  true,
                },
                BeanRuntime: &amp;BeanRuntime{
                        t:    reflect.TypeOf(obj),
                        v:    reflect.ValueOf(obj),
                        name: d.name,
                },
        }
}</span>

// Callable returns the callable for the bean.
func (d *BeanDefinition) Callable() *gs_arg.Callable <span class="cov6" title="19">{
        return d.f
}</span>

// SetName sets the name of the bean.
func (d *BeanDefinition) SetName(name string) <span class="cov3" title="4">{
        d.name = name
}</span>

// Status returns the current status of the bean.
func (d *BeanDefinition) Status() BeanStatus <span class="cov10" title="197">{
        return d.status
}</span>

// SetStatus sets the current status of the bean.
func (d *BeanDefinition) SetStatus(status BeanStatus) <span class="cov8" title="80">{
        d.status = status
}</span>

// SetInit sets the initialization function for the bean.
func (d *BeanDefinition) SetInit(fn gs.BeanInitFunc) <span class="cov0" title="0">{
        if validLifeCycleFunc(reflect.TypeOf(fn), d.Type()) </span><span class="cov0" title="0">{
                d.init = fn
                return
        }</span>
        <span class="cov0" title="0">panic("init should be func(bean) or func(bean)error")</span>
}

// SetDestroy sets the destruction function for the bean.
func (d *BeanDefinition) SetDestroy(fn gs.BeanDestroyFunc) <span class="cov2" title="3">{
        if validLifeCycleFunc(reflect.TypeOf(fn), d.Type()) </span><span class="cov2" title="3">{
                d.destroy = fn
                return
        }</span>
        <span class="cov0" title="0">panic("destroy should be func(bean) or func(bean)error")</span>
}

// SetInitMethod sets the initialization function for the bean by method name.
func (d *BeanDefinition) SetInitMethod(method string) <span class="cov0" title="0">{
        m, ok := d.t.MethodByName(method)
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("method %s not found on type %s", method, d.t))</span>
        }
        <span class="cov0" title="0">d.SetInit(m.Func.Interface())</span>
}

// SetDestroyMethod sets the destruction function for the bean by method name.
func (d *BeanDefinition) SetDestroyMethod(method string) <span class="cov0" title="0">{
        m, ok := d.t.MethodByName(method)
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("method %s not found on type %s", method, d.t))</span>
        }
        <span class="cov0" title="0">d.SetDestroy(m.Func.Interface())</span>
}

// SetExport sets the exported interfaces for the bean.
func (d *BeanDefinition) SetExport(exports ...reflect.Type) <span class="cov4" title="6">{
        for _, t := range exports </span><span class="cov4" title="6">{
                if t.Kind() != reflect.Interface </span><span class="cov0" title="0">{
                        panic("only interface type can be exported")</span>
                }
                <span class="cov4" title="6">if !d.Type().Implements(t) </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("doesn't implement interface %s", t))</span>
                }
                <span class="cov4" title="6">exported := false
                for _, export := range d.exports </span><span class="cov0" title="0">{
                        if t == export </span><span class="cov0" title="0">{
                                exported = true
                                break</span>
                        }
                }
                <span class="cov4" title="6">if exported </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="6">d.exports = append(d.exports, t)</span>
        }
}

// OnProfiles sets the conditions for the bean based on the active profiles.
func (d *BeanDefinition) OnProfiles(profiles string) <span class="cov1" title="1">{
        d.SetCondition(gs_cond.OnFunc(func(ctx gs.CondContext) (bool, error) </span><span class="cov1" title="1">{
                val := strings.TrimSpace(ctx.Prop("spring.profiles.active"))
                if val == "" </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov1" title="1">ss := strings.Split(strings.TrimSpace(profiles), ",")
                for s := range slices.Values(strings.Split(val, ",")) </span><span class="cov1" title="1">{
                        for _, x := range ss </span><span class="cov1" title="1">{
                                if s == x </span><span class="cov1" title="1">{
                                        return true, nil
                                }</span>
                        }
                }
                <span class="cov0" title="0">return false, nil</span>
        }))
}

// TypeAndName returns the type and name of the bean.
func (d *BeanDefinition) TypeAndName() (reflect.Type, string) <span class="cov0" title="0">{
        return d.Type(), d.Name()
}</span>

// String returns a string representation of the bean.
func (d *BeanDefinition) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("name=%s %s", d.name, d.fileLine)
}</span>

// NewBean creates a new bean definition. When registering a normal function,
// use reflect.ValueOf(fn) to avoid conflicts with constructors.
func NewBean(objOrCtor interface{}, ctorArgs ...gs.Arg) *gs.BeanDefinition <span class="cov5" title="16">{

        var f *gs_arg.Callable
        var v reflect.Value
        var fromValue bool
        var name string
        var cond gs.Condition

        switch i := objOrCtor.(type) </span>{
        case reflect.Value:<span class="cov4" title="10">
                fromValue = true
                v = i</span>
        default:<span class="cov4" title="6">
                v = reflect.ValueOf(i)</span>
        }

        <span class="cov5" title="16">t := v.Type()
        if !util.IsBeanType(t) </span><span class="cov0" title="0">{
                panic("bean must be ref type")</span>
        }

        // Ensure the value is valid and not nil
        <span class="cov5" title="16">if !v.IsValid() || v.IsNil() </span><span class="cov0" title="0">{
                panic("bean can't be nil")</span>
        }

        // If objOrCtor is a function (not from reflect.Value),
        // process it as a constructor
        <span class="cov5" title="16">if !fromValue &amp;&amp; t.Kind() == reflect.Func </span><span class="cov2" title="3">{

                if !util.IsConstructor(t) </span><span class="cov0" title="0">{
                        t1 := "func(...)bean"
                        t2 := "func(...)(bean, error)"
                        panic(fmt.Sprintf("constructor should be %s or %s", t1, t2))</span>
                }

                // Bind the constructor arguments
                <span class="cov2" title="3">var err error
                f, err = gs_arg.NewCallable(objOrCtor, ctorArgs)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov2" title="3">var in0 reflect.Type
                if t.NumIn() &gt; 0 </span><span class="cov2" title="3">{
                        in0 = t.In(0)
                }</span>

                // Obtain the return type of the constructor
                <span class="cov2" title="3">out0 := t.Out(0)
                v = reflect.New(out0)
                if util.IsBeanType(out0) </span><span class="cov2" title="3">{
                        v = v.Elem()
                }</span>

                <span class="cov2" title="3">t = v.Type()
                if !util.IsBeanType(t) </span><span class="cov0" title="0">{
                        panic("bean must be ref type")</span>
                }

                // Extract function name for naming the bean
                <span class="cov2" title="3">fnPtr := reflect.ValueOf(objOrCtor).Pointer()
                fnInfo := runtime.FuncForPC(fnPtr)
                funcName := fnInfo.Name()
                name = funcName[strings.LastIndex(funcName, "/")+1:]
                name = name[strings.Index(name, ".")+1:]
                if name[0] == '(' </span><span class="cov0" title="0">{
                        name = name[strings.Index(name, ".")+1:]
                }</span>

                // Check if the function is a method and set a condition if needed
                <span class="cov2" title="3">method := strings.LastIndexByte(fnInfo.Name(), ')') &gt; 0
                if method </span><span class="cov0" title="0">{
                        var s gs.BeanSelector = gs.BeanSelectorImpl{Type: in0}
                        if len(ctorArgs) &gt; 0 </span><span class="cov0" title="0">{
                                switch a := ctorArgs[0].(type) </span>{
                                case *gs.RegisteredBean:<span class="cov0" title="0">
                                        s = a</span>
                                case *gs.BeanDefinition:<span class="cov0" title="0">
                                        s = a</span>
                                case gs_arg.IndexArg:<span class="cov0" title="0">
                                        if a.Idx == 0 </span><span class="cov0" title="0">{
                                                switch x := a.Arg.(type) </span>{
                                                case *gs.RegisteredBean:<span class="cov0" title="0">
                                                        s = x</span>
                                                case *gs.BeanDefinition:<span class="cov0" title="0">
                                                        s = x</span>
                                                default:<span class="cov0" title="0">
                                                        panic("the arg of IndexArg[0] should be *RegisteredBean or *BeanDefinition")</span>
                                                }
                                        }
                                default:<span class="cov0" title="0">
                                        panic("ctorArgs[0] should be *RegisteredBean or *BeanDefinition or IndexArg[0]")</span>
                                }
                        }
                        <span class="cov0" title="0">cond = gs_cond.OnBeanSelector(s)</span>
                }
        }

        // Extract the final type name for bean naming
        <span class="cov5" title="16">if name == "" </span><span class="cov5" title="13">{
                s := strings.Split(t.String(), ".")
                name = strings.TrimPrefix(s[len(s)-1], "*")
        }</span>

        <span class="cov5" title="16">d := makeBean(t, v, f, name)
        if cond != nil </span><span class="cov0" title="0">{
                d.SetCondition(cond)
        }</span>
        <span class="cov5" title="16">return gs.NewBeanDefinition(d)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_cond

import (
        "fmt"
        "strings"

        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/util"
        "github.com/go-spring/spring-core/util/errutil"
)

/********************************* OnFunc ************************************/

// onFunc is an implementation of [gs.Condition] that wraps a function.
// It allows a condition to be evaluated based on the result of a function.
type onFunc struct {
        fn gs.CondFunc
}

// OnFunc creates a Conditional that evaluates using a custom function.
func OnFunc(fn gs.CondFunc) gs.Condition <span class="cov1" title="1">{
        return &amp;onFunc{fn: fn}
}</span>

// Matches checks if the condition is met according to the provided context.
func (c *onFunc) Matches(ctx gs.CondContext) (bool, error) <span class="cov1" title="1">{
        ok, err := c.fn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return false, errutil.WrapError(err, "condition matches error: %s", c)
        }</span>
        <span class="cov1" title="1">return ok, nil</span>
}

func (c *onFunc) String() string <span class="cov0" title="0">{
        _, _, fnName := util.FileLine(c.fn)
        return fmt.Sprintf("OnFunc(fn=%s)", fnName)
}</span>

/******************************* OnProperty **********************************/

// OnPropertyInterface defines the methods for evaluating a condition based on a property.
// This interface provides flexibility for matching missing properties and checking their values.
type OnPropertyInterface interface {
        gs.Condition
        MatchIfMissing() OnPropertyInterface
        HavingValue(s string) OnPropertyInterface
}

// onProperty evaluates a condition based on the existence and value of a property
// in the context. It allows for complex matching behaviors such as matching missing
// properties or evaluating expressions.
type onProperty struct {
        name           string      // The name of the property to check.
        matchIfMissing bool        // Whether to match if the property is missing.
        havingValue    interface{} // The expected value or expression to match.
}

// OnProperty creates a condition based on the presence and value of a specified property.
func OnProperty(name string) OnPropertyInterface <span class="cov10" title="4">{
        return &amp;onProperty{name: name}
}</span>

// MatchIfMissing sets the condition to match if the property is missing.
func (c *onProperty) MatchIfMissing() OnPropertyInterface <span class="cov10" title="4">{
        c.matchIfMissing = true
        return c
}</span>

// HavingValue sets the expected value or expression to match.
func (c *onProperty) HavingValue(s string) OnPropertyInterface <span class="cov10" title="4">{
        c.havingValue = s
        return c
}</span>

// Matches checks if the condition is met according to the provided context.
func (c *onProperty) Matches(ctx gs.CondContext) (bool, error) <span class="cov10" title="4">{

        // If the context doesn't have the property, handle accordingly.
        if !ctx.Has(c.name) </span><span class="cov8" title="3">{
                return c.matchIfMissing, nil
        }</span>

        // If the expected value is nil, the condition is always true.
        <span class="cov1" title="1">if c.havingValue == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov1" title="1">havingValue := c.havingValue.(string)

        // Retrieve the property's value and compare it with the expected value.
        val := ctx.Prop(c.name)
        if !strings.HasPrefix(havingValue, "expr:") </span><span class="cov1" title="1">{
                return val == havingValue, nil
        }</span>

        // Evaluate the expression and return the result.
        <span class="cov0" title="0">ok, err := EvalExpr(havingValue[5:], val)
        if err != nil </span><span class="cov0" title="0">{
                return false, errutil.WrapError(err, "condition matches error: %s", c)
        }</span>
        <span class="cov0" title="0">return ok, nil</span>
}

func (c *onProperty) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString("OnProperty(name=")
        sb.WriteString(c.name)
        if c.havingValue != nil </span><span class="cov0" title="0">{
                sb.WriteString(", havingValue=")
                sb.WriteString(c.havingValue.(string))
        }</span>
        <span class="cov0" title="0">if c.matchIfMissing </span><span class="cov0" title="0">{
                sb.WriteString(", matchIfMissing")
        }</span>
        <span class="cov0" title="0">sb.WriteString(")")
        return sb.String()</span>
}

/*************************** OnMissingProperty *******************************/

// onMissingProperty is a condition that matches when a specified property is
// absent from the context.
type onMissingProperty struct {
        name string // The name of the property to check for absence.
}

// OnMissingProperty creates a condition that matches if the specified property is missing.
func OnMissingProperty(name string) gs.Condition <span class="cov0" title="0">{
        return &amp;onMissingProperty{name: name}
}</span>

// Matches checks if the condition is met according to the provided context.
func (c *onMissingProperty) Matches(ctx gs.CondContext) (bool, error) <span class="cov0" title="0">{
        return !ctx.Has(c.name), nil
}</span>

func (c *onMissingProperty) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("OnMissingProperty(name=%s)", c.name)
}</span>

/********************************* OnBean ************************************/

// onBean checks for the existence of beans that match a selector.
// It returns true if at least one bean matches the selector, and false otherwise.
type onBean struct {
        s gs.BeanSelector // The selector used to match beans in the context.
}

// OnBean creates a condition that evaluates to true if at least one bean
// matches the specified type and name.
func OnBean[T any](name ...string) gs.Condition <span class="cov1" title="1">{
        return &amp;onBean{s: gs.BeanSelectorFor[T](name...)}
}</span>

// OnBeanSelector creates a condition that evaluates to true if at least one
// bean matches the provided selector.
func OnBeanSelector(s gs.BeanSelector) gs.Condition <span class="cov0" title="0">{
        return &amp;onBean{s: s}
}</span>

// Matches checks if the condition is met according to the provided context.
func (c *onBean) Matches(ctx gs.CondContext) (bool, error) <span class="cov1" title="1">{
        beans, err := ctx.Find(c.s)
        if err != nil </span><span class="cov0" title="0">{
                return false, errutil.WrapError(err, "condition matches error: %s", c)
        }</span>
        <span class="cov1" title="1">return len(beans) &gt; 0, nil</span>
}

func (c *onBean) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("OnBean(selector=%s)", c.s)
}</span>

/***************************** OnMissingBean *********************************/

// onMissingBean checks for the absence of beans matching a selector.
// It returns true if no beans match the selector, and false otherwise.
type onMissingBean struct {
        s gs.BeanSelector // The selector used to find beans.
}

// OnMissingBean creates a condition that evaluates to true if no beans match
// the specified type and name.
func OnMissingBean[T any](name ...string) gs.Condition <span class="cov0" title="0">{
        return &amp;onMissingBean{s: gs.BeanSelectorFor[T](name...)}
}</span>

// OnMissingBeanSelector creates a condition that evaluates to true if no beans
// match the provided selector.
func OnMissingBeanSelector(s gs.BeanSelector) gs.Condition <span class="cov0" title="0">{
        return &amp;onMissingBean{s: s}
}</span>

// Matches checks if the condition is met according to the provided context.
func (c *onMissingBean) Matches(ctx gs.CondContext) (bool, error) <span class="cov0" title="0">{
        beans, err := ctx.Find(c.s)
        if err != nil </span><span class="cov0" title="0">{
                return false, errutil.WrapError(err, "condition matches error: %s", c)
        }</span>
        <span class="cov0" title="0">return len(beans) == 0, nil</span>
}

func (c *onMissingBean) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("OnMissingBean(selector=%s)", c.s)
}</span>

/***************************** OnSingleBean **********************************/

// onSingleBean checks if exactly one matching bean exists in the context.
// It returns true if exactly one bean matches the selector, and false otherwise.
type onSingleBean struct {
        s gs.BeanSelector // The selector used to find beans.
}

// OnSingleBean creates a condition that evaluates to true if exactly one bean
// matches the specified type and name.
func OnSingleBean[T any](name ...string) gs.Condition <span class="cov0" title="0">{
        return &amp;onSingleBean{s: gs.BeanSelectorFor[T](name...)}
}</span>

// OnSingleBeanSelector creates a condition that evaluates to true if exactly
// one bean matches the provided selector.
func OnSingleBeanSelector(s gs.BeanSelector) gs.Condition <span class="cov0" title="0">{
        return &amp;onSingleBean{s: s}
}</span>

// Matches checks if the condition is met according to the provided context.
func (c *onSingleBean) Matches(ctx gs.CondContext) (bool, error) <span class="cov0" title="0">{
        beans, err := ctx.Find(c.s)
        if err != nil </span><span class="cov0" title="0">{
                return false, errutil.WrapError(err, "condition matches error: %s", c)
        }</span>
        <span class="cov0" title="0">return len(beans) == 1, nil</span>
}

func (c *onSingleBean) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("OnSingleBean(selector=%s)", c.s)
}</span>

/***************************** OnExpression **********************************/

// onExpression evaluates a custom expression within the context. The expression should
// return true or false, and the evaluation is expected to happen within the context.
type onExpression struct {
        expression string // The string expression to evaluate.
}

// OnExpression creates a condition that evaluates based on a custom string expression.
// The expression is expected to return true or false.
func OnExpression(expression string) gs.Condition <span class="cov0" title="0">{
        return &amp;onExpression{expression: expression}
}</span>

// Matches checks if the condition is met according to the provided context.
func (c *onExpression) Matches(ctx gs.CondContext) (bool, error) <span class="cov0" title="0">{
        err := util.UnimplementedMethod
        return false, errutil.WrapError(err, "condition matches error: %s", c)
}</span>

func (c *onExpression) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("OnExpression(expression=%s)", c.expression)
}</span>

/********************************** Not ***************************************/

// onNot is a condition that negates another condition. It returns true if the wrapped
// condition evaluates to false, and false if the wrapped condition evaluates to true.
type onNot struct {
        c gs.Condition // The condition to negate.
}

// Not creates a condition that inverts the result of the provided condition.
func Not(c gs.Condition) gs.Condition <span class="cov0" title="0">{
        return &amp;onNot{c: c}
}</span>

// Matches checks if the condition is met according to the provided context.
func (c *onNot) Matches(ctx gs.CondContext) (bool, error) <span class="cov0" title="0">{
        ok, err := c.c.Matches(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return false, errutil.WrapError(err, "condition matches error: %s", c)
        }</span>
        <span class="cov0" title="0">return !ok, nil</span>
}

func (c *onNot) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Not(%s)", c.c)
}</span>

/********************************** Or ***************************************/

// onOr is a condition that combines multiple conditions with an OR operator.
// It evaluates to true if at least one condition is satisfied.
type onOr struct {
        conditions []gs.Condition // The list of conditions to evaluate with OR.
}

// Or combines multiple conditions with an OR operator, returning true if at
// least one condition is satisfied.
func Or(conditions ...gs.Condition) gs.Condition <span class="cov0" title="0">{
        if n := len(conditions); n == 0 </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> if n == 1 </span><span class="cov0" title="0">{
                return conditions[0]
        }</span>
        <span class="cov0" title="0">return &amp;onOr{conditions: conditions}</span>
}

// Matches checks if the condition is met according to the provided context.
func (g *onOr) Matches(ctx gs.CondContext) (bool, error) <span class="cov0" title="0">{
        for _, c := range g.conditions </span><span class="cov0" title="0">{
                if ok, err := c.Matches(ctx); err != nil </span><span class="cov0" title="0">{
                        return false, errutil.WrapError(err, "condition matches error: %s", g)
                }</span> else<span class="cov0" title="0"> if ok </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

func (g *onOr) String() string <span class="cov0" title="0">{
        return FormatGroup("Or", g.conditions)
}</span>

/********************************* And ***************************************/

// onAnd is a condition that combines multiple conditions with an AND operator.
// It evaluates to true only if all conditions are satisfied.
type onAnd struct {
        conditions []gs.Condition // The list of conditions to evaluate with AND.
}

// And combines multiple conditions with an AND operator, returning true if
// all conditions are satisfied.
func And(conditions ...gs.Condition) gs.Condition <span class="cov0" title="0">{
        if n := len(conditions); n == 0 </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> if n == 1 </span><span class="cov0" title="0">{
                return conditions[0]
        }</span>
        <span class="cov0" title="0">return &amp;onAnd{conditions: conditions}</span>
}

// Matches checks if the condition is met according to the provided context.
func (g *onAnd) Matches(ctx gs.CondContext) (bool, error) <span class="cov0" title="0">{
        for _, c := range g.conditions </span><span class="cov0" title="0">{
                ok, err := c.Matches(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return false, errutil.WrapError(err, "condition matches error: %s", g)
                }</span> else<span class="cov0" title="0"> if !ok </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

func (g *onAnd) String() string <span class="cov0" title="0">{
        return FormatGroup("And", g.conditions)
}</span>

/********************************** None *************************************/

// onNone is a condition that combines multiple conditions with a NONE operator.
// It evaluates to true only if none of the conditions are satisfied.
type onNone struct {
        conditions []gs.Condition // The list of conditions to evaluate with NONE.
}

// None combines multiple conditions with a NONE operator, returning true if
// none of the conditions are satisfied.
func None(conditions ...gs.Condition) gs.Condition <span class="cov0" title="0">{
        if n := len(conditions); n == 0 </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> if n == 1 </span><span class="cov0" title="0">{
                return Not(conditions[0])
        }</span>
        <span class="cov0" title="0">return &amp;onNone{conditions: conditions}</span>
}

// Matches checks if the condition is met according to the provided context.
func (g *onNone) Matches(ctx gs.CondContext) (bool, error) <span class="cov0" title="0">{
        for _, c := range g.conditions </span><span class="cov0" title="0">{
                if ok, err := c.Matches(ctx); err != nil </span><span class="cov0" title="0">{
                        return false, errutil.WrapError(err, "condition matches error: %s", g)
                }</span> else<span class="cov0" title="0"> if ok </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

func (g *onNone) String() string <span class="cov0" title="0">{
        return FormatGroup("None", g.conditions)
}</span>

/******************************* utilities ***********************************/

// FormatGroup generates a formatted string for a group of conditions (AND, OR, NONE).
func FormatGroup(op string, conditions []gs.Condition) string <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString(op)
        sb.WriteString("(")
        for i, c := range conditions </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        sb.WriteString(", ")
                }</span>
                <span class="cov0" title="0">sb.WriteString(fmt.Sprint(c))</span>
        }
        <span class="cov0" title="0">sb.WriteString(")")
        return sb.String()</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_cond

import (
        "fmt"

        "github.com/expr-lang/expr"
)

// funcMap stores registered functions that can be referenced in expressions.
// These functions are available for use in all expressions evaluated by EvalExpr.
var funcMap = map[string]interface{}{}

// RegisterExpressFunc registers a function under the given name, making it available
// for use in expressions evaluated by EvalExpr. Functions must be registered before
// they are referenced in any expression.
func RegisterExpressFunc(name string, fn interface{}) <span class="cov0" title="0">{
        funcMap[name] = fn
}</span>

// EvalExpr evaluates a boolean expression using the provided value as the "$" variable.
// `input` is a boolean expression string to evaluate, it must return a boolean result.
// `val` is a string value accessible as "$" within the expression context.
func EvalExpr(input string, val string) (bool, error) <span class="cov0" title="0">{
        env := map[string]interface{}{"$": val}
        for k, v := range funcMap </span><span class="cov0" title="0">{
                env[k] = v
        }</span>
        <span class="cov0" title="0">r, err := expr.Eval(input, env)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("eval %q returns error, %w", input, err)
        }</span>
        <span class="cov0" title="0">ret, ok := r.(bool)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("eval %q doesn't return bool value", input)
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_conf

import (
        "fmt"
        "os"
        "strings"

        "github.com/go-spring/spring-core/conf"
)

// CommandArgsPrefix defines the environment variable name used to override
// the default option prefix. This allows users to customize the prefix used
// for command-line options if needed.
const CommandArgsPrefix = "GS_ARGS_PREFIX"

// CommandArgs represents a structure for handling command-line parameters.
type CommandArgs struct{}

// NewCommandArgs creates and returns a new CommandArgs instance.
func NewCommandArgs() *CommandArgs <span class="cov3" title="2">{
        return &amp;CommandArgs{}
}</span>

// CopyTo processes command-line parameters and sets them as key-value pairs
// in the provided conf.Properties. Parameters should be passed in the form
// of `-D key[=value/true]`.
func (c *CommandArgs) CopyTo(out *conf.MutableProperties) error <span class="cov10" title="12">{
        if len(os.Args) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Default option prefix is "-D", but it can be overridden by the
        // environment variable `GS_ARGS_PREFIX`.
        <span class="cov10" title="12">option := "-D"
        if s := strings.TrimSpace(os.Getenv(CommandArgsPrefix)); s != "" </span><span class="cov0" title="0">{
                option = s
        }</span>

        <span class="cov10" title="12">cmdArgs := os.Args[1:]
        n := len(cmdArgs)
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                if cmdArgs[i] == option </span><span class="cov0" title="0">{
                        if i+1 &gt;= n </span><span class="cov0" title="0">{
                                return fmt.Errorf("cmd option %s needs arg", option)
                        }</span>
                        <span class="cov0" title="0">next := cmdArgs[i+1]
                        ss := strings.SplitN(next, "=", 2)
                        if len(ss) == 1 </span><span class="cov0" title="0">{
                                ss = append(ss, "true")
                        }</span>
                        <span class="cov0" title="0">if err := out.Set(ss[0], ss[1]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov10" title="12">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_conf

import (
        "fmt"
        "os"
        "strings"

        "github.com/go-spring/spring-core/conf"
        "github.com/go-spring/spring-core/util/sysconf"
)

// osStat only for test.
var osStat = os.Stat

// PropertyCopier defines the interface for copying properties.
type PropertyCopier interface {
        CopyTo(out *conf.MutableProperties) error
}

// NamedPropertyCopier defines the interface for copying properties with a name.
type NamedPropertyCopier struct {
        PropertyCopier
        Name string
}

// NewNamedPropertyCopier creates a new instance of NamedPropertyCopier.
func NewNamedPropertyCopier(name string, p PropertyCopier) *NamedPropertyCopier <span class="cov8" title="51">{
        return &amp;NamedPropertyCopier{PropertyCopier: p, Name: name}
}</span>

func (c *NamedPropertyCopier) CopyTo(out *conf.MutableProperties) error <span class="cov8" title="51">{
        if c.PropertyCopier != nil </span><span class="cov8" title="46">{
                return c.PropertyCopier.CopyTo(out)
        }</span>
        <span class="cov4" title="5">return nil</span>
}

/******************************** AppConfig **********************************/

// AppConfig represents a layered application configuration.
type AppConfig struct {
        LocalFile   *PropertySources // Configuration sources from local files.
        RemoteFile  *PropertySources // Configuration sources from remote files.
        RemoteProp  conf.Properties  // Remote properties.
        Environment *Environment     // Environment variables as configuration source.
        CommandArgs *CommandArgs     // Command line arguments as configuration source.
}

// NewAppConfig creates a new instance of AppConfig.
func NewAppConfig() *AppConfig <span class="cov1" title="1">{
        return &amp;AppConfig{
                LocalFile:   NewPropertySources(ConfigTypeLocal, "app"),
                RemoteFile:  NewPropertySources(ConfigTypeRemote, "app"),
                Environment: NewEnvironment(),
                CommandArgs: NewCommandArgs(),
        }
}</span>

func merge(sources ...PropertyCopier) (conf.Properties, error) <span class="cov5" title="12">{
        out := conf.New()
        for _, s := range sources </span><span class="cov8" title="51">{
                if s != nil </span><span class="cov8" title="51">{
                        if err := s.CopyTo(out); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }
        <span class="cov5" title="12">return out, nil</span>
}

// Refresh merges all layers of configurations into a read-only properties.
func (c *AppConfig) Refresh() (conf.Properties, error) <span class="cov4" title="5">{
        p, err := merge(
                NewNamedPropertyCopier("sys", sysconf.Clone()),
                NewNamedPropertyCopier("env", c.Environment),
                NewNamedPropertyCopier("cmd", c.CommandArgs),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="5">localFiles, err := c.LocalFile.loadFiles(p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="5">remoteFiles, err := c.RemoteFile.loadFiles(p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="5">var sources []PropertyCopier
        sources = append(sources, NewNamedPropertyCopier("sys", sysconf.Clone()))
        for _, file := range localFiles </span><span class="cov4" title="5">{
                sources = append(sources, file)
        }</span>
        <span class="cov4" title="5">for _, file := range remoteFiles </span><span class="cov4" title="5">{
                sources = append(sources, file)
        }</span>
        <span class="cov4" title="5">sources = append(sources, NewNamedPropertyCopier("remote", c.RemoteProp))
        sources = append(sources, NewNamedPropertyCopier("env", c.Environment))
        sources = append(sources, NewNamedPropertyCopier("cmd", c.CommandArgs))

        return merge(sources...)</span>
}

/******************************** BootConfig *********************************/

// BootConfig represents a layered boot configuration.
type BootConfig struct {
        LocalFile   *PropertySources // Configuration sources from local files.
        Environment *Environment     // Environment variables as configuration source.
        CommandArgs *CommandArgs     // Command line arguments as configuration source.
}

// NewBootConfig creates a new instance of BootConfig.
func NewBootConfig() *BootConfig <span class="cov1" title="1">{
        return &amp;BootConfig{
                LocalFile:   NewPropertySources(ConfigTypeLocal, "boot"),
                Environment: NewEnvironment(),
                CommandArgs: NewCommandArgs(),
        }
}</span>

// Refresh merges all layers of configurations into a read-only properties.
func (c *BootConfig) Refresh() (conf.Properties, error) <span class="cov1" title="1">{
        p, err := merge(
                NewNamedPropertyCopier("sys", sysconf.Clone()),
                NewNamedPropertyCopier("env", c.Environment),
                NewNamedPropertyCopier("cmd", c.CommandArgs),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">localFiles, err := c.LocalFile.loadFiles(p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">var sources []PropertyCopier
        sources = append(sources, NewNamedPropertyCopier("sys", sysconf.Clone()))
        for _, file := range localFiles </span><span class="cov0" title="0">{
                sources = append(sources, file)
        }</span>
        <span class="cov1" title="1">sources = append(sources, NewNamedPropertyCopier("env", c.Environment))
        sources = append(sources, NewNamedPropertyCopier("cmd", c.CommandArgs))

        return merge(sources...)</span>
}

/****************************** PropertySources ******************************/

// ConfigType defines the type of configuration: local or remote.
type ConfigType string

const (
        ConfigTypeLocal  ConfigType = "local"
        ConfigTypeRemote ConfigType = "remote"
)

// PropertySources is a collection of configuration files.
type PropertySources struct {
        configType ConfigType // Type of the configuration (local or remote).
        configName string     // Name of the configuration.
        extraDirs  []string   // Extra directories to be included in the configuration.
        extraFiles []string   // Extra files to be included in the configuration.
}

// NewPropertySources creates a new instance of PropertySources.
func NewPropertySources(configType ConfigType, configName string) *PropertySources <span class="cov3" title="3">{
        return &amp;PropertySources{
                configType: configType,
                configName: configName,
        }
}</span>

// Reset resets all the extra files.
func (p *PropertySources) Reset() <span class="cov0" title="0">{
        p.extraFiles = nil
        p.extraDirs = nil
}</span>

// AddDir adds a or more than one extra directories.
func (p *PropertySources) AddDir(dirs ...string) <span class="cov0" title="0">{
        for _, d := range dirs </span><span class="cov0" title="0">{
                info, err := osStat(d)
                if err != nil </span><span class="cov0" title="0">{
                        if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        panic("should be a directory")</span>
                }
        }
        <span class="cov0" title="0">p.extraDirs = append(p.extraDirs, dirs...)</span>
}

// AddFile adds a or more than one extra files.
func (p *PropertySources) AddFile(files ...string) <span class="cov0" title="0">{
        for _, f := range files </span><span class="cov0" title="0">{
                info, err := osStat(f)
                if err != nil </span><span class="cov0" title="0">{
                        if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        panic("should be a file")</span>
                }
        }
        <span class="cov0" title="0">p.extraFiles = append(p.extraFiles, files...)</span>
}

// getDefaultDir returns the default configuration directory based on the configuration type.
func (p *PropertySources) getDefaultDir(resolver conf.Properties) (configDir string, err error) <span class="cov5" title="11">{
        switch p.configType </span>{
        case ConfigTypeLocal:<span class="cov4" title="6">
                return resolver.Resolve("${spring.app.config-local.dir:=./conf}")</span>
        case ConfigTypeRemote:<span class="cov4" title="5">
                return resolver.Resolve("${spring.app.config-remote.dir:=./conf/remote}")</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unknown config type: %s", p.configType)</span>
        }
}

// getFiles returns the list of configuration files based on the configuration directory and active profiles.
func (p *PropertySources) getFiles(dir string, resolver conf.Properties) (_ []string, err error) <span class="cov5" title="11">{

        files := []string{
                fmt.Sprintf("%s/%s.properties", dir, p.configName),
                fmt.Sprintf("%s/%s.yaml", dir, p.configName),
                fmt.Sprintf("%s/%s.toml", dir, p.configName),
                fmt.Sprintf("%s/%s.json", dir, p.configName),
        }

        activeProfiles, err := resolver.Resolve("${spring.profiles.active:=}")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="11">if activeProfiles = strings.TrimSpace(activeProfiles); activeProfiles != "" </span><span class="cov5" title="11">{
                ss := strings.Split(activeProfiles, ",")
                for _, s := range ss </span><span class="cov5" title="11">{
                        if s = strings.TrimSpace(s); s != "" </span><span class="cov5" title="11">{
                                files = append(files, []string{
                                        fmt.Sprintf("%s/%s-%s.properties", dir, p.configName, s),
                                        fmt.Sprintf("%s/%s-%s.yaml", dir, p.configName, s),
                                        fmt.Sprintf("%s/%s-%s.toml", dir, p.configName, s),
                                        fmt.Sprintf("%s/%s-%s.json", dir, p.configName, s),
                                }...)
                        }</span>
                }
        }
        <span class="cov5" title="11">return files, nil</span>
}

// loadFiles loads all configuration files and returns them as a list of Properties.
func (p *PropertySources) loadFiles(resolver conf.Properties) ([]PropertyCopier, error) <span class="cov5" title="11">{

        defaultDir, err := p.getDefaultDir(resolver)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="11">dirs := append([]string{defaultDir}, p.extraDirs...)

        var files []string
        for _, dir := range dirs </span><span class="cov5" title="11">{
                var temp []string
                temp, err = p.getFiles(dir, resolver)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov5" title="11">files = append(files, temp...)</span>
        }
        <span class="cov5" title="11">files = append(files, p.extraFiles...)

        var ret []PropertyCopier
        for _, s := range files </span><span class="cov10" title="88">{
                filename, err := resolver.Resolve(s)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov10" title="88">c, err := conf.Load(filename)
                if err != nil </span><span class="cov9" title="78">{
                        if os.IsNotExist(err) </span><span class="cov9" title="78">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov5" title="10">ret = append(ret, NewNamedPropertyCopier(filename, c))</span>
        }
        <span class="cov5" title="11">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_conf

import (
        "os"
        "regexp"
        "strings"

        "github.com/go-spring/spring-core/conf"
)

const (
        EnvironmentPrefix  = "GS_ENVS_PREFIX"
        IncludeEnvPatterns = "INCLUDE_ENV_PATTERNS"
        ExcludeEnvPatterns = "EXCLUDE_ENV_PATTERNS"
)

// Environment represents the environment configuration.
type Environment struct{}

// NewEnvironment initializes a new instance of Environment.
func NewEnvironment() *Environment <span class="cov1" title="2">{
        return &amp;Environment{}
}</span>

// lookupEnv searches for an environment variable by key in the environ slice.
func lookupEnv(environ []string, key string) (value string, found bool) <span class="cov5" title="24">{
        key = strings.TrimSpace(key) + "="
        for _, s := range environ </span><span class="cov10" title="1008">{
                if strings.HasPrefix(s, key) </span><span class="cov0" title="0">{
                        v := strings.TrimPrefix(s, key)
                        return strings.TrimSpace(v), true
                }</span>
        }
        <span class="cov5" title="24">return "", false</span>
}

// CopyTo add environment variables that matches IncludeEnvPatterns and
// exclude environment variables that matches ExcludeEnvPatterns.
func (c *Environment) CopyTo(p *conf.MutableProperties) error <span class="cov4" title="12">{
        environ := os.Environ()
        if len(environ) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="12">prefix := "GS_"
        if s := strings.TrimSpace(os.Getenv(EnvironmentPrefix)); s != "" </span><span class="cov0" title="0">{
                prefix = s
        }</span>

        <span class="cov4" title="12">toRex := func(patterns []string) ([]*regexp.Regexp, error) </span><span class="cov5" title="24">{
                var rex []*regexp.Regexp
                for _, v := range patterns </span><span class="cov4" title="12">{
                        exp, err := regexp.Compile(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov4" title="12">rex = append(rex, exp)</span>
                }
                <span class="cov5" title="24">return rex, nil</span>
        }

        <span class="cov4" title="12">includes := []string{".*"}
        if s, ok := lookupEnv(environ, IncludeEnvPatterns); ok </span><span class="cov0" title="0">{
                includes = strings.Split(s, ",")
        }</span>
        <span class="cov4" title="12">includeRex, err := toRex(includes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="12">var excludes []string
        if s, ok := lookupEnv(environ, ExcludeEnvPatterns); ok </span><span class="cov0" title="0">{
                excludes = strings.Split(s, ",")
        }</span>
        <span class="cov4" title="12">excludeRex, err := toRex(excludes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="12">matches := func(rex []*regexp.Regexp, s string) bool </span><span class="cov10" title="1008">{
                for _, r := range rex </span><span class="cov9" title="504">{
                        if r.MatchString(s) </span><span class="cov9" title="504">{
                                return true
                        }</span>
                }
                <span class="cov9" title="504">return false</span>
        }

        <span class="cov4" title="12">for _, env := range environ </span><span class="cov9" title="504">{
                ss := strings.SplitN(env, "=", 2)
                k, v := ss[0], ""
                if len(ss) &gt; 1 </span><span class="cov9" title="504">{
                        v = ss[1]
                }</span>

                <span class="cov9" title="504">var propKey string
                if strings.HasPrefix(k, prefix) </span><span class="cov0" title="0">{
                        propKey = strings.TrimPrefix(k, prefix)
                        propKey = strings.ToLower(replaceKey(propKey))
                }</span> else<span class="cov9" title="504"> if matches(includeRex, k) &amp;&amp; !matches(excludeRex, k) </span><span class="cov9" title="504">{
                        propKey = k
                }</span> else<span class="cov0" title="0"> {
                        continue</span>
                }

                <span class="cov9" title="504">if err = p.Set(propKey, v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov4" title="12">return nil</span>
}

// replaceKey replace '_' with '.'
func replaceKey(s string) string <span class="cov0" title="0">{
        b := make([]byte, len(s)+2)
        b[0] = '_'
        b[len(b)-1] = '_'
        copy(b[1:len(b)-1], s)
        for i := 1; i &lt; len(b)-1; i++ </span><span class="cov0" title="0">{
                if b[i] == '_' </span><span class="cov0" title="0">{
                        if b[i-1] != '_' &amp;&amp; b[i+1] != '_' </span><span class="cov0" title="0">{
                                b[i] = '.'
                        }</span>
                }
        }
        <span class="cov0" title="0">return string(b[1 : len(b)-1])</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_core

import (
        "github.com/go-spring/spring-core/conf"
        "github.com/go-spring/spring-core/gs/internal/gs_core/injecting"
        "github.com/go-spring/spring-core/gs/internal/gs_core/resolving"
)

type Container struct {
        *resolving.Resolving
        *injecting.Injecting
}

// New creates a IoC container.
func New() *Container <span class="cov10" title="2">{
        return &amp;Container{
                Resolving: resolving.New(),
        }
}</span>

// Refresh initializes and wires all beans in the container.
func (c *Container) Refresh(p conf.Properties) error <span class="cov10" title="2">{
        if err := c.Resolving.Refresh(p); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="2">c.Injecting = injecting.New(p)
        if err := c.Injecting.Refresh(c.Beans()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="2">c.Resolving = nil
        return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package injecting

import (
        "bytes"
        "container/list"
        "errors"
        "fmt"
        "reflect"
        "slices"
        "sort"
        "strings"
        "testing"

        "github.com/go-spring/spring-core/conf"
        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/gs/internal/gs_arg"
        "github.com/go-spring/spring-core/gs/internal/gs_bean"
        "github.com/go-spring/spring-core/gs/internal/gs_dync"
        "github.com/go-spring/spring-core/gs/internal/gs_util"
        "github.com/go-spring/spring-core/util"
        "github.com/go-spring/spring-core/util/syslog"
        "github.com/spf13/cast"
)

// BeanRuntime defines an interface for runtime bean information.
type BeanRuntime interface {
        Name() string
        Type() reflect.Type
        Value() reflect.Value
        Interface() interface{}
        Callable() *gs_arg.Callable
        Status() gs_bean.BeanStatus
        String() string
}

// refreshState represents the state of a refresh operation.
type refreshState int

const (
        RefreshDefault = refreshState(iota) // Not refreshed yet
        Refreshing                          // Currently refreshing
        Refreshed                           // Successfully refreshed
)

// Injecting defines a bean injection container.
type Injecting struct {
        p           *gs_dync.Properties
        beansByName map[string][]BeanRuntime // 用于查找未导出接口
        beansByType map[reflect.Type][]BeanRuntime
        destroyers  []func()
}

// New creates a new Injecting instance.
func New(p conf.Properties) *Injecting <span class="cov2" title="2">{
        return &amp;Injecting{
                p: gs_dync.New(p),
        }
}</span>

// RefreshProperties refreshes the properties of the container.
func (c *Injecting) RefreshProperties(p conf.Properties) error <span class="cov4" title="4">{
        return c.p.Refresh(p)
}</span>

// Refresh refreshes the container with the given beans.
func (c *Injecting) Refresh(beans []*gs_bean.BeanDefinition) (err error) <span class="cov2" title="2">{
        allowCircularReferences := cast.ToBool(c.p.Data().Get("spring.allow-circular-references"))
        forceAutowireIsNullable := cast.ToBool(c.p.Data().Get("spring.force-autowire-is-nullable"))

        // registers all beans
        c.beansByName = make(map[string][]BeanRuntime)
        c.beansByType = make(map[reflect.Type][]BeanRuntime)
        for _, b := range beans </span><span class="cov8" title="16">{
                c.beansByName[b.Name()] = append(c.beansByName[b.Name()], b)
                c.beansByType[b.Type()] = append(c.beansByType[b.Type()], b)
                for _, t := range b.Exports() </span><span class="cov5" title="6">{
                        c.beansByType[t] = append(c.beansByType[t], b)
                }</span>
        }

        <span class="cov2" title="2">stack := NewStack()
        defer func() </span><span class="cov2" title="2">{
                if err != nil || len(stack.beans) &gt; 0 </span><span class="cov0" title="0">{
                        err = fmt.Errorf("%s ↩\n%s", err, stack.Path())
                        syslog.Errorf("%s", err.Error())
                }</span>
        }()

        <span class="cov2" title="2">r := &amp;Injector{
                state:                   RefreshDefault,
                p:                       c.p,
                beansByName:             c.beansByName,
                beansByType:             c.beansByType,
                forceAutowireIsNullable: forceAutowireIsNullable,
        }

        // injects all beans
        r.state = Refreshing
        for _, b := range beans </span><span class="cov8" title="16">{
                if err = r.wireBean(b, stack); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov2" title="2">r.state = Refreshed

        if allowCircularReferences </span><span class="cov0" title="0">{
                // processes the bean fields that are marked for lazy injection.
                for _, f := range stack.lazyFields </span><span class="cov0" title="0">{
                        tag := strings.TrimSuffix(f.tag, ",lazy")
                        if err = r.autowire(f.v, tag, stack); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%q wired error: %s", f.path, err.Error())
                        }</span>
                }
        } else<span class="cov2" title="2"> if len(stack.lazyFields) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New("found circular autowire")
        }</span>

        <span class="cov2" title="2">c.destroyers = stack.getSortedDestroyers()

        forceClean := cast.ToBool(c.p.Data().Get("spring.force-clean"))
        if !testing.Testing() || forceClean </span><span class="cov2" title="2">{
                if c.p.ObjectsCount() == 0 </span><span class="cov1" title="1">{
                        c.p = nil
                }</span>
                <span class="cov2" title="2">c.beansByName = nil
                c.beansByType = nil
                return nil</span>
        }

        <span class="cov0" title="0">c.beansByName = make(map[string][]BeanRuntime)
        c.beansByType = make(map[reflect.Type][]BeanRuntime)
        for _, b := range beans </span><span class="cov0" title="0">{
                c.beansByName[b.Name()] = append(c.beansByName[b.Name()], b.BeanRuntime)
                c.beansByType[b.Type()] = append(c.beansByType[b.Type()], b.BeanRuntime)
                for _, t := range b.Exports() </span><span class="cov0" title="0">{
                        c.beansByType[t] = append(c.beansByType[t], b.BeanRuntime)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Wire injects dependencies into the given object.
func (c *Injecting) Wire(obj interface{}) error <span class="cov0" title="0">{
        r := &amp;Injector{
                state:                   Refreshed,
                p:                       gs_dync.New(c.p.Data()),
                beansByName:             c.beansByName,
                beansByType:             c.beansByType,
                forceAutowireIsNullable: true,
        }
        t := reflect.TypeOf(obj)
        v := reflect.ValueOf(obj)
        return r.wireBeanValue(v, t, NewStack())
}</span>

// Close closes the container and cleans up resources.
func (c *Injecting) Close() <span class="cov2" title="2">{
        for _, f := range slices.Backward(c.destroyers) </span><span class="cov3" title="3">{
                f()
        }</span>
}

type Injector struct {
        state                   refreshState
        p                       *gs_dync.Properties
        beansByName             map[string][]BeanRuntime
        beansByType             map[reflect.Type][]BeanRuntime
        forceAutowireIsNullable bool
}

// findBeans finds beans based on a given selector.
func (c *Injector) findBeans(s gs.BeanSelector) []BeanRuntime <span class="cov0" title="0">{
        t, name := s.TypeAndName()
        var beans []BeanRuntime
        if t != nil </span><span class="cov0" title="0">{
                beans = c.beansByType[t]
        }</span>
        <span class="cov0" title="0">if name != "" </span><span class="cov0" title="0">{
                var ret []BeanRuntime
                for _, b := range beans </span><span class="cov0" title="0">{
                        if name == b.Name() </span><span class="cov0" title="0">{
                                ret = append(ret, b)
                        }</span>
                }
                <span class="cov0" title="0">beans = ret</span>
        }
        <span class="cov0" title="0">return beans</span>
}

// WireTag represents a parsed injection tag in the format TypeName:BeanName?.
type WireTag struct {
        beanName string // Bean name for injection.
        nullable bool   // Whether the injection can be nil.
}

// String converts a wireTag back to its string representation.
func (tag WireTag) String() string <span class="cov0" title="0">{
        b := bytes.NewBuffer(nil)
        b.WriteString(tag.beanName)
        if tag.nullable </span><span class="cov0" title="0">{
                b.WriteString("?")
        }</span>
        <span class="cov0" title="0">return b.String()</span>
}

// toWireString converts a slice of wireTags to a comma-separated string.
func toWireString(tags []WireTag) string <span class="cov0" title="0">{
        var buf bytes.Buffer
        for i, tag := range tags </span><span class="cov0" title="0">{
                buf.WriteString(tag.String())
                if i &lt; len(tags)-1 </span><span class="cov0" title="0">{
                        buf.WriteByte(',')
                }</span>
        }
        <span class="cov0" title="0">return buf.String()</span>
}

// parseWireTag parses a wire tag string and returns a wireTag struct.
func parseWireTag(str string) (tag WireTag) <span class="cov6" title="8">{
        if str != "" </span><span class="cov3" title="3">{
                if n := len(str) - 1; str[n] == '?' </span><span class="cov0" title="0">{
                        tag.beanName = str[:n]
                        tag.nullable = true
                }</span> else<span class="cov3" title="3"> {
                        tag.beanName = str
                }</span>
        }
        <span class="cov6" title="8">return</span>
}

// getSingleBean retrieves the bean corresponding to the specified tag and assigns it to `v`.
// `v` should be an uninitialized value.
func (c *Injector) getBean(t reflect.Type, tag WireTag, stack *Stack) (BeanRuntime, error) <span class="cov6" title="8">{

        // Check if the type of `v` is a valid bean receiver type.
        if !util.IsBeanInjectionTarget(t) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s is not a valid receiver type", t.String())
        }</span>

        <span class="cov6" title="8">var foundBeans []BeanRuntime
        // Iterate through all beans of the given type and match against the tag.
        for _, b := range c.beansByType[t] </span><span class="cov7" title="14">{
                if tag.beanName == "" || tag.beanName == b.Name() </span><span class="cov6" title="8">{
                        foundBeans = append(foundBeans, b)
                }</span>
        }

        // When a specific bean name is provided, find it by name.
        <span class="cov6" title="8">if t.Kind() == reflect.Interface &amp;&amp; tag.beanName != "" </span><span class="cov0" title="0">{
                for _, b := range c.beansByName[tag.beanName] </span><span class="cov0" title="0">{
                        if !b.Type().AssignableTo(t) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if !slices.Contains(foundBeans, b) </span><span class="cov0" title="0">{
                                foundBeans = append(foundBeans, b)
                                syslog.Warnf("you should call Export() on %s", b)
                        }</span>
                }
        }

        // If no matching beans are found and the tag allows nullable beans, return nil.
        <span class="cov6" title="8">if len(foundBeans) == 0 </span><span class="cov0" title="0">{
                if tag.nullable </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("can't find bean, bean:%q type:%q", tag, t)</span>
        }

        // If more than one matching bean is found, return an error.
        <span class="cov6" title="8">if len(foundBeans) &gt; 1 </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("found %d beans, bean:%q type:%q [", len(foundBeans), tag, t)
                for _, b := range foundBeans </span><span class="cov0" title="0">{
                        msg += "( " + b.String() + " ), "
                }</span>
                <span class="cov0" title="0">msg = msg[:len(msg)-2] + "]"
                return nil, errors.New(msg)</span>
        }

        // Retrieve the single matching bean.
        <span class="cov6" title="8">b := foundBeans[0]
        if c.state == Refreshing </span><span class="cov6" title="8">{
                if err := c.wireBean(b.(*gs_bean.BeanDefinition), stack); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov6" title="8">return b, nil</span>
}

// getMultiBeans collects beans into the given slice or map value `v`.
// It supports dependency injection by resolving matching beans based on tags.
func (c *Injector) getBeans(t reflect.Type, tags []WireTag, nullable bool, stack *Stack) ([]BeanRuntime, error) <span class="cov4" title="4">{

        et := t.Elem()
        if !util.IsBeanInjectionTarget(et) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s is not a valid receiver type", t.String())
        }</span>

        <span class="cov4" title="4">beans := c.beansByType[et]

        // Process bean tags to filter and order beans
        if len(tags) &gt; 0 </span><span class="cov0" title="0">{
                var (
                        anyBeans  []int
                        afterAny  []int
                        beforeAny []int
                )
                foundAny := false
                for _, item := range tags </span><span class="cov0" title="0">{

                        // 是否遇到了"无序"标记
                        if item.beanName == "*" </span><span class="cov0" title="0">{
                                if foundAny </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("more than one * in collection %q", tags)
                                }</span>
                                <span class="cov0" title="0">foundAny = true
                                continue</span>
                        }

                        <span class="cov0" title="0">var founds []int
                        for i, b := range beans </span><span class="cov0" title="0">{
                                if item.beanName == b.Name() </span><span class="cov0" title="0">{
                                        founds = append(founds, i)
                                }</span>
                        }
                        <span class="cov0" title="0">if len(founds) &gt; 1 </span><span class="cov0" title="0">{
                                msg := fmt.Sprintf("found %d beans, bean:%q type:%q [", len(founds), item, t)
                                for _, i := range founds </span><span class="cov0" title="0">{
                                        msg += "( " + beans[i].String() + " ), "
                                }</span>
                                <span class="cov0" title="0">msg = msg[:len(msg)-2] + "]"
                                return nil, errors.New(msg)</span>
                        }
                        <span class="cov0" title="0">if len(founds) == 0 </span><span class="cov0" title="0">{
                                if item.nullable </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">return nil, fmt.Errorf("can't find bean, bean:%q type:%q", item, t)</span>
                        }

                        <span class="cov0" title="0">if foundAny </span><span class="cov0" title="0">{
                                afterAny = append(afterAny, founds[0])
                        }</span> else<span class="cov0" title="0"> {
                                beforeAny = append(beforeAny, founds[0])
                        }</span>
                }

                <span class="cov0" title="0">if foundAny </span><span class="cov0" title="0">{
                        temp := append(beforeAny, afterAny...)
                        for i := 0; i &lt; len(beans); i++ </span><span class="cov0" title="0">{
                                if slices.Contains(temp, i) </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">anyBeans = append(anyBeans, i)</span>
                        }
                }

                <span class="cov0" title="0">n := len(beforeAny) + len(anyBeans) + len(afterAny)
                arr := make([]BeanRuntime, 0, n)
                for _, i := range beforeAny </span><span class="cov0" title="0">{
                        arr = append(arr, beans[i])
                }</span>
                <span class="cov0" title="0">for _, i := range anyBeans </span><span class="cov0" title="0">{
                        arr = append(arr, beans[i])
                }</span>
                <span class="cov0" title="0">for _, i := range afterAny </span><span class="cov0" title="0">{
                        arr = append(arr, beans[i])
                }</span>

                <span class="cov0" title="0">beans = arr</span>
        }

        // Handle empty beans
        <span class="cov4" title="4">if len(beans) == 0 </span><span class="cov1" title="1">{
                if nullable </span><span class="cov1" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("no beans collected for %q", toWireString(tags))</span>
        }

        // Wire the beans based on the current state of the container
        <span class="cov3" title="3">if c.state == Refreshing </span><span class="cov3" title="3">{
                for _, b := range beans </span><span class="cov5" title="6">{
                        if err := c.wireBean(b.(*gs_bean.BeanDefinition), stack); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }
        <span class="cov3" title="3">return beans, nil</span>
}

// autowire performs dependency injection by tag.
func (c *Injector) autowire(v reflect.Value, str string, stack *Stack) error <span class="cov7" title="12">{
        str, err := c.p.Data().Resolve(str)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="12">switch v.Kind() </span>{
        case reflect.Map, reflect.Slice, reflect.Array:<span class="cov4" title="4">
                </span><span class="cov4" title="4">{
                        var nullable bool
                        var tags []WireTag
                        if str != "" </span><span class="cov4" title="4">{
                                nullable = true
                                if str != "?" </span><span class="cov0" title="0">{
                                        for _, s := range strings.Split(str, ",") </span><span class="cov0" title="0">{
                                                g := parseWireTag(s)
                                                tags = append(tags, g)
                                                if !g.nullable </span><span class="cov0" title="0">{
                                                        nullable = false
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov4" title="4">if c.forceAutowireIsNullable </span><span class="cov0" title="0">{
                                for i := 0; i &lt; len(tags); i++ </span><span class="cov0" title="0">{
                                        tags[i].nullable = true
                                }</span>
                                <span class="cov0" title="0">nullable = true</span>
                        }
                        <span class="cov4" title="4">beans, err := c.getBeans(v.Type(), tags, nullable, stack)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // Populate the slice or map with the resolved beans
                        <span class="cov4" title="4">switch v.Kind() </span>{
                        case reflect.Slice:<span class="cov4" title="4">
                                sort.Slice(beans, func(i, j int) bool </span><span class="cov3" title="3">{
                                        return beans[i].Name() &lt; beans[j].Name()
                                }</span>)
                                <span class="cov4" title="4">ret := reflect.MakeSlice(v.Type(), 0, 0)
                                for _, b := range beans </span><span class="cov5" title="6">{
                                        ret = reflect.Append(ret, b.Value())
                                }</span>
                                <span class="cov4" title="4">v.Set(ret)</span>
                        case reflect.Map:<span class="cov0" title="0">
                                ret := reflect.MakeMap(v.Type())
                                for _, b := range beans </span><span class="cov0" title="0">{
                                        ret.SetMapIndex(reflect.ValueOf(b.Name()), b.Value())
                                }</span>
                                <span class="cov0" title="0">v.Set(ret)</span>
                        default:<span class="cov0" title="0"></span>
                        }
                        <span class="cov4" title="4">return nil</span>
                }
        default:<span class="cov6" title="8">
                g := parseWireTag(str)
                if c.forceAutowireIsNullable </span><span class="cov0" title="0">{
                        g.nullable = true
                }</span>
                <span class="cov6" title="8">b, err := c.getBean(v.Type(), g, stack)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="8">if b != nil </span><span class="cov6" title="8">{
                        v.Set(b.Value())
                }</span>
                <span class="cov6" title="8">return nil</span>
        }
}

// wireBean performs property binding and dependency injection for the specified bean.
// It also tracks its injection path. If the bean has an initialization function, it
// is executed after the injection is completed. If the bean depends on other beans,
// it attempts to instantiate and inject those dependencies first.
func (c *Injector) wireBean(b *gs_bean.BeanDefinition, stack *Stack) error <span class="cov9" title="30">{

        haveDestroy := false

        // Ensure destroy functions are cleaned up in case of failure.
        defer func() </span><span class="cov9" title="30">{
                if haveDestroy </span><span class="cov5" title="6">{
                        stack.popDestroyer()
                }</span>
        }()

        // Record the destroy function for the bean, if it exists.
        <span class="cov9" title="30">if b.Destroy() != nil </span><span class="cov5" title="6">{
                haveDestroy = true
                stack.pushDestroyer(b)
        }</span>

        <span class="cov9" title="30">stack.pushBean(b)

        // Detect circular dependency.
        if b.Status() == gs_bean.StatusCreating &amp;&amp; b.Callable() != nil </span><span class="cov0" title="0">{
                for _, bean := range stack.beans </span><span class="cov0" title="0">{
                        if bean == b </span><span class="cov0" title="0">{
                                return errors.New("found circular autowire")
                        }</span>
                }
        }

        // If the bean is already being created, return early.
        <span class="cov9" title="30">if b.Status() &gt;= gs_bean.StatusCreating </span><span class="cov7" title="14">{
                stack.popBean()
                return nil
        }</span>

        // Mark the bean as being created.
        <span class="cov8" title="16">b.SetStatus(gs_bean.StatusCreating)

        // Inject dependencies for the current bean.
        for _, s := range b.DependsOn() </span><span class="cov0" title="0">{
                beans := c.findBeans(s)
                for _, d := range beans </span><span class="cov0" title="0">{
                        err := c.wireBean(d.(*gs_bean.BeanDefinition), stack)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // Get the value of the current bean.
        <span class="cov8" title="16">v, err := c.getBeanValue(b, stack)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="16">b.SetStatus(gs_bean.StatusCreated)

        // Check if the bean has a value and wire it if it does.
        if v.IsValid() &amp;&amp; !b.Mocked() </span><span class="cov8" title="16">{

                // Wire the value of the bean.
                err = c.wireBeanValue(v, v.Type(), stack)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Execute the bean's initialization function, if it exists.
                <span class="cov8" title="16">if b.Init() != nil </span><span class="cov0" title="0">{
                        fnValue := reflect.ValueOf(b.Init())
                        out := fnValue.Call([]reflect.Value{b.Value()})
                        if len(out) &gt; 0 &amp;&amp; !out[0].IsNil() </span><span class="cov0" title="0">{
                                return out[0].Interface().(error)
                        }</span>
                }
        }

        // Mark the bean as wired and pop it from the stack.
        <span class="cov8" title="16">b.SetStatus(gs_bean.StatusWired)
        stack.popBean()
        return nil</span>
}

// getBeanValue retrieves the value of a bean. If it is a constructor bean,
// it executes the constructor and returns the result.
func (c *Injector) getBeanValue(b BeanRuntime, stack *Stack) (reflect.Value, error) <span class="cov8" title="16">{

        // If the bean has no callable function, return its value directly.
        if b.Callable() == nil </span><span class="cov7" title="13">{
                return b.Value(), nil
        }</span>

        // Call the bean's constructor and handle errors.
        <span class="cov3" title="3">out, err := b.Callable().Call(NewArgContext(c, stack))
        if err != nil </span><span class="cov0" title="0">{
                if c.forceAutowireIsNullable </span><span class="cov0" title="0">{
                        syslog.Warnf("autowire error: %v", err)
                        return reflect.Value{}, nil
                }</span>
                <span class="cov0" title="0">return reflect.Value{}, err</span>
        }

        <span class="cov3" title="3">if o := out[len(out)-1]; util.IsErrorType(o.Type()) </span><span class="cov0" title="0">{
                if i := o.Interface(); i != nil </span><span class="cov0" title="0">{
                        if c.forceAutowireIsNullable </span><span class="cov0" title="0">{
                                syslog.Warnf("autowire error: %v", err)
                                return reflect.Value{}, nil
                        }</span>
                        <span class="cov0" title="0">return reflect.Value{}, i.(error)</span>
                }
        }

        // If the return value is of bean type, handle it accordingly.
        <span class="cov3" title="3">if val := out[0]; util.IsBeanType(val.Type()) </span><span class="cov3" title="3">{
                // If it's a non-pointer value type, convert it into a pointer and set it.
                if !val.IsNil() &amp;&amp; val.Kind() == reflect.Interface &amp;&amp; util.IsPropBindingTarget(val.Elem().Type()) </span><span class="cov0" title="0">{
                        v := reflect.New(val.Elem().Type())
                        v.Elem().Set(val.Elem())
                        b.Value().Set(v)
                }</span> else<span class="cov3" title="3"> {
                        b.Value().Set(val)
                }</span>
        } else<span class="cov0" title="0"> {
                b.Value().Elem().Set(val)
        }</span>

        // Return an error if the value is nil.
        <span class="cov3" title="3">if b.Value().IsNil() </span><span class="cov0" title="0">{
                return reflect.Value{}, fmt.Errorf("%s return nil", b.String()) // b.GetClass(), b.FileLine())
        }</span>

        <span class="cov3" title="3">v := b.Value()
        // If the result is an interface, extract the original value.
        if v.Kind() == reflect.Interface </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>
        <span class="cov3" title="3">return v, nil</span>
}

// wireBeanValue binds properties and injects dependencies into the value v. v should already be initialized.
func (c *Injector) wireBeanValue(v reflect.Value, t reflect.Type, stack *Stack) error <span class="cov8" title="16">{

        // Dereference pointer types and adjust the target type.
        if v.Kind() == reflect.Ptr </span><span class="cov7" title="13">{
                v = v.Elem()
                t = t.Elem()
        }</span>

        // If v is not a struct type, no injection is needed.
        <span class="cov8" title="16">if v.Kind() != reflect.Struct </span><span class="cov3" title="3">{
                return nil
        }</span>

        <span class="cov7" title="13">typeName := t.Name()
        if typeName == "" </span><span class="cov0" title="0">{
                // Simple types don't have names, use their string representation.
                typeName = t.String()
        }</span>

        <span class="cov7" title="13">param := conf.BindParam{Path: typeName}
        return c.wireStruct(v, t, param, stack)</span>
}

// wireStruct performs dependency injection for a struct.
func (c *Injector) wireStruct(v reflect.Value, t reflect.Type, opt conf.BindParam, stack *Stack) error <span class="cov7" title="14">{
        // Loop through each field of the struct.
        for i := 0; i &lt; t.NumField(); i++ </span><span class="cov10" title="33">{
                ft := t.Field(i)
                fv := v.Field(i)

                // If the field is unexported, try to patch it.
                if !fv.CanInterface() </span><span class="cov7" title="15">{
                        fv = util.PatchValue(fv)
                }</span>

                <span class="cov10" title="33">fieldPath := opt.Path + "." + ft.Name

                // Check for autowire or inject tags.
                tag, ok := ft.Tag.Lookup("autowire")
                if !ok </span><span class="cov9" title="24">{
                        tag, ok = ft.Tag.Lookup("inject")
                }</span>
                <span class="cov10" title="33">if ok </span><span class="cov6" title="9">{
                        // Handle lazy injection.
                        if strings.HasSuffix(tag, ",lazy") </span><span class="cov0" title="0">{
                                f := LazyField{v: fv, path: fieldPath, tag: tag}
                                stack.lazyFields = append(stack.lazyFields, f)
                        }</span> else<span class="cov6" title="9"> {
                                if err := c.autowire(fv, tag, stack); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("%q wired error: %w", fieldPath, err)
                                }</span>
                        }
                        <span class="cov6" title="9">continue</span>
                }

                <span class="cov9" title="24">subParam := conf.BindParam{
                        Key:  opt.Key,
                        Path: fieldPath,
                }

                // Bind values if the field has a "value" tag.
                if tag, ok = ft.Tag.Lookup("value"); ok </span><span class="cov4" title="4">{
                        if err := subParam.BindTag(tag, ft.Tag); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov4" title="4">if ft.Anonymous </span><span class="cov0" title="0">{
                                // Recursively wire anonymous structs.
                                err := c.wireStruct(fv, ft.Type, subParam, stack)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov4" title="4"> {
                                // Refresh field value if needed.
                                err := c.p.RefreshField(fv.Addr(), subParam)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov4" title="4">continue</span>
                }

                // Recursively wire anonymous struct fields.
                <span class="cov8" title="20">if ft.Anonymous &amp;&amp; ft.Type.Kind() == reflect.Struct </span><span class="cov1" title="1">{
                        if err := c.wireStruct(fv, ft.Type, subParam, stack); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov7" title="14">return nil</span>
}

// destroyer stores beans with destroy functions and their call order.
type destroyer struct {
        current *gs_bean.BeanDefinition   // The current bean being processed.
        depends []*gs_bean.BeanDefinition // Beans that must be destroyed before the current bean.
}

// after adds a bean to the later list, ensuring it is destroyed after the current bean.
func (d *destroyer) isDependOn(b *gs_bean.BeanDefinition) bool <span class="cov6" title="9">{
        return slices.Contains(d.depends, b)
}</span>

// after adds a bean to the later list, ensuring it is destroyed after the current bean.
func (d *destroyer) dependOn(b *gs_bean.BeanDefinition) <span class="cov0" title="0">{
        if d.isDependOn(b) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">d.depends = append(d.depends, b)</span>
}

// LazyField represents a lazy-injected field with metadata.
type LazyField struct {
        v    reflect.Value // The value to be injected.
        path string        // Path for the field in the injection hierarchy.
        tag  string        // Associated tag for the field.
}

// Stack tracks the injection path of beans and their destroyers.
type Stack struct {
        beans        []*gs_bean.BeanDefinition
        lazyFields   []LazyField
        destroyers   *list.List
        destroyerMap map[gs.BeanID]*destroyer
}

// NewStack creates a new Stack instance.
func NewStack() *Stack <span class="cov2" title="2">{
        return &amp;Stack{
                destroyers:   list.New(),
                destroyerMap: make(map[gs.BeanID]*destroyer),
        }
}</span>

// pushBean adds a bean to the injection path.
func (s *Stack) pushBean(b *gs_bean.BeanDefinition) <span class="cov9" title="30">{
        syslog.Debugf("push %s %s", b, b.Status())
        s.beans = append(s.beans, b)
}</span>

// popBean removes the last bean from the injection path.
func (s *Stack) popBean() <span class="cov9" title="30">{
        n := len(s.beans)
        b := s.beans[n-1]
        s.beans[n-1] = nil
        s.beans = s.beans[:n-1]
        syslog.Debugf("pop %s %s", b, b.Status())
}</span>

// Path returns the injection path as a string.
func (s *Stack) Path() (path string) <span class="cov0" title="0">{
        if len(s.beans) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">for _, b := range s.beans </span><span class="cov0" title="0">{
                path += fmt.Sprintf("=&gt; %s ↩\n", b)
        }</span>
        <span class="cov0" title="0">return path[:len(path)-1]</span> // Remove the trailing newline.
}

// pushDestroyer tracks a bean with a destroy function, ensuring no duplicates.
func (s *Stack) pushDestroyer(b *gs_bean.BeanDefinition) <span class="cov5" title="6">{
        beanID := gs.BeanID{Name: b.Name(), Type: b.Type()}
        d, ok := s.destroyerMap[beanID]
        if !ok </span><span class="cov3" title="3">{
                d = &amp;destroyer{current: b}
                s.destroyerMap[beanID] = d
        }</span>
        <span class="cov5" title="6">if i := s.destroyers.Back(); i != nil </span><span class="cov0" title="0">{
                d.dependOn(i.Value.(*gs_bean.BeanDefinition))
        }</span>
        <span class="cov5" title="6">s.destroyers.PushBack(b)</span>
}

// popDestroyer removes the last bean from the destroyer stack.
func (s *Stack) popDestroyer() <span class="cov5" title="6">{
        s.destroyers.Remove(s.destroyers.Back())
}</span>

// getBeforeDestroyers retrieves destroyers that should be processed before a given one for sorting purposes.
func getBeforeDestroyers(destroyers *list.List, i interface{}) *list.List <span class="cov3" title="3">{
        d := i.(*destroyer)
        result := list.New()
        for e := destroyers.Front(); e != nil; e = e.Next() </span><span class="cov6" title="9">{
                c := e.Value.(*destroyer)
                if d.isDependOn(c.current) </span><span class="cov0" title="0">{
                        result.PushBack(c)
                }</span>
        }
        <span class="cov3" title="3">return result</span>
}

// getSortedDestroyers sorts beans with destroy functions by dependency order.
func (s *Stack) getSortedDestroyers() []func() <span class="cov2" title="2">{

        destroy := func(v reflect.Value, fn interface{}) func() </span><span class="cov3" title="3">{
                return func() </span><span class="cov3" title="3">{
                        fnValue := reflect.ValueOf(fn)
                        out := fnValue.Call([]reflect.Value{v})
                        if len(out) &gt; 0 &amp;&amp; !out[0].IsNil() </span><span class="cov0" title="0">{
                                syslog.Errorf("%s", out[0].Interface().(error).Error())
                        }</span>
                }
        }

        <span class="cov2" title="2">destroyers := list.New()
        for _, d := range s.destroyerMap </span><span class="cov3" title="3">{
                destroyers.PushBack(d)
        }</span>
        // the injection process should first discover cyclic dependencies
        <span class="cov2" title="2">destroyers, _ = gs_util.TripleSort(destroyers, getBeforeDestroyers)

        var ret []func()
        for e := destroyers.Front(); e != nil; e = e.Next() </span><span class="cov3" title="3">{
                d := e.Value.(*destroyer).current
                ret = append(ret, destroy(d.Value(), d.Destroy()))
        }</span>
        <span class="cov2" title="2">return ret</span>
}

// ArgContext holds a Container and a Stack to manage dependency injection.
type ArgContext struct {
        c     *Injector
        stack *Stack
}

// NewArgContext creates a new ArgContext with a given Container and Stack.
func NewArgContext(c *Injector, stack *Stack) *ArgContext <span class="cov3" title="3">{
        return &amp;ArgContext{c: c, stack: stack}
}</span>

func (a *ArgContext) Has(key string) bool <span class="cov0" title="0">{
        return a.c.p.Data().Has(key)
}</span>

func (a *ArgContext) Prop(key string, def ...string) string <span class="cov0" title="0">{
        return a.c.p.Data().Get(key, def...)
}</span>

func (a *ArgContext) Find(s gs.BeanSelector) ([]gs.CondBean, error) <span class="cov0" title="0">{
        beans := a.c.findBeans(s)
        var ret []gs.CondBean
        for _, bean := range beans </span><span class="cov0" title="0">{
                ret = append(ret, bean)
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}

// Check checks if a given condition matches the container.
func (a *ArgContext) Check(c gs.Condition) (bool, error) <span class="cov0" title="0">{
        return c.Matches(a)
}</span>

// Bind binds a value to a specific tag in the container.
func (a *ArgContext) Bind(v reflect.Value, tag string) error <span class="cov4" title="4">{
        return a.c.p.Data().Bind(v, tag)
}</span>

// Wire wires a value based on a specific tag in the container.
func (a *ArgContext) Wire(v reflect.Value, tag string) error <span class="cov3" title="3">{
        return a.c.autowire(v, tag, a.stack)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package resolving

import (
        "errors"
        "fmt"
        "reflect"
        "regexp"
        "slices"

        "github.com/go-spring/spring-core/conf"
        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/gs/internal/gs_bean"
        "github.com/go-spring/spring-core/gs/internal/gs_cond"
        "github.com/go-spring/spring-core/util"
)

// RefreshState represents the current state of the container.
type RefreshState int

const (
        RefreshDefault = RefreshState(iota)
        Refreshing
        Refreshed
)

// BeanGroupFunc defines a function that dynamically registers beans
// based on configuration properties.
type BeanGroupFunc func(p conf.Properties) ([]*gs.BeanDefinition, error)

// BeanMock defines a mock object and its target bean selector for overriding.
type BeanMock struct {
        Object interface{}     // Mock instance to replace the target bean
        Target gs.BeanSelector // Selector to identify the target bean
}

// Resolving manages bean definitions, mocks, and dynamic bean registration functions.
type Resolving struct {
        state RefreshState              // Current refresh state
        mocks []BeanMock                // Registered mock beans
        beans []*gs_bean.BeanDefinition // Managed bean definitions
        funcs []BeanGroupFunc           // Dynamic bean registration functions
}

// New creates an empty Resolving instance.
func New() *Resolving <span class="cov3" title="2">{
        return &amp;Resolving{}
}</span>

// Beans returns all active bean definitions, excluding deleted ones.
func (c *Resolving) Beans() []*gs_bean.BeanDefinition <span class="cov3" title="2">{
        var beans []*gs_bean.BeanDefinition
        for _, b := range c.beans </span><span class="cov9" title="16">{
                if b.Status() == gs_bean.StatusDeleted </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov9" title="16">beans = append(beans, b)</span>
        }
        <span class="cov3" title="2">return beans</span>
}

// Mock registers a mock object to override a bean matching the selector.
func (c *Resolving) Mock(obj interface{}, target gs.BeanSelector) <span class="cov0" title="0">{
        mock := BeanMock{Object: obj, Target: target}
        c.mocks = append(c.mocks, mock)
}</span>

// Object registers a pre-constructed instance as a bean.
func (c *Resolving) Object(i interface{}) *gs.RegisteredBean <span class="cov3" title="2">{
        b := gs_bean.NewBean(reflect.ValueOf(i))
        return c.Register(b).Caller(1)
}</span>

// Provide registers a constructor function to create a bean.
func (c *Resolving) Provide(ctor interface{}, args ...gs.Arg) *gs.RegisteredBean <span class="cov0" title="0">{
        b := gs_bean.NewBean(ctor, args...)
        return c.Register(b).Caller(1)
}</span>

// Register adds a bean definition to the container.
func (c *Resolving) Register(b *gs.BeanDefinition) *gs.RegisteredBean <span class="cov8" title="13">{
        if c.state &gt;= Refreshing </span><span class="cov0" title="0">{
                panic("container is refreshing or already refreshed")</span>
        }
        <span class="cov8" title="13">bd := b.BeanRegistration().(*gs_bean.BeanDefinition)
        c.beans = append(c.beans, bd)
        return gs.NewRegisteredBean(bd)</span>
}

// GroupRegister adds a function to dynamically register beans.
func (c *Resolving) GroupRegister(fn BeanGroupFunc) <span class="cov1" title="1">{
        c.funcs = append(c.funcs, fn)
}</span>

// Refresh performs the full initialization process of the container.
// It transitions through several phases:
// - Executes group functions to register additional beans.
// - Scans configuration beans and registers their methods as beans.
// - Applies mock beans to override specific targets.
// - Resolves all beans based on their conditions.
// - Validates that no duplicate beans exist.
func (c *Resolving) Refresh(p conf.Properties) error <span class="cov3" title="2">{
        if c.state != RefreshDefault </span><span class="cov0" title="0">{
                return errors.New("container is already refreshing or refreshed")
        }</span>
        <span class="cov3" title="2">c.state = Refreshing

        if err := c.applyGroupFuncs(p); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">if err := c.scanConfigurations(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">if err := c.applyMocks(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">if err := c.resolveBeans(p); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">if err := c.checkDuplicateBeans(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">c.state = Refreshed
        return nil</span>
}

// applyGroupFuncs executes registered group functions to add dynamic beans.
func (c *Resolving) applyGroupFuncs(p conf.Properties) error <span class="cov3" title="2">{
        for _, fn := range c.funcs </span><span class="cov1" title="1">{
                beans, err := fn(p)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">for _, b := range beans </span><span class="cov4" title="3">{
                        d := b.BeanRegistration().(*gs_bean.BeanDefinition)
                        c.beans = append(c.beans, d)
                }</span>
        }
        <span class="cov3" title="2">return nil</span>
}

// scanConfigurations processes configuration beans to register their methods as beans.
func (c *Resolving) scanConfigurations() error <span class="cov3" title="2">{
        for _, b := range c.beans </span><span class="cov9" title="16">{
                if b.Configuration() == nil </span><span class="cov9" title="16">{
                        continue</span>
                }
                // Check if the configuration bean has a mock override
                <span class="cov0" title="0">var foundMocks []BeanMock
                for _, mock := range c.mocks </span><span class="cov0" title="0">{
                        t, s := mock.Target.TypeAndName()
                        if s != "" &amp;&amp; s != b.Name() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if t != b.Type() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">foundMocks = append(foundMocks, mock)</span>
                }
                <span class="cov0" title="0">if n := len(foundMocks); n &gt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("found duplicate mock bean for '%s'", b.Name())
                }</span> else<span class="cov0" title="0"> if n == 1 </span><span class="cov0" title="0">{
                        b.SetMock(foundMocks[0].Object)
                        continue</span>
                }
                // Scan methods if no mock is applied
                <span class="cov0" title="0">beans, err := c.scanConfiguration(b)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">c.beans = append(c.beans, beans...)</span>
        }
        <span class="cov3" title="2">return nil</span>
}

// scanConfiguration inspects the methods of a configuration bean, and for each
// method that matches the include patterns and not the exclude patterns,
// registers it as a bean. This enables dynamic bean registration based on method
// naming conventions or regex.
func (c *Resolving) scanConfiguration(bd *gs_bean.BeanDefinition) ([]*gs_bean.BeanDefinition, error) <span class="cov0" title="0">{
        var (
                includes []*regexp.Regexp
                excludes []*regexp.Regexp
        )

        param := bd.Configuration()
        ss := param.Includes
        if len(ss) == 0 </span><span class="cov0" title="0">{
                ss = []string{"New.*"}
        }</span>
        <span class="cov0" title="0">for _, s := range ss </span><span class="cov0" title="0">{
                p, err := regexp.Compile(s)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">includes = append(includes, p)</span>
        }

        <span class="cov0" title="0">ss = param.Excludes
        for _, s := range ss </span><span class="cov0" title="0">{
                p, err := regexp.Compile(s)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">excludes = append(excludes, p)</span>
        }

        <span class="cov0" title="0">var ret []*gs_bean.BeanDefinition
        n := bd.Type().NumMethod()
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                m := bd.Type().Method(i)
                skip := false
                for _, p := range excludes </span><span class="cov0" title="0">{
                        if p.MatchString(m.Name) </span><span class="cov0" title="0">{
                                skip = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if skip </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for _, p := range includes </span><span class="cov0" title="0">{
                        if !p.MatchString(m.Name) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">b := gs_bean.NewBean(m.Func.Interface(), gs.NewBeanDefinition(bd)).
                                Name(bd.Name() + "_" + m.Name).
                                Condition(gs_cond.OnBeanSelector(bd)).
                                BeanRegistration().(*gs_bean.BeanDefinition)
                        file, line, _ := util.FileLine(m.Func.Interface())
                        b.SetFileLine(file, line)
                        ret = append(ret, b)
                        break</span>
                }
        }
        <span class="cov0" title="0">return ret, nil</span>
}

// isBeanMatched checks if a bean matches the target type and name selector.
func isBeanMatched(t reflect.Type, s string, b *gs_bean.BeanDefinition) bool <span class="cov8" title="13">{
        if s != "" &amp;&amp; s != b.Name() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="13">if t != nil &amp;&amp; t != b.Type() </span><span class="cov8" title="12">{
                if !slices.Contains(b.Exports(), t) </span><span class="cov8" title="12">{
                        return false
                }</span>
        }
        <span class="cov1" title="1">return true</span>
}

// applyMocks overrides target beans with registered mock objects.
func (c *Resolving) applyMocks() error <span class="cov3" title="2">{
        for _, mock := range c.mocks </span><span class="cov0" title="0">{
                if err := c.applyMock(mock); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov3" title="2">return nil</span>
}

// applyMock applies a mock object to its target bean. It ensures that the mock
// implements all the interfaces that the original bean exported. If multiple
// matching beans are found, or if the mock doesn't implement required interfaces,
// an error is returned.
func (c *Resolving) applyMock(mock BeanMock) error <span class="cov0" title="0">{
        var foundBeans []*gs_bean.BeanDefinition
        vt := reflect.TypeOf(mock.Object)
        t, s := mock.Target.TypeAndName()

        for _, b := range c.beans </span><span class="cov0" title="0">{
                if !isBeanMatched(t, s, b) </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Verify mock implements all exported interfaces
                <span class="cov0" title="0">for _, et := range b.Exports() </span><span class="cov0" title="0">{
                        if !vt.Implements(et) </span><span class="cov0" title="0">{
                                return fmt.Errorf("found unimplemented interface")
                        }</span>
                }
                <span class="cov0" title="0">foundBeans = append(foundBeans, b)</span>
        }
        <span class="cov0" title="0">if len(foundBeans) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if len(foundBeans) &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("found duplicate mocked beans")
        }</span>
        <span class="cov0" title="0">foundBeans[0].SetMock(mock.Object)
        return nil</span>
}

// resolveBeans evaluates conditions for all beans and marks inactive ones.
func (c *Resolving) resolveBeans(p conf.Properties) error <span class="cov3" title="2">{
        ctx := &amp;CondContext{p: p, c: c}
        for _, b := range c.beans </span><span class="cov9" title="16">{
                if err := ctx.resolveBean(b); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov3" title="2">return nil</span>
}

// checkDuplicateBeans ensures no duplicate type/name combinations exist.
func (c *Resolving) checkDuplicateBeans() error <span class="cov3" title="2">{
        beansByID := make(map[gs.BeanID]*gs_bean.BeanDefinition)
        for _, b := range c.beans </span><span class="cov9" title="16">{
                if b.Status() == gs_bean.StatusDeleted </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov9" title="16">for _, t := range append(b.Exports(), b.Type()) </span><span class="cov10" title="22">{
                        beanID := gs.BeanID{Name: b.Name(), Type: t}
                        if d, ok := beansByID[beanID]; ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("found duplicate beans [%s] [%s]", b, d)
                        }</span>
                        <span class="cov10" title="22">beansByID[beanID] = b</span>
                }
        }
        <span class="cov3" title="2">return nil</span>
}

// CondContext provides condition evaluation context during resolution.
type CondContext struct {
        c *Resolving
        p conf.Properties
}

// resolveBean evaluates a bean's conditions, updating its status accordingly.
// If any condition fails, the bean is marked as deleted.
func (c *CondContext) resolveBean(b *gs_bean.BeanDefinition) error <span class="cov9" title="17">{
        if b.Status() &gt;= gs_bean.StatusResolving </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov9" title="16">b.SetStatus(gs_bean.StatusResolving)
        for _, cond := range b.Conditions() </span><span class="cov6" title="6">{
                if ok, err := cond.Matches(c); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov6" title="6"> if !ok </span><span class="cov0" title="0">{
                        b.SetStatus(gs_bean.StatusDeleted)
                        return nil
                }</span>
        }
        <span class="cov9" title="16">b.SetStatus(gs_bean.StatusResolved)
        return nil</span>
}

// Has checks if a configuration property exists.
func (c *CondContext) Has(key string) bool <span class="cov5" title="4">{
        return c.p.Has(key)
}</span>

// Prop retrieves a configuration property with optional default value.
func (c *CondContext) Prop(key string, def ...string) string <span class="cov3" title="2">{
        return c.p.Get(key, def...)
}</span>

// Find returns beans matching the selector after resolving their conditions.
func (c *CondContext) Find(s gs.BeanSelector) ([]gs.CondBean, error) <span class="cov1" title="1">{
        var found []gs.CondBean
        t, name := s.TypeAndName()
        for _, b := range c.c.beans </span><span class="cov8" title="14">{
                if b.Status() == gs_bean.StatusResolving || b.Status() == gs_bean.StatusDeleted </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov8" title="13">if !isBeanMatched(t, name, b) </span><span class="cov8" title="12">{
                        continue</span>
                }
                <span class="cov1" title="1">if err := c.resolveBean(b); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">if b.Status() == gs_bean.StatusDeleted </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">found = append(found, b)</span>
        }
        <span class="cov1" title="1">return found, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_dync

import (
        "encoding/json"
        "reflect"
        "sort"
        "strings"
        "sync"
        "sync/atomic"

        "github.com/go-spring/spring-core/conf"
)

// refreshable represents an object that can be dynamically refreshed.
type refreshable interface {
        onRefresh(prop conf.Properties, param conf.BindParam) error
}

// Listener holds a channel to receive notifications.
type Listener struct {
        C chan struct{}
}

// listeners maintains a collection of listeners that can be notified on value updates.
type listeners struct {
        m sync.Mutex
        a []*Listener
}

// NewListener creates and registers a new listener.
func (r *listeners) NewListener() *Listener <span class="cov0" title="0">{
        r.m.Lock()
        defer r.m.Unlock()
        l := &amp;Listener{C: make(chan struct{})}
        r.a = append(r.a, l)
        return l
}</span>

// notifyAll sends a notification signal to all registered listeners.
func (r *listeners) notifyAll() <span class="cov3" title="5">{
        r.m.Lock()
        defer r.m.Unlock()
        for _, l := range r.a </span><span class="cov0" title="0">{
                select </span>{
                case l.C &lt;- struct{}{}:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                }
        }
}

// Value represents a thread-safe object that can dynamically refresh its value.
type Value[T any] struct {
        listeners
        v atomic.Value
}

// Value retrieves the current value stored in the object.
// If no value is set, it returns the zero value for the type T.
func (r *Value[T]) Value() T <span class="cov3" title="5">{
        v, ok := r.v.Load().(T)
        if !ok </span><span class="cov0" title="0">{
                var zero T
                return zero
        }</span>
        <span class="cov3" title="5">return v</span>
}

// onRefresh updates the stored value with new properties and notifies listeners.
func (r *Value[T]) onRefresh(prop conf.Properties, param conf.BindParam) error <span class="cov3" title="5">{
        t := reflect.TypeFor[T]()
        v := reflect.New(t).Elem()
        err := conf.BindValue(prop, v, t, param, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="5">r.v.Store(v.Interface())
        r.notifyAll()
        return nil</span>
}

// MarshalJSON serializes the stored value as JSON.
func (r *Value[T]) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(r.v.Load())
}</span>

// refreshObject represents an object bound to dynamic properties that can be refreshed.
type refreshObject struct {
        target refreshable    // The refreshable object.
        param  conf.BindParam // Parameters used for refreshing.
}

// Properties manages dynamic properties and refreshable objects.
type Properties struct {
        prop    conf.Properties  // The current properties.
        lock    sync.RWMutex     // A read-write lock for thread-safe access.
        objects []*refreshObject // List of refreshable objects bound to the properties.
}

// New creates and returns a new Properties instance.
func New(p conf.Properties) *Properties <span class="cov2" title="2">{
        return &amp;Properties{
                prop: p,
        }
}</span>

// Data returns the current properties.
func (p *Properties) Data() conf.Properties <span class="cov6" title="22">{
        p.lock.RLock()
        defer p.lock.RUnlock()
        return p.prop
}</span>

// ObjectsCount returns the number of registered refreshable objects.
func (p *Properties) ObjectsCount() int <span class="cov2" title="2">{
        p.lock.RLock()
        defer p.lock.RUnlock()
        return len(p.objects)
}</span>

// Refresh updates the properties and refreshes all bound objects as necessary.
func (p *Properties) Refresh(prop conf.Properties) (err error) <span class="cov3" title="4">{
        p.lock.Lock()
        defer p.lock.Unlock()

        if len(p.objects) == 0 </span><span class="cov0" title="0">{
                p.prop = prop
                return nil
        }</span>

        <span class="cov3" title="4">old := p.prop
        p.prop = prop

        oldKeys := make(map[string]struct{})
        for _, k := range old.Keys() </span><span class="cov10" title="208">{
                oldKeys[k] = struct{}{}
        }</span>

        <span class="cov3" title="4">changes := make(map[string]struct{})
        for _, k := range prop.Keys() </span><span class="cov10" title="208">{
                if _, ok := oldKeys[k]; ok </span><span class="cov10" title="208">{
                        delete(oldKeys, k)
                        if old.Get(k) == prop.Get(k) </span><span class="cov9" title="204">{
                                continue</span>
                        }
                }
                <span class="cov3" title="4">changes[k] = struct{}{}</span>
        }
        <span class="cov3" title="4">for k := range oldKeys </span><span class="cov0" title="0">{
                changes[k] = struct{}{}
        }</span>

        <span class="cov3" title="4">keys := make([]string, 0, len(changes))
        for k := range changes </span><span class="cov3" title="4">{
                keys = append(keys, k)
        }</span>
        <span class="cov3" title="4">sort.Strings(keys)
        return p.refreshKeys(keys)</span>
}

// refreshKeys refreshes objects bound by the specified keys.
func (p *Properties) refreshKeys(keys []string) (err error) <span class="cov3" title="4">{
        updateIndexes := make(map[int]*refreshObject)
        for _, key := range keys </span><span class="cov3" title="4">{
                for index, o := range p.objects </span><span class="cov3" title="4">{
                        s := strings.TrimPrefix(key, o.param.Key)
                        if len(s) == len(key) </span><span class="cov0" title="0">{ // Check if the key starts with the parameter key.
                                continue</span>
                        }
                        <span class="cov3" title="4">if len(s) == 0 || s[0] == '.' || s[0] == '[' </span><span class="cov3" title="4">{
                                if _, ok := updateIndexes[index]; !ok </span><span class="cov3" title="4">{
                                        updateIndexes[index] = o
                                }</span>
                        }
                }
        }

        // Sort and collect objects that need updating.
        <span class="cov3" title="4">updateObjects := make([]*refreshObject, 0, len(updateIndexes))
        </span><span class="cov3" title="4">{
                ints := make([]int, 0, len(updateIndexes))
                for k := range updateIndexes </span><span class="cov3" title="4">{
                        ints = append(ints, k)
                }</span>
                <span class="cov3" title="4">sort.Ints(ints)
                for _, k := range ints </span><span class="cov3" title="4">{
                        updateObjects = append(updateObjects, updateIndexes[k])
                }</span>
        }

        <span class="cov3" title="4">if len(updateObjects) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov3" title="4">return p.refreshObjects(updateObjects)</span>
}

// Errors represents a collection of errors.
type Errors struct {
        arr []error
}

// Len returns the number of errors.
func (e *Errors) Len() int <span class="cov3" title="4">{
        return len(e.arr)
}</span>

// Append adds an error to the collection if it is non-nil.
func (e *Errors) Append(err error) <span class="cov3" title="4">{
        if err != nil </span><span class="cov0" title="0">{
                e.arr = append(e.arr, err)
        }</span>
}

// Error concatenates all errors into a single string.
func (e *Errors) Error() string <span class="cov0" title="0">{
        var sb strings.Builder
        for i, err := range e.arr </span><span class="cov0" title="0">{
                sb.WriteString(err.Error())
                if i &lt; len(e.arr)-1 </span><span class="cov0" title="0">{
                        sb.WriteString("; ")
                }</span>
        }
        <span class="cov0" title="0">return sb.String()</span>
}

// refreshObjects refreshes all provided objects and aggregates errors.
func (p *Properties) refreshObjects(objects []*refreshObject) error <span class="cov3" title="4">{
        ret := &amp;Errors{}
        for _, obj := range objects </span><span class="cov3" title="4">{
                err := obj.target.onRefresh(p.prop, obj.param)
                ret.Append(err)
        }</span>
        <span class="cov3" title="4">if ret.Len() == 0 </span><span class="cov3" title="4">{
                return nil
        }</span>
        <span class="cov0" title="0">return ret</span>
}

// filter is used to selectively refresh objects and fields.
type filter struct {
        *Properties
}

// Do attempts to refresh a single object if it implements the [refreshable] interface.
func (f *filter) Do(i interface{}, param conf.BindParam) (bool, error) <span class="cov3" title="4">{
        v, ok := i.(refreshable)
        if !ok </span><span class="cov2" title="3">{
                return false, nil
        }</span>
        <span class="cov1" title="1">f.objects = append(f.objects, &amp;refreshObject{
                target: v,
                param:  param,
        })
        return true, v.onRefresh(f.prop, param)</span>
}

// RefreshField refreshes a field of a bean, optionally registering it as refreshable.
func (p *Properties) RefreshField(v reflect.Value, param conf.BindParam) error <span class="cov3" title="4">{
        p.lock.Lock()
        defer p.lock.Unlock()
        f := &amp;filter{Properties: p}
        if v.Kind() == reflect.Ptr </span><span class="cov3" title="4">{
                ok, err := f.Do(v.Interface(), param)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="4">if ok </span><span class="cov1" title="1">{
                        return nil
                }</span>
        }
        <span class="cov2" title="3">return conf.BindValue(p.prop, v.Elem(), v.Elem().Type(), param, f)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_util

import (
        "container/list"
        "errors"
)

// GetBeforeItems is a function type that returns a list of items
// that must appear before the given current item in the sorting order.
type GetBeforeItems func(sorting *list.List, current interface{}) *list.List

// TripleSort performs a three-way sort (processing, toSort, sorted)
// to resolve dependencies and return a sorted list.
// The input `sorting` is a list of all items to be sorted, and `fn` determines dependencies.
func TripleSort(sorting *list.List, fn GetBeforeItems) (*list.List, error) <span class="cov4" title="2">{
        toSort := list.New()     // List of items that still need to be sorted.
        sorted := list.New()     // List of items that have been fully sorted.
        processing := list.New() // List of items currently being processed.

        // Initialize the toSort list with all elements from the input sorting list.
        toSort.PushBackList(sorting)

        // Process items in the toSort list until all items are sorted.
        for toSort.Len() &gt; 0 </span><span class="cov6" title="3">{
                // Recursively sort the dependency chain starting with the next item in `toSort`.
                err := tripleSortByAfter(sorting, toSort, sorted, processing, nil, fn)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov4" title="2">return sorted, nil</span>
}

// searchInList searches for an element `v` in the list `l`.
// If the element exists, it returns a pointer to the list element. Otherwise, it returns nil.
func searchInList(l *list.List, v interface{}) *list.Element <span class="cov10" title="6">{
        for e := l.Front(); e != nil; e = e.Next() </span><span class="cov10" title="6">{
                if e.Value == v </span><span class="cov6" title="3">{
                        return e
                }</span>
        }
        <span class="cov6" title="3">return nil</span>
}

// tripleSortByAfter recursively processes an item's dependency chain and adds it to the sorted list.
// Parameters:
// - sorting: The original list of items.
// - toSort: The list of items to be sorted.
// - sorted: The list of items that have been sorted.
// - processing: The list of items currently being processed (to detect cycles).
// - current: The current item being processed (nil for the first item).
// - fn: A function that retrieves the list of items that must appear before the current item.
func tripleSortByAfter(sorting *list.List, toSort *list.List, sorted *list.List,
        processing *list.List, current interface{}, fn GetBeforeItems) error <span class="cov6" title="3">{

        // If no current item is specified, remove and process the first item in the `toSort` list.
        if current == nil </span><span class="cov6" title="3">{
                current = toSort.Remove(toSort.Front())
        }</span>

        // Retrieve dependencies for the current item.
        <span class="cov6" title="3">l := fn(sorting, current)

        // Add the current item to the processing list to mark it as being processed.
        processing.PushBack(current)

        // Process dependencies for the current item.
        for e := l.Front(); e != nil; e = e.Next() </span><span class="cov0" title="0">{
                c := e.Value

                // Detect circular dependencies by checking if `c` is already being processed.
                if searchInList(processing, c) != nil </span><span class="cov0" title="0">{
                        return errors.New("found sorting cycle") // todo: more details
                }</span>

                // Check if the dependency `c` is already sorted or still in the toSort list.
                <span class="cov0" title="0">inSorted := searchInList(sorted, c) != nil
                inToSort := searchInList(toSort, c) != nil

                // If the dependency is not sorted but still needs sorting, process it recursively.
                if !inSorted &amp;&amp; inToSort </span><span class="cov0" title="0">{
                        err := tripleSortByAfter(sorting, toSort, sorted, processing, c, fn)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // Remove the current item from the processing list.
        <span class="cov6" title="3">if e := searchInList(processing, current); e != nil </span><span class="cov6" title="3">{
                processing.Remove(e)
        }</span>

        // Remove the current item from the toSort list (if it is still there).
        <span class="cov6" title="3">if e := searchInList(toSort, current); e != nil </span><span class="cov0" title="0">{
                toSort.Remove(e)
        }</span>

        // Add the current item to the sorted list to mark it as fully processed.
        <span class="cov6" title="3">sorted.PushBack(current)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs

import (
        "net/http"
        "net/http/pprof"
)

func init() <span class="cov8" title="1">{
        Provide(
                NewSimplePProfServer,
                TagArg("${pprof.server.addr:=0.0.0.0:9981}"),
        ).Condition(
                OnProperty(EnableServersProp).HavingValue("true").MatchIfMissing(),
                OnProperty(EnableSimplePProfServerProp).HavingValue("true").MatchIfMissing(),
        ).AsServer()
}</span>

// SimplePProfServer is a simple pprof server.
type SimplePProfServer struct {
        *SimpleHttpServer
}

// NewSimplePProfServer creates a new SimplePProfServer.
func NewSimplePProfServer(addr string) *SimplePProfServer <span class="cov8" title="1">{
        mux := http.NewServeMux()
        mux.HandleFunc("GET /debug/pprof/", pprof.Index)
        mux.HandleFunc("GET /debug/pprof/cmdline", pprof.Cmdline)
        mux.HandleFunc("GET /debug/pprof/profile", pprof.Profile)
        mux.HandleFunc("GET /debug/pprof/symbol", pprof.Symbol)
        mux.HandleFunc("GET /debug/pprof/trace", pprof.Trace)
        return &amp;SimplePProfServer{
                SimpleHttpServer: NewSimpleHttpServer(mux, SetHttpServerAddr(addr)),
        }
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs

import (
        "strconv"

        "github.com/go-spring/spring-core/util/sysconf"
        "github.com/go-spring/spring-core/util/syslog"
)

const (
        AllowCircularReferencesProp = "spring.allow-circular-references"
        ForceAutowireIsNullableProp = "spring.force-autowire-is-nullable"
        ActiveProfilesProp          = "spring.profiles.active"
        EnableJobsProp              = "spring.app.enable-jobs"
        EnableServersProp           = "spring.app.enable-servers"
        EnableSimpleHttpServerProp  = "spring.enable.simple-http-server"
        EnableSimplePProfServerProp = "spring.enable.simple-pprof-server"
        EnableDefaultServeMuxProp   = "spring.enable.default-serve-mux"
)

func setProperty(key string, val string) <span class="cov10" title="2">{
        if err := sysconf.Set(key, val); err != nil </span><span class="cov0" title="0">{
                syslog.Errorf("failed to set %s: %v", key, err)
        }</span>
}

// AllowCircularReferences enables or disables circular references between beans.
func AllowCircularReferences(enable bool) <span class="cov0" title="0">{
        setProperty(AllowCircularReferencesProp, strconv.FormatBool(enable))
}</span>

// ForceAutowireIsNullable forces autowire to be nullable.
func ForceAutowireIsNullable(enable bool) <span class="cov0" title="0">{
        setProperty(ForceAutowireIsNullableProp, strconv.FormatBool(enable))
}</span>

// SetActiveProfiles sets the active profiles for the app.
func SetActiveProfiles(profiles string) <span class="cov1" title="1">{
        setProperty(ActiveProfilesProp, profiles)
}</span>

// EnableJobs enables or disables the app jobs.
func EnableJobs(enable bool) <span class="cov0" title="0">{
        setProperty(EnableJobsProp, strconv.FormatBool(enable))
}</span>

// EnableServers enables or disables the app servers.
func EnableServers(enable bool) <span class="cov0" title="0">{
        setProperty(EnableServersProp, strconv.FormatBool(enable))
}</span>

// EnableSimpleHttpServer enables or disables the simple HTTP server.
func EnableSimpleHttpServer(enable bool) <span class="cov0" title="0">{
        setProperty(EnableSimpleHttpServerProp, strconv.FormatBool(enable))
}</span>

// EnableSimplePProfServer enables or disables the simple pprof server.
func EnableSimplePProfServer(enable bool) <span class="cov1" title="1">{
        setProperty(EnableSimplePProfServerProp, strconv.FormatBool(enable))
}</span>

// EnableDefaultServeMux enables or disables the default serve mux.
func EnableDefaultServeMux(enable bool) <span class="cov0" title="0">{
        setProperty(EnableDefaultServeMuxProp, strconv.FormatBool(enable))
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package errutil

import (
        "fmt"
)

// LineBreak defines the separator used between errors with hierarchical relationships.
var LineBreak = " &lt;&lt; "

// WrapError wraps an existing error, creating a new error with hierarchical relationships.
func WrapError(err error, format string, args ...interface{}) error <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, args...)
        return fmt.Errorf("%s%s%w", msg, LineBreak, err)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package util

import (
        "fmt"
        "reflect"

        "github.com/spf13/cast"
)

// FlattenMap flattens a nested map, array, or slice into a single-level map
// with string keys and string values. It recursively processes each element
// of the input map and adds its flattened representation to the result map.
func FlattenMap(m map[string]interface{}) map[string]string <span class="cov6" title="10">{
        result := make(map[string]string)
        for key, val := range m </span><span class="cov10" title="45">{
                FlattenValue(key, val, result)
        }</span>
        <span class="cov6" title="10">return result</span>
}

// FlattenValue flattens a single value (which can be a map, array, slice,
// or other types) into the result map.
func FlattenValue(key string, val interface{}, result map[string]string) <span class="cov10" title="45">{
        if val == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="45">switch v := reflect.ValueOf(val); v.Kind() </span>{
        case reflect.Map:<span class="cov0" title="0">
                if v.Len() == 0 </span><span class="cov0" title="0">{
                        result[key] = ""
                        return
                }</span>
                <span class="cov0" title="0">for _, k := range v.MapKeys() </span><span class="cov0" title="0">{
                        mapKey := cast.ToString(k.Interface())
                        mapValue := v.MapIndex(k).Interface()
                        FlattenValue(key+"."+mapKey, mapValue, result)
                }</span>
        case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                if v.Len() == 0 </span><span class="cov0" title="0">{
                        result[key] = ""
                        return
                }</span>
                <span class="cov0" title="0">for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                        subKey := fmt.Sprintf("%s[%d]", key, i)
                        subValue := v.Index(i).Interface()
                        // If an element is nil, treat it as an empty value and assign an empty string.
                        // Note: We do not remove the nil element to avoid changing the array's size.
                        if subValue == nil </span><span class="cov0" title="0">{
                                result[subKey] = ""
                                continue</span>
                        }
                        <span class="cov0" title="0">FlattenValue(subKey, subValue, result)</span>
                }
        default:<span class="cov10" title="45">
                result[key] = cast.ToString(val)</span>
        }
}
</pre>
		
		<pre class="file" id="file42" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package goutil

import (
        "context"
        "errors"
        "runtime/debug"
        "sync"

        "github.com/go-spring/spring-core/util/syslog"
)

// OnPanic is a global callback function triggered when a panic occurs.
var OnPanic = func(r interface{}) <span class="cov0" title="0">{
        syslog.Errorf("panic: %v\n%s", r, debug.Stack())
}</span>

/********************************** go ***************************************/

// Status provides a mechanism to wait for a goroutine to finish.
type Status struct {
        wg sync.WaitGroup
}

// newStatus creates and initializes a new Status object.
func newStatus() *Status <span class="cov10" title="8">{
        s := &amp;Status{}
        s.wg.Add(1)
        return s
}</span>

// done marks the goroutine as finished.
func (s *Status) done() <span class="cov9" title="7">{
        s.wg.Done()
}</span>

// Wait waits for the goroutine to finish.
func (s *Status) Wait() <span class="cov0" title="0">{
        s.wg.Wait()
}</span>

// Go runs a goroutine safely with context support and panic recovery.
// It ensures the process does not crash due to an uncaught panic in the goroutine.
func Go(ctx context.Context, f func(ctx context.Context)) *Status <span class="cov0" title="0">{
        s := newStatus()
        go func() </span><span class="cov0" title="0">{
                defer s.done()
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                if OnPanic != nil </span><span class="cov0" title="0">{
                                        OnPanic(r)
                                }</span>
                        }
                }()
                <span class="cov0" title="0">f(ctx)</span>
        }()
        <span class="cov0" title="0">return s</span>
}

// GoFunc runs a goroutine safely with panic recovery.
// It ensures the process does not crash due to an uncaught panic in the goroutine.
func GoFunc(f func()) *Status <span class="cov10" title="8">{
        s := newStatus()
        go func() </span><span class="cov10" title="8">{
                defer s.done()
                defer func() </span><span class="cov9" title="7">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                if OnPanic != nil </span><span class="cov0" title="0">{
                                        OnPanic(r)
                                }</span>
                        }
                }()
                <span class="cov10" title="8">f()</span>
        }()
        <span class="cov10" title="8">return s</span>
}

/******************************* go with value *******************************/

// ValueStatus provides a mechanism to wait for a goroutine that returns a value and an error.
type ValueStatus[T any] struct {
        wg  sync.WaitGroup
        val T
        err error
}

// newValueStatus creates and initializes a new ValueStatus object.
func newValueStatus[T any]() *ValueStatus[T] <span class="cov0" title="0">{
        s := &amp;ValueStatus[T]{}
        s.wg.Add(1)
        return s
}</span>

// done marks the goroutine as finished.
func (s *ValueStatus[T]) done() <span class="cov0" title="0">{
        s.wg.Done()
}</span>

// Wait blocks until the goroutine finishes and returns its result and error.
func (s *ValueStatus[T]) Wait() (T, error) <span class="cov0" title="0">{
        s.wg.Wait()
        return s.val, s.err
}</span>

// GoValue runs a goroutine safely with context support and panic recovery and
// returns its result and error.
// It ensures the process does not crash due to an uncaught panic in the goroutine.
func GoValue[T any](ctx context.Context, f func(ctx context.Context) (T, error)) *ValueStatus[T] <span class="cov0" title="0">{
        s := newValueStatus[T]()
        go func() </span><span class="cov0" title="0">{
                defer s.done()
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                if OnPanic != nil </span><span class="cov0" title="0">{
                                        OnPanic(r)
                                }</span>
                                <span class="cov0" title="0">s.err = errors.New("panic occurred")</span>
                        }
                }()
                <span class="cov0" title="0">s.val, s.err = f(ctx)</span>
        }()
        <span class="cov0" title="0">return s</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package iterutil

// Times executes the function 'fn' exactly 'count' times.
func Times(count int, fn func(i int)) <span class="cov1" title="1">{
        for i := 0; i &lt; count; i++ </span><span class="cov10" title="5">{
                fn(i)
        }</span>
}

// Ranges iterates from 'start' to 'end' (exclusive) and applies 'fn' to each index.
func Ranges(start, end int, fn func(i int)) <span class="cov0" title="0">{
        if start &lt; end </span><span class="cov0" title="0">{
                stepRangesForward(start, end, 1, fn)
        }</span> else<span class="cov0" title="0"> {
                stepRangesBackward(start, end, -1, fn)
        }</span>
}

// StepRanges iterates from 'start' to 'end' using a step size and applies 'fn' to each index.
func StepRanges(start, end, step int, fn func(i int)) <span class="cov0" title="0">{
        if step &gt; 0 &amp;&amp; start &lt; end </span><span class="cov0" title="0">{
                stepRangesForward(start, end, step, fn)
        }</span> else<span class="cov0" title="0"> if step &lt; 0 &amp;&amp; start &gt; end </span><span class="cov0" title="0">{
                stepRangesBackward(start, end, step, fn)
        }</span>
}

// stepRangesForward helper function for forward step iteration.
func stepRangesForward(start, end, step int, fn func(i int)) <span class="cov0" title="0">{
        for i := start; i &lt; end; i += step </span><span class="cov0" title="0">{
                fn(i)
        }</span>
}

// stepRangesBackward helper function for backward step iteration.
func stepRangesBackward(start, end, step int, fn func(i int)) <span class="cov0" title="0">{
        for i := start; i &gt; end; i += step </span><span class="cov0" title="0">{
                fn(i)
        }</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package util

import (
        "container/list"
)

// ListOf creates a list of the given items.
func ListOf[T any](a ...T) *list.List <span class="cov0" title="0">{
        l := list.New()
        for _, i := range a </span><span class="cov0" title="0">{
                l.PushBack(i)
        }</span>
        <span class="cov0" title="0">return l</span>
}

// AllOfList returns a slice of all items in the given list.
func AllOfList[T any](l *list.List) []T <span class="cov0" title="0">{
        if l == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if l.Len() == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">ret := make([]T, 0, l.Len())
        for e := l.Front(); e != nil; e = e.Next() </span><span class="cov0" title="0">{
                ret = append(ret, e.Value.(T))
        }</span>
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package util

import (
        "cmp"
        "slices"
)

// MapKeys returns the keys of the map m.
func MapKeys[M ~map[K]V, K comparable, V any](m M) []K <span class="cov4" title="9">{
        r := make([]K, 0, len(m))
        for k := range m </span><span class="cov10" title="419">{
                r = append(r, k)
        }</span>
        <span class="cov4" title="9">return r</span>
}

// OrderedMapKeys returns the keys of the map m in sorted order.
func OrderedMapKeys[M ~map[K]V, K cmp.Ordered, V any](m M) []K <span class="cov4" title="9">{
        r := MapKeys(m)
        slices.Sort(r)
        return r
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sysconf

import (
        "sync"

        "github.com/go-spring/spring-core/conf"
)

var (
        prop = conf.New()
        lock sync.Mutex
)

// Has returns whether the key exists.
func Has(key string) bool <span class="cov0" title="0">{
        lock.Lock()
        defer lock.Unlock()
        return prop.Has(key)
}</span>

// Get returns the property of the key.
func Get(key string) string <span class="cov0" title="0">{
        lock.Lock()
        defer lock.Unlock()
        return prop.Get(key)
}</span>

// Set sets the property of the key.
func Set(key string, val string) error <span class="cov3" title="2">{
        lock.Lock()
        defer lock.Unlock()
        return prop.Set(key, val)
}</span>

// Clear clears all properties.
func Clear() <span class="cov0" title="0">{
        lock.Lock()
        defer lock.Unlock()
        prop = conf.New()
}</span>

// Clone copies all properties into another properties.
func Clone() *conf.MutableProperties <span class="cov10" title="12">{
        lock.Lock()
        defer lock.Unlock()
        p := conf.New()
        err := prop.CopyTo(p)
        _ = err // should no error
        return p
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package syslog

import (
        "context"
        "fmt"
        "log"
        "log/slog"
        "os"
        "runtime"
        "time"
)

func init() <span class="cov1" title="1">{
        log.SetOutput(os.Stdout)
        log.SetFlags(log.Flags() | log.Lshortfile)
}</span>

// Debugf logs a debug-level message using slog.
func Debugf(format string, a ...any) <span class="cov9" title="60">{
        logMsg(slog.LevelDebug, format, a...)
}</span>

// Infof logs an info-level message using slog.
func Infof(format string, a ...any) <span class="cov2" title="2">{
        logMsg(slog.LevelInfo, format, a...)
}</span>

// Warnf logs a warning-level message using slog.
func Warnf(format string, a ...any) <span class="cov0" title="0">{
        logMsg(slog.LevelWarn, format, a...)
}</span>

// Errorf logs an error-level message using slog.
func Errorf(format string, a ...any) <span class="cov0" title="0">{
        logMsg(slog.LevelError, format, a...)
}</span>

// logMsg constructs and logs a message at the specified log level.
func logMsg(level slog.Level, format string, a ...any) <span class="cov10" title="62">{
        ctx := context.Background()
        if !slog.Default().Enabled(ctx, level) </span><span class="cov9" title="60">{
                return
        }</span>

        // skip [runtime.Callers, syslog.logMsg, syslog.*f]
        <span class="cov2" title="2">var pcs [1]uintptr
        runtime.Callers(3, pcs[:])

        msg := fmt.Sprintf(format, a...)
        r := slog.NewRecord(time.Now(), level, msg, pcs[0])
        err := slog.Default().Handler().Handle(ctx, r)
        _ = err</span> // ignore error
}
</pre>
		
		<pre class="file" id="file48" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package util

import (
        "reflect"
)

// errorType is the [reflect.Type] of the error interface.
var errorType = reflect.TypeOf((*error)(nil)).Elem()

// IsFuncType returns true if the provided type t is a function type.
func IsFuncType(t reflect.Type) bool <span class="cov5" title="6">{
        return t.Kind() == reflect.Func
}</span>

// IsErrorType returns true if the provided type t is an error type,
// either directly (error) or via an implementation (i.e., implements the error interface).
func IsErrorType(t reflect.Type) bool <span class="cov6" title="9">{
        return t == errorType || t.Implements(errorType)
}</span>

// ReturnNothing returns true if the provided function type t has no return values.
func ReturnNothing(t reflect.Type) bool <span class="cov3" title="3">{
        return t.NumOut() == 0
}</span>

// ReturnOnlyError returns true if the provided function type t returns only one value,
// and that value is an error.
func ReturnOnlyError(t reflect.Type) bool <span class="cov0" title="0">{
        return t.NumOut() == 1 &amp;&amp; IsErrorType(t.Out(0))
}</span>

// IsConstructor returns true if the provided function type t is a constructor.
// A constructor is defined as a function that returns one or two values.
// If it returns two values, the second value must be an error.
func IsConstructor(t reflect.Type) bool <span class="cov3" title="3">{
        if !IsFuncType(t) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="3">switch t.NumOut() </span>{
        case 1:<span class="cov3" title="3">
                return !IsErrorType(t.Out(0))</span>
        case 2:<span class="cov0" title="0">
                return IsErrorType(t.Out(1))</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// IsPrimitiveValueType returns true if the provided type t is a primitive value type,
// such as int, uint, float, bool, or string.
func IsPrimitiveValueType(t reflect.Type) bool <span class="cov9" title="29">{
        switch t.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov6" title="10">
                return true</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return true</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return true</span>
        case reflect.String:<span class="cov6" title="10">
                return true</span>
        case reflect.Bool:<span class="cov2" title="2">
                return true</span>
        default:<span class="cov5" title="7">
                return false</span>
        }
}

// IsPropBindingTarget returns true if the provided type t is a valid target for property binding.
// This includes primitive value types or composite types (such as array, slice, map, or struct)
// where the elements are primitive value types.
func IsPropBindingTarget(t reflect.Type) bool <span class="cov9" title="29">{
        switch t.Kind() </span>{
        case reflect.Map, reflect.Slice, reflect.Array:<span class="cov1" title="1">
                t = t.Elem()</span> // for collection types, check the element type
        default:<span class="cov9" title="28"></span>
                // do nothing
        }
        <span class="cov9" title="29">return IsPrimitiveValueType(t) || t.Kind() == reflect.Struct</span>
}

// IsBeanType returns true if the provided type t is considered a "bean" type.
// A "bean" type includes a channel, function, interface, or a pointer to a struct.
func IsBeanType(t reflect.Type) bool <span class="cov10" title="40">{
        switch t.Kind() </span>{
        case reflect.Chan, reflect.Func, reflect.Interface:<span class="cov6" title="10">
                return true</span>
        case reflect.Ptr:<span class="cov9" title="30">
                return t.Elem().Kind() == reflect.Struct</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// IsBeanInjectionTarget returns true if the provided type t is a valid target for bean injection.
// This includes maps, slices, arrays, or any other bean type (including pointers to structs).
func IsBeanInjectionTarget(t reflect.Type) bool <span class="cov7" title="15">{
        switch t.Kind() </span>{
        case reflect.Map, reflect.Slice, reflect.Array:<span class="cov0" title="0">
                t = t.Elem()</span> // for collection types, check the element type
        default:<span class="cov7" title="15"></span>
                // do nothing
        }
        <span class="cov7" title="15">return IsBeanType(t)</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package util

import (
        "reflect"
        "runtime"
        "strings"
        "unsafe"
)

const (
        flagStickyRO = 1 &lt;&lt; 5
        flagEmbedRO  = 1 &lt;&lt; 6
        flagRO       = flagStickyRO | flagEmbedRO
)

// PatchValue modifies an unexported field to make it assignable by modifying the internal flag.
// It takes a [reflect.Value] and returns the patched value that can be written to.
// This is typically used to manipulate unexported fields in struct types.
func PatchValue(v reflect.Value) reflect.Value <span class="cov10" title="15">{
        rv := reflect.ValueOf(&amp;v)
        flag := rv.Elem().FieldByName("flag")
        ptrFlag := (*uintptr)(unsafe.Pointer(flag.UnsafeAddr()))
        *ptrFlag = *ptrFlag &amp;^ flagRO
        return v
}</span>

// FuncName returns the function name for a given function.
func FuncName(fn interface{}) string <span class="cov0" title="0">{
        _, _, fnName := FileLine(fn)
        return fnName
}</span>

// FileLine returns the file, line number, and function name for a given function.
// It uses reflection and runtime information to extract these details.
// 'fn' is expected to be a function or method value.
func FileLine(fn interface{}) (file string, line int, fnName string) <span class="cov0" title="0">{

        fnPtr := reflect.ValueOf(fn).Pointer()
        fnInfo := runtime.FuncForPC(fnPtr)
        file, line = fnInfo.FileLine(fnPtr)

        s := fnInfo.Name()
        i := strings.LastIndex(s, "/")
        if i &gt; 0 </span><span class="cov0" title="0">{
                s = s[i+1:]
        }</span>

        // method values are printed as "T.m-fm"
        <span class="cov0" title="0">s = strings.TrimRight(s, "-fm")
        return file, line, s</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
