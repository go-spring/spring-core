
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bookman: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">/Users/didi/spring-core/gs/examples/bookman/main.go (85.7%)</option>
				
				<option value="file1">github.com/go-spring/spring-core/conf/bind.go (41.7%)</option>
				
				<option value="file2">github.com/go-spring/spring-core/conf/conf.go (80.0%)</option>
				
				<option value="file3">github.com/go-spring/spring-core/conf/expr.go (0.0%)</option>
				
				<option value="file4">github.com/go-spring/spring-core/conf/reader/json/json.go (0.0%)</option>
				
				<option value="file5">github.com/go-spring/spring-core/conf/reader/prop/prop.go (100.0%)</option>
				
				<option value="file6">github.com/go-spring/spring-core/conf/reader/toml/toml.go (0.0%)</option>
				
				<option value="file7">github.com/go-spring/spring-core/conf/reader/yaml/yaml.go (0.0%)</option>
				
				<option value="file8">github.com/go-spring/spring-core/conf/storage/path.go (26.8%)</option>
				
				<option value="file9">github.com/go-spring/spring-core/conf/storage/store.go (61.0%)</option>
				
				<option value="file10">github.com/go-spring/spring-core/gs/examples/bookman/app/bootstrap/bootstrap.go (85.7%)</option>
				
				<option value="file11">github.com/go-spring/spring-core/gs/examples/bookman/app/common/handlers/log/log.go (87.5%)</option>
				
				<option value="file12">github.com/go-spring/spring-core/gs/examples/bookman/app/common/httpsvr/httpsvr.go (100.0%)</option>
				
				<option value="file13">github.com/go-spring/spring-core/gs/examples/bookman/app/controller/controller-book.go (12.0%)</option>
				
				<option value="file14">github.com/go-spring/spring-core/gs/examples/bookman/app/controller/controller.go (100.0%)</option>
				
				<option value="file15">github.com/go-spring/spring-core/gs/examples/bookman/biz/job/job.go (83.3%)</option>
				
				<option value="file16">github.com/go-spring/spring-core/gs/examples/bookman/biz/service/book_service/book_service.go (40.0%)</option>
				
				<option value="file17">github.com/go-spring/spring-core/gs/examples/bookman/dao/book_dao/book_dao.go (36.4%)</option>
				
				<option value="file18">github.com/go-spring/spring-core/gs/examples/bookman/idl/proto.go (100.0%)</option>
				
				<option value="file19">github.com/go-spring/spring-core/gs/gs.go (52.4%)</option>
				
				<option value="file20">github.com/go-spring/spring-core/gs/http.go (87.5%)</option>
				
				<option value="file21">github.com/go-spring/spring-core/gs/internal/gs/gs.go (45.5%)</option>
				
				<option value="file22">github.com/go-spring/spring-core/gs/internal/gs_app/app.go (73.0%)</option>
				
				<option value="file23">github.com/go-spring/spring-core/gs/internal/gs_app/boot.go (63.6%)</option>
				
				<option value="file24">github.com/go-spring/spring-core/gs/internal/gs_app/signal.go (77.8%)</option>
				
				<option value="file25">github.com/go-spring/spring-core/gs/internal/gs_arg/arg.go (44.1%)</option>
				
				<option value="file26">github.com/go-spring/spring-core/gs/internal/gs_bean/bean.go (39.4%)</option>
				
				<option value="file27">github.com/go-spring/spring-core/gs/internal/gs_cond/cond.go (15.4%)</option>
				
				<option value="file28">github.com/go-spring/spring-core/gs/internal/gs_cond/expr.go (0.0%)</option>
				
				<option value="file29">github.com/go-spring/spring-core/gs/internal/gs_conf/arg.go (42.1%)</option>
				
				<option value="file30">github.com/go-spring/spring-core/gs/internal/gs_conf/conf.go (66.7%)</option>
				
				<option value="file31">github.com/go-spring/spring-core/gs/internal/gs_conf/env.go (80.8%)</option>
				
				<option value="file32">github.com/go-spring/spring-core/gs/internal/gs_core/bean.go (67.2%)</option>
				
				<option value="file33">github.com/go-spring/spring-core/gs/internal/gs_core/core.go (61.0%)</option>
				
				<option value="file34">github.com/go-spring/spring-core/gs/internal/gs_core/resolving/resolving.go (29.9%)</option>
				
				<option value="file35">github.com/go-spring/spring-core/gs/internal/gs_core/wiring/wiring.go (56.7%)</option>
				
				<option value="file36">github.com/go-spring/spring-core/gs/internal/gs_dync/dync.go (11.8%)</option>
				
				<option value="file37">github.com/go-spring/spring-core/gs/internal/gs_util/util.go (65.7%)</option>
				
				<option value="file38">github.com/go-spring/spring-core/gs/pprof.go (100.0%)</option>
				
				<option value="file39">github.com/go-spring/spring-core/gs/prop.go (40.0%)</option>
				
				<option value="file40">github.com/go-spring/spring-core/util/errutil/errutil.go (0.0%)</option>
				
				<option value="file41">github.com/go-spring/spring-core/util/flat.go (28.0%)</option>
				
				<option value="file42">github.com/go-spring/spring-core/util/goutil/goutil.go (27.5%)</option>
				
				<option value="file43">github.com/go-spring/spring-core/util/map.go (100.0%)</option>
				
				<option value="file44">github.com/go-spring/spring-core/util/sysconf/sysconf.go (45.0%)</option>
				
				<option value="file45">github.com/go-spring/spring-core/util/syslog/syslog.go (86.7%)</option>
				
				<option value="file46">github.com/go-spring/spring-core/util/type.go (63.0%)</option>
				
				<option value="file47">github.com/go-spring/spring-core/util/value.go (35.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
        "fmt"
        "io"
        "net/http"
        "os"
        "time"

        "github.com/go-spring/spring-core/gs"
        "github.com/go-spring/spring-core/util/syslog"

        _ "github.com/go-spring/spring-core/gs/examples/bookman/app"
        _ "github.com/go-spring/spring-core/gs/examples/bookman/biz"
        _ "github.com/go-spring/spring-core/gs/examples/bookman/idl"
)

func init() <span class="cov8" title="1">{
        gs.SetActiveProfiles("online")
        gs.EnableSimplePProfServer(true)
}</span>

func main() <span class="cov8" title="1">{
        _ = os.Unsetenv("_")
        _ = os.Unsetenv("TERM")
        _ = os.Unsetenv("TERM_SESSION_ID")
        go func() </span><span class="cov8" title="1">{
                time.Sleep(time.Millisecond * 500)
                runTest()
        }</span>()
        <span class="cov8" title="1">if err := gs.Run(); err != nil </span><span class="cov0" title="0">{
                syslog.Errorf("app run failed: %s", err.Error())
        }</span>
}

func runTest() <span class="cov8" title="1">{

        // books
        </span><span class="cov8" title="1">{
                url := "http://127.0.0.1:9090/books"
                resp, err := http.Get(url)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov8" title="1">b, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov8" title="1">defer resp.Body.Close()
                fmt.Print(string(b))</span>
        }

        <span class="cov8" title="1">gs.ShutDown()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package conf

import (
        "errors"
        "fmt"
        "reflect"
        "strconv"
        "strings"

        "github.com/go-spring/spring-core/util"
        "github.com/go-spring/spring-core/util/errutil"
)

var (
        ErrNotExist      = errors.New("not exist")
        ErrInvalidSyntax = errors.New("invalid syntax")
)

// ParsedTag a value tag includes at most three parts: required key, optional
// default value, and optional splitter, the syntax is ${key:=value}&gt;&gt;splitter.
type ParsedTag struct {
        Key      string // short property key
        Def      string // default value
        HasDef   bool   // has default value
        Splitter string // splitter's name
}

func (tag ParsedTag) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString("${")
        sb.WriteString(tag.Key)
        if tag.HasDef </span><span class="cov0" title="0">{
                sb.WriteString(":=")
                sb.WriteString(tag.Def)
        }</span>
        <span class="cov0" title="0">sb.WriteString("}")
        if tag.Splitter != "" </span><span class="cov0" title="0">{
                sb.WriteString("&gt;&gt;")
                sb.WriteString(tag.Splitter)
        }</span>
        <span class="cov0" title="0">return sb.String()</span>
}

// ParseTag parses a value tag, returns its key, and default value, and splitter.
func ParseTag(tag string) (ret ParsedTag, err error) <span class="cov4" title="19">{
        i := strings.LastIndex(tag, "&gt;&gt;")
        if i == 0 </span><span class="cov0" title="0">{
                err = fmt.Errorf("parse tag '%s' error: %w", tag, ErrInvalidSyntax)
                return
        }</span>
        <span class="cov4" title="19">j := strings.LastIndex(tag, "}")
        if j &lt;= 0 </span><span class="cov0" title="0">{
                err = fmt.Errorf("parse tag '%s' error: %w", tag, ErrInvalidSyntax)
                return
        }</span>
        <span class="cov4" title="19">k := strings.Index(tag, "${")
        if k &lt; 0 </span><span class="cov0" title="0">{
                err = fmt.Errorf("parse tag '%s' error: %w", tag, ErrInvalidSyntax)
                return
        }</span>
        <span class="cov4" title="19">if i &gt; j </span><span class="cov0" title="0">{
                ret.Splitter = strings.TrimSpace(tag[i+2:])
        }</span>
        <span class="cov4" title="19">ss := strings.SplitN(tag[k+2:j], ":=", 2)
        ret.Key = ss[0]
        if len(ss) &gt; 1 </span><span class="cov4" title="12">{
                ret.HasDef = true
                ret.Def = ss[1]
        }</span>
        <span class="cov4" title="19">return</span>
}

type BindParam struct {
        Key      string            // full key
        Path     string            // full path
        Tag      ParsedTag         // parsed tag
        Validate reflect.StructTag // full field tag
}

func (param *BindParam) BindTag(tag string, validate reflect.StructTag) error <span class="cov4" title="19">{
        param.Validate = validate
        parsedTag, err := ParseTag(tag)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="19">if parsedTag.Key == "" </span><span class="cov0" title="0">{ // ${:=} 默认值语法
                if parsedTag.HasDef </span><span class="cov0" title="0">{
                        param.Tag = parsedTag
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("xxxx")</span> // todo
        }
        <span class="cov4" title="19">if parsedTag.Key == "ROOT" </span><span class="cov0" title="0">{
                parsedTag.Key = ""
        }</span>
        <span class="cov4" title="19">if param.Key == "" </span><span class="cov4" title="13">{
                param.Key = parsedTag.Key
        }</span> else<span class="cov3" title="6"> if parsedTag.Key != "" </span><span class="cov3" title="6">{
                param.Key = param.Key + "." + parsedTag.Key
        }</span>
        <span class="cov4" title="19">param.Tag = parsedTag
        return nil</span>
}

type Filter interface {
        Do(i interface{}, param BindParam) (bool, error)
}

// BindValue binds properties to a value.
func BindValue(p ReadOnlyProperties, v reflect.Value, t reflect.Type, param BindParam, filter Filter) (RetErr error) <span class="cov4" title="12">{

        if !util.IsPropBindingTarget(t) </span><span class="cov0" title="0">{
                err := errors.New("target should be value type")
                return fmt.Errorf("bind path=%s type=%s error: %w", param.Path, v.Type().String(), err)
        }</span>

        <span class="cov4" title="12">defer func() </span><span class="cov4" title="12">{
                if RetErr == nil </span><span class="cov4" title="12">{
                        tag, ok := param.Validate.Lookup("expr")
                        if ok &amp;&amp; len(tag) &gt; 0 </span><span class="cov0" title="0">{
                                err := validateField(tag, v.Interface())
                                if err != nil </span><span class="cov0" title="0">{
                                        RetErr = err
                                }</span>
                        }
                }
        }()

        <span class="cov4" title="12">switch v.Kind() </span>{
        case reflect.Map:<span class="cov1" title="1">
                return bindMap(p, v, t, param, filter)</span>
        case reflect.Slice:<span class="cov0" title="0">
                return bindSlice(p, v, t, param, filter)</span>
        case reflect.Array:<span class="cov0" title="0">
                err := errors.New("use slice instead of array")
                return fmt.Errorf("bind path=%s type=%s error: %w", param.Path, v.Type().String(), err)</span>
        default:<span class="cov4" title="11"></span> // for linter
        }

        <span class="cov4" title="11">fn := converters[t]
        if fn == nil &amp;&amp; v.Kind() == reflect.Struct </span><span class="cov2" title="3">{
                if err := bindStruct(p, v, t, param, filter); err != nil </span><span class="cov0" title="0">{
                        return err // no wrap
                }</span>
                <span class="cov2" title="3">return nil</span>
        }

        <span class="cov3" title="8">val, err := resolve(p, param)
        if err != nil </span><span class="cov0" title="0">{
                return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())
        }</span>

        <span class="cov3" title="8">if fn != nil </span><span class="cov0" title="0">{
                fnValue := reflect.ValueOf(fn)
                out := fnValue.Call([]reflect.Value{reflect.ValueOf(val)})
                if !out[1].IsNil() </span><span class="cov0" title="0">{
                        err = out[1].Interface().(error)
                        return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())
                }</span>
                <span class="cov0" title="0">v.Set(out[0])
                return nil</span>
        }

        <span class="cov3" title="8">switch v.Kind() </span>{
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                var u uint64
                if u, err = strconv.ParseUint(val, 0, 0); err == nil </span><span class="cov0" title="0">{
                        v.SetUint(u)
                        return nil
                }</span>
                <span class="cov0" title="0">return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                var i int64
                if i, err = strconv.ParseInt(val, 0, 0); err == nil </span><span class="cov0" title="0">{
                        v.SetInt(i)
                        return nil
                }</span>
                <span class="cov0" title="0">return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                var f float64
                if f, err = strconv.ParseFloat(val, 64); err == nil </span><span class="cov0" title="0">{
                        v.SetFloat(f)
                        return nil
                }</span>
                <span class="cov0" title="0">return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())</span>
        case reflect.Bool:<span class="cov0" title="0">
                var b bool
                if b, err = strconv.ParseBool(val); err == nil </span><span class="cov0" title="0">{
                        v.SetBool(b)
                        return nil
                }</span>
                <span class="cov0" title="0">return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())</span>
        case reflect.String:<span class="cov3" title="8">
                v.SetString(val)
                return nil</span>
        default:<span class="cov0" title="0"></span> // for linter
        }

        <span class="cov0" title="0">err = errors.New("unsupported bind type")
        return fmt.Errorf("bind path=%s type=%s error: %w", param.Path, v.Type().String(), err)</span>
}

// bindSlice binds properties to a slice value.
func bindSlice(p ReadOnlyProperties, v reflect.Value, t reflect.Type, param BindParam, filter Filter) error <span class="cov0" title="0">{

        et := t.Elem()
        p, err := getSlice(p, et, param)
        if err != nil </span><span class="cov0" title="0">{
                return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())
        }</span>

        <span class="cov0" title="0">slice := reflect.MakeSlice(t, 0, 0)
        defer func() </span><span class="cov0" title="0">{ v.Set(slice) }</span>()

        <span class="cov0" title="0">if p == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for i := 0; ; i++ </span><span class="cov0" title="0">{
                e := reflect.New(et).Elem()
                subParam := BindParam{
                        Key:  fmt.Sprintf("%s[%d]", param.Key, i),
                        Path: fmt.Sprintf("%s[%d]", param.Path, i),
                }
                err = BindValue(p, e, et, subParam, filter)
                if errors.Is(err, ErrNotExist) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())
                }</span>
                <span class="cov0" title="0">slice = reflect.Append(slice, e)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func getSlice(p ReadOnlyProperties, et reflect.Type, param BindParam) (ReadOnlyProperties, error) <span class="cov0" title="0">{

        // properties that defined as list.
        if p.Has(param.Key + "[0]") </span><span class="cov0" title="0">{
                return p, nil
        }</span>

        // properties that defined as string and needs to split into []string.
        <span class="cov0" title="0">var strVal string
        </span><span class="cov0" title="0">{
                if p.Has(param.Key) </span><span class="cov0" title="0">{
                        strVal = p.Get(param.Key)
                }</span> else<span class="cov0" title="0"> {
                        if !param.Tag.HasDef </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("property %q %w", param.Key, ErrNotExist)
                        }</span>
                        <span class="cov0" title="0">if param.Tag.Def == "" </span><span class="cov0" title="0">{
                                return nil, nil
                        }</span>
                        <span class="cov0" title="0">if !util.IsPrimitiveValueType(et) &amp;&amp; converters[et] == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("can't find converter for %s", et.String())
                        }</span>
                        <span class="cov0" title="0">strVal = param.Tag.Def</span>
                }
        }
        <span class="cov0" title="0">if strVal == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">var (
                err    error
                arrVal []string
        )

        if s := param.Tag.Splitter; s == "" </span><span class="cov0" title="0">{
                arrVal = strings.Split(strVal, ",")
                for i := range arrVal </span><span class="cov0" title="0">{
                        arrVal[i] = strings.TrimSpace(arrVal[i])
                }</span>
        } else<span class="cov0" title="0"> if fn, ok := splitters[s]; ok &amp;&amp; fn != nil </span><span class="cov0" title="0">{
                if arrVal, err = fn(strVal); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("split error: %w, value: %q", err, strVal)
                }</span>
        } else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("unknown splitter %q", s)
        }</span>

        <span class="cov0" title="0">r := New()
        for i, s := range arrVal </span><span class="cov0" title="0">{
                k := fmt.Sprintf("%s[%d]", param.Key, i)
                if err = r.storage.Set(k, s); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return r, nil</span>
}

// bindMap binds properties to a map value.
func bindMap(p ReadOnlyProperties, v reflect.Value, t reflect.Type, param BindParam, filter Filter) error <span class="cov1" title="1">{

        if param.Tag.HasDef &amp;&amp; param.Tag.Def != "" </span><span class="cov0" title="0">{
                err := errors.New("map can't have a non-empty default value")
                return fmt.Errorf("bind path=%s type=%s error: %w", param.Path, v.Type().String(), err)
        }</span>

        <span class="cov1" title="1">et := t.Elem()
        ret := reflect.MakeMap(t)
        defer func() </span><span class="cov1" title="1">{ v.Set(ret) }</span>()

        // 当成默认值处理
        <span class="cov1" title="1">if param.Tag.Key == "" </span><span class="cov0" title="0">{
                if param.Tag.HasDef </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov1" title="1">keys, err := p.SubKeys(param.Key)
        if err != nil </span><span class="cov0" title="0">{
                return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())
        }</span>

        <span class="cov1" title="1">for _, key := range keys </span><span class="cov2" title="3">{
                e := reflect.New(et).Elem()
                subKey := key
                if param.Key != "" </span><span class="cov2" title="3">{
                        subKey = param.Key + "." + key
                }</span>
                <span class="cov2" title="3">subParam := BindParam{
                        Key:  subKey,
                        Path: param.Path,
                }
                if err = BindValue(p, e, et, subParam, filter); err != nil </span><span class="cov0" title="0">{
                        return err // no wrap
                }</span>
                <span class="cov2" title="3">ret.SetMapIndex(reflect.ValueOf(key), e)</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// bindStruct binds properties to a struct value.
func bindStruct(p ReadOnlyProperties, v reflect.Value, t reflect.Type, param BindParam, filter Filter) error <span class="cov2" title="3">{

        if param.Tag.HasDef &amp;&amp; param.Tag.Def != "" </span><span class="cov0" title="0">{
                err := errors.New("struct can't have a non-empty default value")
                return fmt.Errorf("bind path=%s type=%s error: %w", param.Path, v.Type().String(), err)
        }</span>

        <span class="cov2" title="3">for i := 0; i &lt; t.NumField(); i++ </span><span class="cov3" title="6">{
                ft := t.Field(i)
                fv := v.Field(i)

                if !fv.CanInterface() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov3" title="6">subParam := BindParam{
                        Key:  param.Key,
                        Path: param.Path + "." + ft.Name,
                }

                if tag, ok := ft.Tag.Lookup("value"); ok </span><span class="cov3" title="6">{
                        if err := subParam.BindTag(tag, ft.Tag); err != nil </span><span class="cov0" title="0">{
                                return errutil.WrapError(err, "bind path=%s type=%s error", param.Path, v.Type().String())
                        }</span>
                        <span class="cov3" title="6">if filter != nil </span><span class="cov0" title="0">{
                                ret, err := filter.Do(fv.Addr().Interface(), subParam)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if ret </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                        <span class="cov3" title="6">if err := BindValue(p, fv, ft.Type, subParam, filter); err != nil </span><span class="cov0" title="0">{
                                return err // no wrap
                        }</span>
                        <span class="cov3" title="6">continue</span>
                }

                <span class="cov0" title="0">if ft.Anonymous </span><span class="cov0" title="0">{
                        // embed pointer type may lead to infinite recursion.
                        if ft.Type.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if err := bindStruct(p, fv, ft.Type, subParam, filter); err != nil </span><span class="cov0" title="0">{
                                return err // no wrap
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
        }
        <span class="cov2" title="3">return nil</span>
}

// resolve returns property references processed property value.
func resolve(p ReadOnlyProperties, param BindParam) (string, error) <span class="cov4" title="18">{
        const defVal = "@@def@@"
        val := p.Get(param.Key, defVal)
        if val != defVal </span><span class="cov4" title="10">{
                return resolveString(p, val)
        }</span>
        <span class="cov3" title="8">if p.Has(param.Key) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("property key=%s isn't simple value", param.Key)
        }</span>
        <span class="cov3" title="8">if param.Tag.HasDef </span><span class="cov3" title="8">{
                return resolveString(p, param.Tag.Def)
        }</span>
        <span class="cov0" title="0">return "", fmt.Errorf("property key=%s %w", param.Key, ErrNotExist)</span>
}

// resolveString returns property references processed string.
func resolveString(p ReadOnlyProperties, s string) (string, error) <span class="cov6" title="62">{

        var (
                length = len(s)
                count  = 0
                start  = -1
                end    = -1
        )

        for i := 0; i &lt; length; i++ </span><span class="cov10" title="942">{
                if s[i] == '$' </span><span class="cov4" title="10">{
                        if i &lt; length-1 &amp;&amp; s[i+1] == '{' </span><span class="cov4" title="10">{
                                if count == 0 </span><span class="cov4" title="10">{
                                        start = i
                                }</span>
                                <span class="cov4" title="10">count++</span>
                        }
                } else<span class="cov9" title="932"> if s[i] == '}' </span><span class="cov4" title="10">{
                        if count &gt; 0 </span><span class="cov4" title="10">{
                                count--
                                if count == 0 </span><span class="cov4" title="10">{
                                        end = i
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov6" title="62">if start &lt; 0 </span><span class="cov6" title="52">{
                return s, nil
        }</span>

        <span class="cov4" title="10">if end &lt; 0 || count &gt; 0 </span><span class="cov0" title="0">{
                err := ErrInvalidSyntax
                return "", fmt.Errorf("resolve string %q error: %w", s, err)
        }</span>

        <span class="cov4" title="10">var param BindParam
        _ = param.BindTag(s[start:end+1], "")

        s1, err := resolve(p, param)
        if err != nil </span><span class="cov0" title="0">{
                return "", errutil.WrapError(err, "resolve string %q error", s)
        }</span>

        <span class="cov4" title="10">s2, err := resolveString(p, s[end+1:])
        if err != nil </span><span class="cov0" title="0">{
                return "", errutil.WrapError(err, "resolve string %q error", s)
        }</span>

        <span class="cov4" title="10">return s[:start] + s1 + s2, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package conf

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "reflect"
        "strings"
        "time"

        "github.com/go-spring/spring-core/conf/reader/json"
        "github.com/go-spring/spring-core/conf/reader/prop"
        "github.com/go-spring/spring-core/conf/reader/toml"
        "github.com/go-spring/spring-core/conf/reader/yaml"
        "github.com/go-spring/spring-core/conf/storage"
        "github.com/go-spring/spring-core/util"
        "github.com/spf13/cast"
)

var (
        readers    = map[string]Reader{}
        splitters  = map[string]Splitter{}
        converters = map[reflect.Type]interface{}{}
)

func init() <span class="cov1" title="1">{

        RegisterReader(json.Read, ".json")
        RegisterReader(prop.Read, ".properties")
        RegisterReader(yaml.Read, ".yaml", ".yml")
        RegisterReader(toml.Read, ".toml", ".tml")

        RegisterConverter(func(s string) (time.Time, error) </span><span class="cov0" title="0">{
                return cast.ToTimeE(strings.TrimSpace(s))
        }</span>)

        <span class="cov1" title="1">RegisterConverter(func(s string) (time.Duration, error) </span><span class="cov0" title="0">{
                return time.ParseDuration(strings.TrimSpace(s))
        }</span>)
}

// Reader parses []byte into nested map[string]interface{}.
type Reader func(b []byte) (map[string]interface{}, error)

// RegisterReader registers its Reader for some kind of file extension.
func RegisterReader(r Reader, ext ...string) <span class="cov3" title="4">{
        for _, s := range ext </span><span class="cov4" title="6">{
                readers[s] = r
        }</span>
}

// Splitter splits string into []string by some characters.
type Splitter func(string) ([]string, error)

// RegisterSplitter registers a Splitter and named it.
func RegisterSplitter(name string, fn Splitter) <span class="cov0" title="0">{
        splitters[name] = fn
}</span>

// Converter converts string value into user-defined value. It should be function
// type, and its prototype is func(string)(type,error).
type Converter[T any] func(string) (T, error)

// RegisterConverter registers its converter for non-primitive type such as
// time.Time, time.Duration, or other user-defined value type.
func RegisterConverter[T any](fn Converter[T]) <span class="cov2" title="2">{
        t := reflect.TypeOf(fn)
        converters[t.Out(0)] = fn
}</span>

// ReadOnlyProperties is the interface for read-only properties.
type ReadOnlyProperties interface {
        // Data returns key-value pairs of the properties.
        Data() map[string]string
        // Keys returns keys of the properties.
        Keys() []string
        // Has returns whether the key exists.
        Has(key string) bool
        // SubKeys returns the sorted sub keys of the key.
        SubKeys(key string) ([]string, error)
        // Get returns key's value.
        Get(key string, def ...string) string
        // Resolve resolves string that contains references.
        Resolve(s string) (string, error)
        // Bind binds properties into a value.
        Bind(i interface{}, tag ...string) error
        // CopyTo copies properties into another by override.
        CopyTo(out *Properties) error
}

var _ ReadOnlyProperties = (*Properties)(nil)

// Properties stores the data with map[string]string and the keys are case-sensitive,
// you can get one of them by its key, or bind some of them to a value.
// There are too many formats of configuration files, and too many conflicts between
// them. Each format of configuration file provides its special characteristics, but
// usually they are not all necessary, and complementary. For example, `conf` disabled
// Java properties' expansion when reading file, but also provides similar function
// when getting or binding properties.
// A good rule of thumb is that treating application configuration as a tree, but not
// all formats of configuration files designed as a tree or not ideal, for instance
// Java properties isn't strictly verified. Although configuration can store as a tree,
// but it costs more CPU time when getting properties because it reads property node
// by node. So `conf` uses a tree to strictly verify and a flat map to store.
type Properties struct {
        storage *storage.Storage
}

// New creates empty *Properties.
func New() *Properties <span class="cov7" title="31">{
        return &amp;Properties{
                storage: storage.NewStorage(),
        }
}</span>

// Map creates *Properties from map.
func Map(m map[string]interface{}) (*Properties, error) <span class="cov0" title="0">{
        p := New()
        if err := p.Merge(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return p, nil</span>
}

// Load creates *Properties from file.
func Load(file string) (*Properties, error) <span class="cov6" title="24">{
        p := New()
        if err := p.Load(file); err != nil </span><span class="cov6" title="23">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return p, nil</span>
}

// Load loads properties from file.
func (p *Properties) Load(file string) error <span class="cov6" title="24">{
        b, err := os.ReadFile(file)
        if err != nil </span><span class="cov6" title="23">{
                return err
        }</span>
        <span class="cov1" title="1">return p.Bytes(b, filepath.Ext(file))</span>
}

// Bytes loads properties from []byte, ext is the file name extension.
func (p *Properties) Bytes(b []byte, ext string) error <span class="cov1" title="1">{
        r, ok := readers[ext]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported file type %q", ext)
        }</span>
        <span class="cov1" title="1">m, err := r(b)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return p.Merge(m)</span>
}

// Merge flattens the map and sets all keys and values.
func (p *Properties) Merge(m map[string]interface{}) error <span class="cov1" title="1">{
        s := util.FlattenMap(m)
        return p.merge(s)
}</span>

func (p *Properties) merge(m map[string]string) error <span class="cov9" title="156">{
        for key, val := range m </span><span class="cov10" title="172">{
                if err := p.storage.Set(key, val); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov9" title="156">return nil</span>
}

func (p *Properties) Data() map[string]string <span class="cov0" title="0">{
        return p.storage.Data()
}</span>

// Keys returns all sorted keys.
func (p *Properties) Keys() []string <span class="cov0" title="0">{
        return p.storage.Keys()
}</span>

// Has returns whether key exists.
func (p *Properties) Has(key string) bool <span class="cov5" title="10">{
        return p.storage.Has(key)
}</span>

// SubKeys returns the sorted sub keys of the key.
func (p *Properties) SubKeys(key string) ([]string, error) <span class="cov1" title="1">{
        return p.storage.SubKeys(key)
}</span>

// Get returns key's value, using Def to return a default value.
func (p *Properties) Get(key string, def ...string) string <span class="cov6" title="24">{
        val, ok := p.storage.Get(key)
        if !ok &amp;&amp; len(def) &gt; 0 </span><span class="cov4" title="8">{
                return def[0]
        }</span>
        <span class="cov5" title="16">return val</span>
}

// Set sets key's value to be a primitive type as int or string,
// or a slice or map nested with primitive type elements. One thing
// you should know is Set actions as overlap but not replace, that
// means when you set a slice or a map, an existing path will remain
// when it doesn't exist in the slice or map even they share a same
// prefix path.
func (p *Properties) Set(key string, val interface{}) error <span class="cov9" title="150">{
        if key == "" </span><span class="cov0" title="0">{
                return errors.New("key is empty")
        }</span>
        <span class="cov9" title="150">m := make(map[string]string)
        util.FlattenValue(key, val, m)
        return p.merge(m)</span>
}

// Resolve resolves string value that contains references to other
// properties, the references are defined by ${key:=def}.
func (p *Properties) Resolve(s string) (string, error) <span class="cov7" title="34">{
        return resolveString(p, s)
}</span>

// Bind binds properties to a value, the bind value can be primitive type,
// map, slice, struct. When binding to struct, the tag 'value' indicates
// which properties should be bind. The 'value' tag are defined by
// value:"${a:=b}&gt;&gt;splitter", 'a' is the key, 'b' is the default value,
// 'splitter' is the Splitter's name when you want split string value
// into []string value.
func (p *Properties) Bind(i interface{}, tag ...string) error <span class="cov2" title="3">{

        var v reflect.Value
        </span><span class="cov2" title="3">{
                switch e := i.(type) </span>{
                case reflect.Value:<span class="cov2" title="2">
                        v = e</span>
                default:<span class="cov1" title="1">
                        v = reflect.ValueOf(i)
                        if v.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                                return errors.New("should be a ptr")
                        }</span>
                        <span class="cov1" title="1">v = v.Elem()</span>
                }
        }

        <span class="cov2" title="3">t := v.Type()
        typeName := t.Name()
        if typeName == "" </span><span class="cov1" title="1">{ // primitive type has no name
                typeName = t.String()
        }</span>

        <span class="cov2" title="3">s := "${ROOT}"
        if len(tag) &gt; 0 </span><span class="cov2" title="3">{
                s = tag[0]
        }</span>

        <span class="cov2" title="3">var param BindParam
        err := param.BindTag(s, "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="3">param.Path = typeName
        return BindValue(p, v, t, param, nil)</span>
}

// CopyTo copies properties into another by override.
func (p *Properties) CopyTo(out *Properties) error <span class="cov3" title="5">{
        return out.merge(p.storage.RawData())
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package conf

import (
        "fmt"

        "github.com/expr-lang/expr"
)

// ValidateFunc defines a type for validation functions, which accept
// a value of type T and return a boolean result.
type ValidateFunc[T any] func(T) bool

// validateFuncs holds a map of registered validation functions.
var validateFuncs = map[string]interface{}{}

// RegisterValidateFunc registers a validation function with a specific name.
// The function can then be used in validation expressions.
func RegisterValidateFunc[T any](name string, fn ValidateFunc[T]) <span class="cov0" title="0">{
        validateFuncs[name] = fn
}</span>

// validateField validates a field using a validation expression (tag) and the field value (i).
// It evaluates the expression and checks if the result is true (i.e., the validation passes).
// If any error occurs during evaluation or if the validation fails, an error is returned.
func validateField(tag string, i interface{}) error <span class="cov0" title="0">{
        env := map[string]interface{}{"$": i}
        for k, v := range validateFuncs </span><span class="cov0" title="0">{
                env[k] = v
        }</span>
        <span class="cov0" title="0">r, err := expr.Eval(tag, env)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("eval %q returns error, %w", tag, err)
        }</span>
        <span class="cov0" title="0">ret, ok := r.(bool)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("eval %q doesn't return bool value", tag)
        }</span>
        <span class="cov0" title="0">if !ret </span><span class="cov0" title="0">{
                return fmt.Errorf("validate failed on %q for value %v", tag, i)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package json

import (
        "encoding/json"
)

// Read parses []byte in the json format into map.
func Read(b []byte) (map[string]interface{}, error) <span class="cov0" title="0">{
        var ret map[string]interface{}
        err := json.Unmarshal(b, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package prop

import "github.com/magiconair/properties"

// Read parses []byte in the properties format into map.
func Read(b []byte) (map[string]interface{}, error) <span class="cov1" title="1">{

        p := properties.NewProperties()
        p.DisableExpansion = true
        _ = p.Load(b, properties.UTF8) // always no error

        ret := make(map[string]interface{})
        for k, v := range p.Map() </span><span class="cov10" title="7">{
                ret[k] = v
        }</span>
        <span class="cov1" title="1">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package toml

import (
        "github.com/pelletier/go-toml"
)

// Read parses []byte in the toml format into map.
func Read(b []byte) (map[string]interface{}, error) <span class="cov0" title="0">{
        tree, err := toml.LoadBytes(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tree.ToMap(), nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package yaml

import (
        "gopkg.in/yaml.v2"
)

// Read parses []byte in the yaml format into map.
func Read(b []byte) (map[string]interface{}, error) <span class="cov0" title="0">{
        m := make(map[string]interface{})
        err := yaml.Unmarshal(b, &amp;m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package storage

import (
        "fmt"
        "strconv"
        "strings"
)

type PathType int

const (
        PathTypeKey   PathType = iota // PathTypeKey is map key like a/b in a[0][1].b
        PathTypeIndex                 // PathTypeIndex is array index like 0/1 in a[0][1].b
)

type Path struct {
        Type PathType
        Elem string
}

// JoinPath joins all path elements into a single path.
func JoinPath(path []Path) string <span class="cov0" title="0">{
        var s strings.Builder
        for i, p := range path </span><span class="cov0" title="0">{
                switch p.Type </span>{
                case PathTypeKey:<span class="cov0" title="0">
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                s.WriteString(".")
                        }</span>
                        <span class="cov0" title="0">s.WriteString(p.Elem)</span>
                case PathTypeIndex:<span class="cov0" title="0">
                        s.WriteString("[")
                        s.WriteString(p.Elem)
                        s.WriteString("]")</span>
                }
        }
        <span class="cov0" title="0">return s.String()</span>
}

// SplitPath splits key into individual path elements.
func SplitPath(key string) ([]Path, error) <span class="cov7" title="182">{
        if key == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid key '%s'", key)
        }</span>
        <span class="cov7" title="182">var (
                path        []Path
                lastPos     int
                lastChar    int32
                openBracket bool
        )
        for i, c := range key </span><span class="cov10" title="2114">{
                switch c </span>{
                case ' ':<span class="cov0" title="0">
                        return nil, fmt.Errorf("invalid key '%s'", key)</span>
                case '.':<span class="cov6" title="163">
                        if openBracket </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid key '%s'", key)
                        }</span>
                        <span class="cov6" title="163">if lastChar == ']' </span><span class="cov0" title="0">{
                                lastPos = i + 1
                                lastChar = c
                                continue</span>
                        }
                        <span class="cov6" title="163">if lastPos == i </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid key '%s'", key)
                        }</span>
                        <span class="cov6" title="163">path = append(path, Path{PathTypeKey, key[lastPos:i]})
                        lastPos = i + 1
                        lastChar = c</span>
                case '[':<span class="cov0" title="0">
                        if openBracket </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid key '%s'", key)
                        }</span>
                        <span class="cov0" title="0">if i == 0 || lastChar == ']' </span><span class="cov0" title="0">{
                                lastPos = i + 1
                                openBracket = true
                                lastChar = c
                                continue</span>
                        }
                        <span class="cov0" title="0">if lastChar == '.' || lastPos == i </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid key '%s'", key)
                        }</span>
                        <span class="cov0" title="0">path = append(path, Path{PathTypeKey, key[lastPos:i]})
                        lastPos = i + 1
                        openBracket = true
                        lastChar = c</span>
                case ']':<span class="cov0" title="0">
                        if !openBracket || lastPos == i </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid key '%s'", key)
                        }</span>
                        <span class="cov0" title="0">s := key[lastPos:i]
                        _, err := strconv.ParseUint(s, 10, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid key '%s'", key)
                        }</span>
                        <span class="cov0" title="0">path = append(path, Path{PathTypeIndex, s})
                        lastPos = i + 1
                        openBracket = false
                        lastChar = c</span>
                default:<span class="cov9" title="1951">
                        lastChar = c</span>
                }
        }
        <span class="cov7" title="182">if openBracket || lastChar == '.' </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid key '%s'", key)
        }</span>
        <span class="cov7" title="182">if lastChar != ']' </span><span class="cov7" title="182">{
                path = append(path, Path{PathTypeKey, key[lastPos:]})
        }</span>
        <span class="cov7" title="182">return path, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package storage

import (
        "fmt"

        "github.com/go-spring/spring-core/util"
)

type nodeType int

const (
        nodeTypeNil nodeType = iota
        nodeTypeValue
        nodeTypeMap
        nodeTypeArray
)

type treeNode struct {
        node nodeType
        data interface{}
}

// Storage is a key-value store that verifies the format of the key.
type Storage struct {
        tree *treeNode
        data map[string]string
}

func NewStorage() *Storage <span class="cov6" title="31">{
        return &amp;Storage{
                tree: &amp;treeNode{
                        node: nodeTypeNil,
                        data: make(map[string]*treeNode),
                },
                data: make(map[string]string),
        }
}</span>

// RawData returns the raw data of the storage.
func (s *Storage) RawData() map[string]string <span class="cov3" title="5">{
        return s.data
}</span>

// Data returns the copied data of the storage.
func (s *Storage) Data() map[string]string <span class="cov0" title="0">{
        m := make(map[string]string)
        for k, v := range s.data </span><span class="cov0" title="0">{
                m[k] = v
        }</span>
        <span class="cov0" title="0">return m</span>
}

// Keys returns the sorted keys of the storage.
func (s *Storage) Keys() []string <span class="cov0" title="0">{
        return util.OrderedMapKeys(s.data)
}</span>

// SubKeys returns the sorted sub keys of the key.
func (s *Storage) SubKeys(key string) (_ []string, err error) <span class="cov1" title="1">{
        var path []Path
        if key != "" </span><span class="cov1" title="1">{
                if path, err = SplitPath(key); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov1" title="1">tree := s.tree
        for i, pathNode := range path </span><span class="cov1" title="1">{
                m := tree.data.(map[string]*treeNode)
                v, ok := m[pathNode.Elem]
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov1" title="1">switch v.node </span>{
                case nodeTypeNil:<span class="cov0" title="0">
                        return nil, nil</span>
                case nodeTypeValue:<span class="cov0" title="0">
                        return nil, fmt.Errorf("property '%s' is value", JoinPath(path[:i+1]))</span>
                case nodeTypeArray, nodeTypeMap:<span class="cov1" title="1">
                        tree = v</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("invalid node type %d", v.node)</span>
                }
        }
        <span class="cov1" title="1">m := tree.data.(map[string]*treeNode)
        keys := util.OrderedMapKeys(m)
        return keys, nil</span>
}

// Has returns whether the key exists.
func (s *Storage) Has(key string) bool <span class="cov4" title="10">{
        if key == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov4" title="10">if _, ok := s.data[key]; ok </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov4" title="9">path, err := SplitPath(key)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov4" title="9">tree := s.tree
        for i, node := range path </span><span class="cov5" title="18">{
                m := tree.data.(map[string]*treeNode)
                switch tree.node </span>{
                case nodeTypeArray:<span class="cov0" title="0">
                        if node.Type != PathTypeIndex </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case nodeTypeMap:<span class="cov4" title="9">
                        if node.Type != PathTypeKey </span><span class="cov0" title="0">{
                                return false
                        }</span>
                default:<span class="cov4" title="9"></span> // for linter
                }
                <span class="cov5" title="18">v, ok := m[node.Elem]
                if !ok </span><span class="cov4" title="9">{
                        return false
                }</span>
                <span class="cov4" title="9">if v.node == nodeTypeNil || v.node == nodeTypeValue </span><span class="cov0" title="0">{
                        return i == len(path)-1
                }</span>
                <span class="cov4" title="9">tree = v</span>
        }
        <span class="cov0" title="0">return true</span>
}

// Get returns the value of the key, and false if the key does not exist.
func (s *Storage) Get(key string) (string, bool) <span class="cov5" title="24">{
        val, ok := s.data[key]
        return val, ok
}</span>

// Set stores the value of the key.
func (s *Storage) Set(key, val string) error <span class="cov9" title="172">{
        if key == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("key is empty")
        }</span>
        <span class="cov9" title="172">tree, err := s.merge(key, val)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov9" title="172">switch tree.node </span>{
        case nodeTypeNil, nodeTypeValue:<span class="cov9" title="172">
                s.data[key] = val</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid node type %d", tree.node)</span>
        }
        <span class="cov9" title="172">return nil</span>
}

func (s *Storage) merge(key, val string) (*treeNode, error) <span class="cov9" title="172">{
        path, err := SplitPath(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="172">tree := s.tree
        for i, pathNode := range path </span><span class="cov10" title="314">{
                if tree.node == nodeTypeMap </span><span class="cov8" title="142">{
                        if pathNode.Type != PathTypeKey </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("property '%s' is a map but '%s' wants other type", JoinPath(path[:i]), key)
                        }</span>
                }
                <span class="cov10" title="314">m := tree.data.(map[string]*treeNode)
                v, ok := m[pathNode.Elem]
                if v != nil &amp;&amp; v.node == nodeTypeNil </span><span class="cov0" title="0">{
                        delete(s.data, JoinPath(path[:i+1]))
                }</span>
                <span class="cov10" title="314">if !ok || v.node == nodeTypeNil </span><span class="cov9" title="269">{
                        if i &lt; len(path)-1 </span><span class="cov8" title="97">{
                                n := &amp;treeNode{
                                        data: make(map[string]*treeNode),
                                }
                                if path[i+1].Type == PathTypeIndex </span><span class="cov0" title="0">{
                                        n.node = nodeTypeArray
                                }</span> else<span class="cov8" title="97"> {
                                        n.node = nodeTypeMap
                                }</span>
                                <span class="cov8" title="97">m[pathNode.Elem] = n
                                tree = n
                                continue</span>
                        }
                        <span class="cov9" title="172">if val == "" </span><span class="cov0" title="0">{
                                tree = &amp;treeNode{node: nodeTypeNil}
                        }</span> else<span class="cov9" title="172"> {
                                tree = &amp;treeNode{node: nodeTypeValue}
                        }</span>
                        <span class="cov9" title="172">m[pathNode.Elem] = tree
                        break</span> // break for 100% test
                }
                <span class="cov6" title="45">switch v.node </span>{
                case nodeTypeMap:<span class="cov6" title="45">
                        if i &lt; len(path)-1 </span><span class="cov6" title="45">{
                                tree = v
                                continue</span>
                        }
                        <span class="cov0" title="0">if val == "" </span><span class="cov0" title="0">{
                                return v, nil
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("property '%s' is a map but '%s' wants other type", JoinPath(path[:i+1]), key)</span>
                case nodeTypeArray:<span class="cov0" title="0">
                        if pathNode.Type != PathTypeIndex </span><span class="cov0" title="0">{
                                if i &lt; len(path)-1 &amp;&amp; path[i+1].Type != PathTypeIndex </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("property '%s' is an array but '%s' wants other type", JoinPath(path[:i+1]), key)
                                }</span>
                        }
                        <span class="cov0" title="0">if i &lt; len(path)-1 </span><span class="cov0" title="0">{
                                tree = v
                                continue</span>
                        }
                        <span class="cov0" title="0">if val == "" </span><span class="cov0" title="0">{
                                return v, nil
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("property '%s' is an array but '%s' wants other type", JoinPath(path[:i+1]), key)</span>
                case nodeTypeValue:<span class="cov0" title="0">
                        if i == len(path)-1 </span><span class="cov0" title="0">{
                                return v, nil
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("property '%s' is a value but '%s' wants other type", JoinPath(path[:i+1]), key)</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("invalid node type %d", v.node)</span>
                }
        }
        <span class="cov9" title="172">return tree, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package bootstrap

import (
        "os"

        "github.com/go-spring/spring-core/gs"
)

func init() <span class="cov8" title="1">{
        gs.Boot().Object(&amp;Runner{}).AsRunner().OnProfiles("online")
}</span>

type Runner struct{}

func (r *Runner) Run() error <span class="cov8" title="1">{
        err := os.MkdirAll("./conf", os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">const data = `
server.addr=0.0.0.0:9090

log.access.name=access.log
log.access.dir=./log

log.biz.name=biz.log
log.biz.dir=./log

log.dao.name=dao.log
log.dao.dir=./log`

        const file = "conf/app-online.properties"
        return os.WriteFile(file, []byte(data), os.ModePerm)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package log

import (
        "log/slog"
        "os"
        "path/filepath"

        "github.com/go-spring/spring-core/gs"
)

func init() <span class="cov1" title="1">{
        gs.GroupRegister(func(p gs.Properties) ([]*gs.BeanDefinition, error) </span><span class="cov1" title="1">{
                var loggers map[string]struct {
                        Name string `value:"${name}"`
                        Dir  string `value:"${dir}"`
                }
                err := p.Bind(&amp;loggers, "${log}")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">var ret []*gs.BeanDefinition
                for k, l := range loggers </span><span class="cov10" title="3">{
                        var (
                                f    *os.File
                                flag = os.O_WRONLY | os.O_CREATE | os.O_APPEND
                        )
                        f, err = os.OpenFile(filepath.Join(l.Dir, l.Name), flag, os.ModePerm)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov10" title="3">o := slog.New(slog.NewTextHandler(f, nil))
                        b := gs.NewBean(o).Name(k).Destroy(func(_ *slog.Logger) </span><span class="cov10" title="3">{
                                _ = f.Close()
                        }</span>)
                        <span class="cov10" title="3">ret = append(ret, b)</span>
                }
                <span class="cov1" title="1">return ret, nil</span>
        })
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package httpsvr

import (
        "fmt"
        "log/slog"
        "net/http"

        "github.com/go-spring/spring-core/gs"
        "github.com/go-spring/spring-core/gs/examples/bookman/idl"
)

func init() <span class="cov1" title="1">{
        gs.Provide(NewServeMux, gs.IndexArg(1, gs.TagArg("access")))
}</span>

func NewServeMux(c idl.Controller, logger *slog.Logger) *http.ServeMux <span class="cov1" title="1">{
        mux := http.NewServeMux()
        idl.RegisterRouter(mux, c, Access(logger))
        return mux
}</span>

func Access(logger *slog.Logger) func(http.Handler) http.Handler <span class="cov1" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov10" title="4">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov1" title="1">{
                        logger.Info(fmt.Sprintf("access %s %s", r.Method, r.URL.Path))
                        next.ServeHTTP(w, r)
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package controller

import (
        "encoding/json"
        "net/http"

        "github.com/go-spring/spring-core/gs/examples/bookman/biz/service/book_service"
        "github.com/go-spring/spring-core/gs/examples/bookman/dao/book_dao"
)

type BookController struct {
        BookService *book_service.BookService `autowire:""`
}

func (c *BookController) ListBooks(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        books, err := c.BookService.ListBooks()
        if err != nil </span><span class="cov0" title="0">{
                _, _ = w.Write([]byte(err.Error()))
                return
        }</span>
        <span class="cov8" title="1">_ = json.NewEncoder(w).Encode(books)</span>
}

func (c *BookController) GetBook(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        isbn := r.PathValue("isbn")
        book, err := c.BookService.GetBook(isbn)
        if err != nil </span><span class="cov0" title="0">{
                _, _ = w.Write([]byte(err.Error()))
                return
        }</span>
        <span class="cov0" title="0">_ = json.NewEncoder(w).Encode(book)</span>
}

func (c *BookController) SaveBook(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var book book_dao.Book
        if err := json.NewDecoder(r.Body).Decode(&amp;book); err != nil </span><span class="cov0" title="0">{
                _, _ = w.Write([]byte(err.Error()))
                return
        }</span>
        <span class="cov0" title="0">if err := c.BookService.SaveBook(book); err != nil </span><span class="cov0" title="0">{
                _, _ = w.Write([]byte(err.Error()))
                return
        }</span>
        <span class="cov0" title="0">_ = json.NewEncoder(w).Encode("OK!")</span>
}

func (c *BookController) DeleteBook(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        isbn := r.PathValue("isbn")
        err := c.BookService.DeleteBook(isbn)
        if err != nil </span><span class="cov0" title="0">{
                _, _ = w.Write([]byte(err.Error()))
                return
        }</span>
        <span class="cov0" title="0">_ = json.NewEncoder(w).Encode("OK!")</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package controller

import (
        "github.com/go-spring/spring-core/gs"
        "github.com/go-spring/spring-core/gs/examples/bookman/idl"
)

func init() <span class="cov8" title="1">{
        gs.Object(&amp;Controller{}).Export(gs.As[idl.Controller]())
}</span>

var _ idl.Controller = (*Controller)(nil)

type Controller struct {
        BookController
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package job

import (
        "context"
        "fmt"
        "time"

        "github.com/go-spring/spring-core/gs"
)

func init() <span class="cov8" title="1">{
        gs.Object(&amp;Job{}).AsJob()
}</span>

type Job struct {
}

func (x *Job) Run(ctx context.Context) error <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        fmt.Println("job exit")
                        return nil</span>
                case &lt;-time.After(time.Second * 5):<span class="cov0" title="0">
                        fmt.Println("job sleep end")</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package book_service

import (
        "log/slog"

        "github.com/go-spring/spring-core/gs"
        "github.com/go-spring/spring-core/gs/examples/bookman/dao/book_dao"
)

func init() <span class="cov8" title="1">{
        gs.Object(&amp;BookService{})
}</span>

type BookService struct {
        BookDao *book_dao.BookDao `autowire:""`
        Logger  *slog.Logger      `autowire:"biz"`
}

func (s *BookService) ListBooks() ([]book_dao.Book, error) <span class="cov8" title="1">{
        return s.BookDao.ListBooks()
}</span>

func (s *BookService) GetBook(isbn string) (book_dao.Book, error) <span class="cov0" title="0">{
        return s.BookDao.GetBook(isbn)
}</span>

func (s *BookService) SaveBook(book book_dao.Book) error <span class="cov0" title="0">{
        return s.BookDao.SaveBook(book)
}</span>

func (s *BookService) DeleteBook(isbn string) error <span class="cov0" title="0">{
        return s.BookDao.DeleteBook(isbn)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package book_dao

import (
        "log/slog"
        "maps"
        "slices"
        "sort"

        "github.com/go-spring/spring-core/gs"
)

func init() <span class="cov8" title="1">{
        gs.Object(&amp;BookDao{Store: map[string]Book{
                "978-0134190440": {
                        Title:     "The Go Programming Language",
                        Author:    "Alan A. A. Donovan, Brian W. Kernighan",
                        ISBN:      "978-0134190440",
                        Publisher: "Addison-Wesley",
                },
        }})
}</span>

type Book struct {
        Title     string `json:"title"`
        Author    string `json:"author"`
        ISBN      string `json:"isbn"`
        Publisher string `json:"publisher"`
}

type BookDao struct {
        Store  map[string]Book
        Logger *slog.Logger `autowire:"dao"`
}

func (dao *BookDao) ListBooks() ([]Book, error) <span class="cov8" title="1">{
        r := slices.Collect(maps.Values(dao.Store))
        sort.Slice(r, func(i, j int) bool </span><span class="cov0" title="0">{
                return r[i].ISBN &lt; r[j].ISBN
        }</span>)
        <span class="cov8" title="1">return r, nil</span>
}

func (dao *BookDao) GetBook(isbn string) (Book, error) <span class="cov0" title="0">{
        r, _ := dao.Store[isbn]
        return r, nil
}</span>

func (dao *BookDao) SaveBook(book Book) error <span class="cov0" title="0">{
        dao.Store[book.ISBN] = book
        return nil
}</span>

func (dao *BookDao) DeleteBook(isbn string) error <span class="cov0" title="0">{
        delete(dao.Store, isbn)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package idl

import (
        "net/http"
)

type Controller interface {
        ListBooks(w http.ResponseWriter, r *http.Request)
        GetBook(w http.ResponseWriter, r *http.Request)
        SaveBook(w http.ResponseWriter, r *http.Request)
        DeleteBook(w http.ResponseWriter, r *http.Request)
}

func RegisterRouter(mux *http.ServeMux, c Controller, wrap func(next http.Handler) http.Handler) <span class="cov8" title="1">{
        mux.Handle("GET /books", wrap(http.HandlerFunc(c.ListBooks)))
        mux.Handle("GET /books/{isbn}", wrap(http.HandlerFunc(c.GetBook)))
        mux.Handle("POST /books", wrap(http.HandlerFunc(c.SaveBook)))
        mux.Handle("DELETE /books/{isbn}", wrap(http.HandlerFunc(c.DeleteBook)))
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs

import (
        "fmt"
        "reflect"
        "strings"

        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/gs/internal/gs_app"
        "github.com/go-spring/spring-core/gs/internal/gs_arg"
        "github.com/go-spring/spring-core/gs/internal/gs_cond"
        "github.com/go-spring/spring-core/gs/internal/gs_conf"
        "github.com/go-spring/spring-core/gs/internal/gs_core"
        "github.com/go-spring/spring-core/gs/internal/gs_dync"
)

const (
        Version = "go-spring@v1.2.0.rc"
        Website = "https://go-spring.com/"
)

// As returns the [reflect.Type] of the given interface type.
func As[T any]() reflect.Type <span class="cov1" title="1">{
        return gs.As[T]()
}</span>

/************************************ arg ***********************************/

type Arg = gs.Arg

// TagArg returns a TagArg with the specified tag.
func TagArg(tag string) Arg <span class="cov4" title="3">{
        return gs_arg.TagArg{Tag: tag}
}</span>

// NilArg returns a ValueArg with a nil value.
func NilArg() Arg <span class="cov0" title="0">{
        return gs_arg.Nil()
}</span>

// ValueArg returns a ValueArg with the specified value.
func ValueArg(v interface{}) Arg <span class="cov0" title="0">{
        return gs_arg.Value(v)
}</span>

// IndexArg returns an IndexArg with the specified index and argument.
func IndexArg(n int, arg Arg) Arg <span class="cov1" title="1">{
        return gs_arg.Index(n, arg)
}</span>

// BindArg binds runtime arguments to a given function.
func BindArg(fn interface{}, args ...Arg) *gs_arg.Callable <span class="cov0" title="0">{
        return gs_arg.MustBind(fn, args...)
}</span>

// OptionArg returns an OptionArg for the specified function and arguments.
func OptionArg(fn interface{}, args ...Arg) *gs_arg.OptionArg <span class="cov0" title="0">{
        return gs_arg.Option(fn, args...)
}</span>

/************************************ cond ***********************************/

type (
        CondFunc    = gs.CondFunc
        Condition   = gs.Condition
        CondContext = gs.CondContext
)

// OnFunc creates a Condition based on the provided function.
func OnFunc(fn CondFunc) Condition <span class="cov0" title="0">{
        return gs_cond.OnFunc(fn)
}</span>

// OnProperty creates a Condition based on a property name and options.
func OnProperty(name string) gs_cond.OnPropertyInterface <span class="cov2" title="2">{
        return gs_cond.OnProperty(name)
}</span>

// OnMissingProperty creates a Condition that checks for a missing property.
func OnMissingProperty(name string) Condition <span class="cov0" title="0">{
        return gs_cond.OnMissingProperty(name)
}</span>

// OnBean creates a Condition based on a BeanSelector.
func OnBean[T any](name ...string) Condition <span class="cov1" title="1">{
        return gs_cond.OnBean[T](name...)
}</span>

// OnBeanSelector creates a Condition based on a BeanSelector.
func OnBeanSelector(s BeanSelector) Condition <span class="cov0" title="0">{
        return gs_cond.OnBeanSelector(s)
}</span>

// OnMissingBean creates a Condition for when a specific bean is missing.
func OnMissingBean[T any](name ...string) Condition <span class="cov0" title="0">{
        return gs_cond.OnMissingBean[T](name...)
}</span>

// OnMissingBeanSelector creates a Condition for when a specific bean is missing.
func OnMissingBeanSelector(s BeanSelector) Condition <span class="cov0" title="0">{
        return gs_cond.OnMissingBeanSelector(s)
}</span>

// OnSingleBean creates a Condition for when only one instance of a bean exists.
func OnSingleBean[T any](name ...string) Condition <span class="cov0" title="0">{
        return gs_cond.OnSingleBean[T](name...)
}</span>

// OnSingleBeanSelector creates a Condition for when only one instance of a bean exists.
func OnSingleBeanSelector(s BeanSelector) Condition <span class="cov0" title="0">{
        return gs_cond.OnSingleBeanSelector(s)
}</span>

// RegisterExpressFunc registers a custom expression function.
func RegisterExpressFunc(name string, fn interface{}) <span class="cov0" title="0">{
        gs_cond.RegisterExpressFunc(name, fn)
}</span>

// OnExpression creates a Condition based on a custom expression.
func OnExpression(expression string) Condition <span class="cov0" title="0">{
        return gs_cond.OnExpression(expression)
}</span>

// Not creates a Condition that negates the given Condition.
func Not(c Condition) Condition <span class="cov0" title="0">{
        return gs_cond.Not(c)
}</span>

// Or creates a Condition that is true if any of the given Conditions are true.
func Or(conditions ...Condition) Condition <span class="cov0" title="0">{
        return gs_cond.Or(conditions...)
}</span>

// And creates a Condition that is true if all the given Conditions are true.
func And(conditions ...Condition) Condition <span class="cov0" title="0">{
        return gs_cond.And(conditions...)
}</span>

// None creates a Condition that is true if none of the given Conditions are true.
func None(conditions ...Condition) Condition <span class="cov0" title="0">{
        return gs_cond.None(conditions...)
}</span>

/************************************ ioc ************************************/

type (
        Properties  = gs.Properties
        Refreshable = gs.Refreshable
        Dync[T any] = gs_dync.Value[T]
)

type (
        RegisteredBean = gs.RegisteredBean
        BeanDefinition = gs.BeanDefinition
)

type (
        BeanSelector    = gs.BeanSelector
        BeanInitFunc    = gs.BeanInitFunc
        BeanDestroyFunc = gs.BeanDestroyFunc
)

// NewBean creates a new BeanDefinition.
var NewBean = gs_core.NewBean

// BeanSelectorFor returns a BeanSelector for the given type.
func BeanSelectorFor[T any](name ...string) BeanSelector <span class="cov0" title="0">{
        return gs.BeanSelectorFor[T](name...)
}</span>

/************************************ boot ***********************************/

var boot gs_app.Boot

// Boot initializes and returns a [*gs_app.Boot] instance.
func Boot() gs_app.Boot <span class="cov1" title="1">{
        if boot == nil </span><span class="cov1" title="1">{
                boot = gs_app.NewBoot()
        }</span>
        <span class="cov1" title="1">return boot</span>
}

/*********************************** app *************************************/

type (
        Runner      = gs.Runner
        Job         = gs.Job
        Server      = gs.Server
        ReadySignal = gs.ReadySignal
)

// Run runs the app and waits for an interrupt signal to exit.
func Run() error <span class="cov1" title="1">{
        printBanner()
        if boot != nil </span><span class="cov1" title="1">{
                if err := boot.(interface{ Run() error }).Run(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">boot = nil</span>
        }
        <span class="cov1" title="1">return gs_app.GS.Run()</span>
}

// Exiting returns a boolean indicating whether the application is exiting.
func Exiting() bool <span class="cov0" title="0">{
        return gs_app.GS.Exiting()
}</span>

// ShutDown shuts down the app with an optional message.
func ShutDown() <span class="cov1" title="1">{
        gs_app.GS.ShutDown()
}</span>

// Config returns the app configuration.
func Config() *gs_conf.AppConfig <span class="cov0" title="0">{
        return gs_app.GS.P
}</span>

// Object registers a bean definition for a given object.
func Object(i interface{}) *RegisteredBean <span class="cov4" title="4">{
        b := NewBean(reflect.ValueOf(i))
        return gs_app.GS.C.Register(b)
}</span>

// Provide registers a bean definition for a given constructor.
func Provide(ctor interface{}, args ...Arg) *RegisteredBean <span class="cov4" title="3">{
        b := NewBean(ctor, args...)
        return gs_app.GS.C.Register(b)
}</span>

// Register registers a bean definition.
func Register(b *BeanDefinition) *RegisteredBean <span class="cov0" title="0">{
        return gs_app.GS.C.Register(b)
}</span>

// GroupRegister registers a group of bean definitions.
func GroupRegister(fn func(p Properties) ([]*BeanDefinition, error)) <span class="cov1" title="1">{
        gs_app.GS.C.GroupRegister(fn)
}</span>

// RefreshProperties refreshes the app configuration.
func RefreshProperties() error <span class="cov0" title="0">{
        p, err := Config().Refresh()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return gs_app.GS.C.RefreshProperties(p)</span>
}

/********************************** banner ***********************************/

var appBanner = `
   ____    ___            ____    ____    ____    ___   _   _    ____ 
  / ___|  / _ \          / ___|  |  _ \  |  _ \  |_ _| | \ | |  / ___|
 | |  _  | | | |  _____  \___ \  | |_) | | |_) |  | |  |  \| | | |  _ 
 | |_| | | |_| | |_____|  ___) | |  __/  |  _ &lt;   | |  | |\  | | |_| |
  \____|  \___/          |____/  |_|     |_| \_\ |___| |_| \_|  \____| 
`

// Banner sets a custom app banner.
func Banner(banner string) <span class="cov0" title="0">{
        appBanner = banner
}</span>

// printBanner prints the app banner.
func printBanner() <span class="cov1" title="1">{
        if len(appBanner) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">if appBanner[0] != '\n' </span><span class="cov0" title="0">{
                fmt.Println()
        }</span>

        <span class="cov1" title="1">maxLength := 0
        for _, s := range strings.Split(appBanner, "\n") </span><span class="cov6" title="7">{
                fmt.Printf("\x1b[36m%s\x1b[0m\n", s) // CYAN
                if len(s) &gt; maxLength </span><span class="cov2" title="2">{
                        maxLength = len(s)
                }</span>
        }

        <span class="cov1" title="1">if appBanner[len(appBanner)-1] != '\n' </span><span class="cov0" title="0">{
                fmt.Println()
        }</span>

        <span class="cov1" title="1">var padding []byte
        if n := (maxLength - len(Version)) / 2; n &gt; 0 </span><span class="cov1" title="1">{
                padding = make([]byte, n)
                for i := range padding </span><span class="cov10" title="26">{
                        padding[i] = ' '
                }</span>
        }
        <span class="cov1" title="1">fmt.Println(string(padding) + Version + "\n")</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs

import (
        "context"
        "net"
        "net/http"
)

func init() <span class="cov1" title="1">{
        // Initialize the HTTP server. The server will listen on the address specified
        // by the 'server.addr' configuration, defaulting to "0.0.0.0:9090" if not set.
        // It is only provided as a server if an instance of *http.ServeMux exists.
        Provide(NewSimpleHttpServer, TagArg("${server.addr:=0.0.0.0:9090}")).
                Condition(OnBean[*http.ServeMux]()).
                Condition(OnProperty(EnableSimpleHttpServerProp).HavingValue("true").MatchIfMissing()).
                AsServer()
}</span>

// SimpleHttpServer wraps a [http.Server] instance.
type SimpleHttpServer struct {
        svr *http.Server
}

// NewSimpleHttpServer creates a new instance of SimpleHttpServer.
func NewSimpleHttpServer(addr string, mux *http.ServeMux) *SimpleHttpServer <span class="cov10" title="2">{
        return &amp;SimpleHttpServer{svr: &amp;http.Server{
                Addr:    addr,
                Handler: mux,
        }}
}</span>

// ListenAndServe starts the HTTP server and listens for incoming connections.
func (s *SimpleHttpServer) ListenAndServe(sig ReadySignal) error <span class="cov10" title="2">{
        ln, err := net.Listen("tcp", s.svr.Addr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="2">&lt;-sig.TriggerAndWait()
        return s.svr.Serve(ln)</span>
}

// Shutdown gracefully shuts down the HTTP server with the given context.
func (s *SimpleHttpServer) Shutdown(ctx context.Context) error <span class="cov10" title="2">{
        return s.svr.Shutdown(ctx)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs

import (
        "context"
        "reflect"
        "strings"
        "unsafe"

        "github.com/go-spring/spring-core/conf"
)

// anyType is the [reflect.Type] of the [any] type.
var anyType = reflect.TypeFor[any]()

// As returns the [reflect.Type] of the given interface type.
// It ensures that the provided generic type parameter T is an interface.
// If T is not an interface, the function panics.
func As[T any]() reflect.Type <span class="cov5" title="5">{
        t := reflect.TypeFor[T]()
        if t.Kind() != reflect.Interface </span><span class="cov0" title="0">{
                panic("T must be interface")</span>
        }
        <span class="cov5" title="5">return t</span>
}

// BeanInitFunc defines the prototype for initialization functions.
// Examples: `func(bean)` or `func(bean) error`.
type BeanInitFunc = interface{}

// BeanDestroyFunc defines the prototype for destruction functions.
// Examples: `func(bean)` or `func(bean) error`.
type BeanDestroyFunc = interface{}

// BeanSelector is an interface for selecting beans.
type BeanSelector interface {
        // TypeAndName returns the type and name of the bean.
        TypeAndName() (reflect.Type, string)
}

// BeanSelectorImpl is an implementation of BeanSelector.
type BeanSelectorImpl struct {
        Type reflect.Type // The type of the bean
        Name string       // The name of the bean
}

// BeanSelectorFor returns a BeanSelectorImpl for the given type.
// If a name is provided, it is set; otherwise, only the type is used.
func BeanSelectorFor[T any](name ...string) BeanSelector <span class="cov1" title="1">{
        if len(name) == 0 </span><span class="cov1" title="1">{
                return BeanSelectorImpl{Type: reflect.TypeFor[T]()}
        }</span>
        <span class="cov0" title="0">return BeanSelectorImpl{Type: reflect.TypeFor[T](), Name: name[0]}</span>
}

// TypeAndName returns the type and name of the bean.
func (s BeanSelectorImpl) TypeAndName() (reflect.Type, string) <span class="cov1" title="1">{
        return s.Type, s.Name
}</span>

func (s BeanSelectorImpl) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString("{")
        if s.Type != nil &amp;&amp; s.Type != anyType </span><span class="cov0" title="0">{
                sb.WriteString("Type:")
                sb.WriteString(s.Type.String())
        }</span>
        <span class="cov0" title="0">if s.Name != "" </span><span class="cov0" title="0">{
                if sb.Len() &gt; 1 </span><span class="cov0" title="0">{
                        sb.WriteString(",")
                }</span>
                <span class="cov0" title="0">sb.WriteString("Name:")
                sb.WriteString(s.Name)</span>
        }
        <span class="cov0" title="0">sb.WriteString("}")
        return sb.String()</span>
}

/********************************** condition ********************************/

// Condition is an interface used for defining conditional logic
// when registering beans in the IoC container.
type Condition interface {
        // Matches checks whether the condition is satisfied.
        Matches(ctx CondContext) (bool, error)
}

// CondBean represents a bean with Name and Type.
type CondBean interface {
        Name() string
        Type() reflect.Type
}

// CondContext defines methods for the IoC container used by conditions.
type CondContext interface {
        // Has checks whether the IoC container has a property with the given key.
        Has(key string) bool
        // Prop retrieves the value of a property from the IoC container.
        Prop(key string, def ...string) string
        // Find searches for bean definitions matching the given BeanSelector.
        Find(s BeanSelector) ([]CondBean, error)
}

// CondFunc is a function type that determines whether a condition is satisfied.
type CondFunc func(ctx CondContext) (bool, error)

/************************************* arg ***********************************/

// Arg is an interface for retrieving argument values in function parameter binding.
type Arg interface {
        // GetArgValue retrieves the argument value based on the type.
        GetArgValue(ctx ArgContext, t reflect.Type) (reflect.Value, error)
}

// ArgContext defines methods for the IoC container used by Arg types.
type ArgContext interface {
        // Matches checks if the given condition is met.
        Matches(c Condition) (bool, error)
        // Bind binds property values to the provided [reflect.Value].
        Bind(v reflect.Value, tag string) error
        // Wire wires dependent beans to the provided [reflect.Value].
        Wire(v reflect.Value, tag string) error
}

/*********************************** conf ************************************/

// Properties represents read-only configuration properties.
type Properties = conf.ReadOnlyProperties

// Refreshable represents an object that can be dynamically refreshed.
type Refreshable interface {
        // OnRefresh is called to refresh the properties when they change.
        OnRefresh(prop Properties, param conf.BindParam) error
}

/*********************************** app ************************************/

// Runner defines an interface for components that should run after
// all beans are injected but before the application servers start.
type Runner interface {
        Run() error
}

// Job defines an interface for components that run tasks with a given context
// after all beans are injected but before the application servers start.
type Job interface {
        Run(ctx context.Context) error
}

// ReadySignal defines an interface for components that can trigger a signal
// when the application is ready to serve requests.
type ReadySignal interface {
        TriggerAndWait() &lt;-chan struct{}
}

// Server defines an interface for managing the lifecycle of application servers,
// such as HTTP, gRPC, Thrift, or MQ servers. It includes methods for starting
// and shutting down the server gracefully.
type Server interface {
        ListenAndServe(sig ReadySignal) error
        Shutdown(ctx context.Context) error
}

/*********************************** bean ************************************/

// ConfigurationParam holds parameters for bean setup configuration.
type ConfigurationParam struct {
        Includes []string // Methods to include
        Excludes []string // Methods to exclude
}

// BeanRegistration provides methods for configuring and registering bean metadata.
type BeanRegistration interface {
        Name() string
        Type() reflect.Type
        Value() reflect.Value
        SetName(name string)
        SetInit(fn BeanInitFunc)
        SetDestroy(fn BeanDestroyFunc)
        SetInitMethod(method string)
        SetDestroyMethod(method string)
        SetCondition(conditions ...Condition)
        SetDependsOn(selectors ...BeanSelector)
        SetExport(exports ...reflect.Type)
        SetConfiguration(param ...ConfigurationParam)
        SetRefreshable(tag string)
        SetCaller(skip int)
        OnProfiles(profiles string)
}

// beanBuilder helps configure a bean during its creation.
type beanBuilder[T any] struct {
        b BeanRegistration
}

// TypeAndName returns the type and name of the bean.
func (d *beanBuilder[T]) TypeAndName() (reflect.Type, string) <span class="cov0" title="0">{
        return d.b.Type(), d.b.Name()
}</span>

// GetArgValue returns the value of the bean.
func (d *beanBuilder[T]) GetArgValue(ctx ArgContext, t reflect.Type) (reflect.Value, error) <span class="cov0" title="0">{
        return d.b.Value(), nil
}</span>

// BeanRegistration returns the underlying BeanRegistration instance.
func (d *beanBuilder[T]) BeanRegistration() BeanRegistration <span class="cov10" title="23">{
        return d.b
}</span>

// Name sets the name of the bean.
func (d *beanBuilder[T]) Name(name string) *T <span class="cov4" title="3">{
        d.b.SetName(name)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// Init sets the initialization function for the bean.
func (d *beanBuilder[T]) Init(fn BeanInitFunc) *T <span class="cov0" title="0">{
        d.b.SetInit(fn)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// Destroy sets the destruction function for the bean.
func (d *beanBuilder[T]) Destroy(fn BeanDestroyFunc) *T <span class="cov4" title="3">{
        d.b.SetDestroy(fn)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// InitMethod sets the initialization function for the bean by method name.
func (d *beanBuilder[T]) InitMethod(method string) *T <span class="cov0" title="0">{
        d.b.SetInitMethod(method)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// DestroyMethod sets the destruction function for the bean by method name.
func (d *beanBuilder[T]) DestroyMethod(method string) *T <span class="cov0" title="0">{
        d.b.SetDestroyMethod(method)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// Condition sets the conditions for the bean.
func (d *beanBuilder[T]) Condition(conditions ...Condition) *T <span class="cov4" title="3">{
        d.b.SetCondition(conditions...)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// DependsOn sets the beans that this bean depends on.
func (d *beanBuilder[T]) DependsOn(selectors ...BeanSelector) *T <span class="cov0" title="0">{
        d.b.SetDependsOn(selectors...)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// AsRunner marks the bean as a Runner.
func (d *beanBuilder[T]) AsRunner() *T <span class="cov1" title="1">{
        d.b.SetExport(As[Runner]())
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// AsJob marks the bean as a Job.
func (d *beanBuilder[T]) AsJob() *T <span class="cov1" title="1">{
        d.b.SetExport(As[Job]())
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// AsServer marks the bean as a Server.
func (d *beanBuilder[T]) AsServer() *T <span class="cov2" title="2">{
        d.b.SetExport(As[Server]())
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// Export sets the interfaces that the bean will export.
func (d *beanBuilder[T]) Export(exports ...reflect.Type) *T <span class="cov1" title="1">{
        d.b.SetExport(exports...)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// Configuration applies the configuration parameters to the bean.
func (d *beanBuilder[T]) Configuration(param ...ConfigurationParam) *T <span class="cov0" title="0">{
        d.b.SetConfiguration(param...)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// Refreshable marks the bean as refreshable with the provided tag.
func (d *beanBuilder[T]) Refreshable(tag string) *T <span class="cov0" title="0">{
        d.b.SetRefreshable(tag)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// Caller sets the caller information for the bean.
func (d *beanBuilder[T]) Caller(skip int) *T <span class="cov0" title="0">{
        d.b.SetCaller(skip)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// OnProfiles sets the profiles that the bean will be active in.
func (d *beanBuilder[T]) OnProfiles(profiles string) *T <span class="cov1" title="1">{
        d.b.OnProfiles(profiles)
        return *(**T)(unsafe.Pointer(&amp;d))
}</span>

// RegisteredBean represents a bean that has been registered in the IoC container.
type RegisteredBean struct {
        beanBuilder[RegisteredBean]
}

// NewRegisteredBean creates a new RegisteredBean instance.
func NewRegisteredBean(d BeanRegistration) *RegisteredBean <span class="cov7" title="10">{
        return &amp;RegisteredBean{
                beanBuilder: beanBuilder[RegisteredBean]{d},
        }
}</span>

// BeanDefinition represents a bean that has not yet been registered.
type BeanDefinition struct {
        beanBuilder[BeanDefinition]
}

// NewBeanDefinition creates a new BeanDefinition instance.
func NewBeanDefinition(d BeanRegistration) *BeanDefinition <span class="cov8" title="13">{
        return &amp;BeanDefinition{
                beanBuilder: beanBuilder[BeanDefinition]{d},
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_app

import (
        "context"
        "errors"
        "net/http"
        "os"
        "os/signal"
        "sync"
        "sync/atomic"
        "syscall"
        "time"

        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/gs/internal/gs_conf"
        "github.com/go-spring/spring-core/gs/internal/gs_core"
        "github.com/go-spring/spring-core/util/goutil"
        "github.com/go-spring/spring-core/util/syslog"
)

// GS is the global application instance.
var GS = NewApp()

// App represents the core application, managing its lifecycle,
// configuration, and dependency injection.
type App struct {
        C *gs_core.Container
        P *gs_conf.AppConfig

        exiting atomic.Bool
        ctx     context.Context
        cancel  context.CancelFunc
        wg      sync.WaitGroup

        Runners []gs.Runner `autowire:"${spring.app.runners:=*?}"`
        Jobs    []gs.Job    `autowire:"${spring.app.jobs:=*?}"`
        Servers []gs.Server `autowire:"${spring.app.servers:=*?}"`
}

// NewApp creates and initializes a new application instance.
func NewApp() *App <span class="cov1" title="1">{
        ctx, cancel := context.WithCancel(context.Background())
        return &amp;App{
                C:      gs_core.New(),
                P:      gs_conf.NewAppConfig(),
                ctx:    ctx,
                cancel: cancel,
        }
}</span>

// Run starts the application and listens for termination signals
// (e.g., SIGINT, SIGTERM). Upon receiving a signal, it initiates
// a graceful shutdown.
func (app *App) Run() error <span class="cov1" title="1">{
        app.C.Object(app)

        if err := app.Start(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // listens for OS termination signals
        <span class="cov1" title="1">go func() </span><span class="cov1" title="1">{
                ch := make(chan os.Signal, 1)
                signal.Notify(ch, os.Interrupt, syscall.SIGTERM)
                sig := &lt;-ch
                syslog.Infof("Received signal: %v", sig)
                app.ShutDown()
        }</span>()

        // waits for the shutdown signal
        <span class="cov1" title="1">&lt;-app.ctx.Done()
        app.Stop()
        return nil</span>
}

// Start initializes and starts the application. It performs configuration
// loading, IoC container refreshing, dependency injection, and runs
// runners, jobs and servers.
func (app *App) Start() error <span class="cov1" title="1">{
        // loads the layered app properties
        p, err := app.P.Refresh()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // refreshes the container properties
        <span class="cov1" title="1">err = app.C.RefreshProperties(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // refreshes the container
        <span class="cov1" title="1">err = app.C.Refresh()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // runs all runners
        <span class="cov1" title="1">for _, r := range app.Runners </span><span class="cov0" title="0">{
                if err := r.Run(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // runs all jobs
        <span class="cov1" title="1">for _, job := range app.Jobs </span><span class="cov1" title="1">{
                goutil.GoFunc(func() </span><span class="cov1" title="1">{
                        defer func() </span><span class="cov1" title="1">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        app.ShutDown()
                                        panic(r)</span>
                                }
                        }()
                        <span class="cov1" title="1">if err := job.Run(app.ctx); err != nil </span><span class="cov0" title="0">{
                                syslog.Errorf("job run error: %s", err.Error())
                                app.ShutDown()
                        }</span>
                })
        }

        <span class="cov1" title="1">sig := NewReadySignal()

        // starts all servers
        for _, svr := range app.Servers </span><span class="cov10" title="2">{
                sig.Add()
                app.wg.Add(1)
                goutil.GoFunc(func() </span><span class="cov10" title="2">{
                        defer app.wg.Done()
                        defer func() </span><span class="cov10" title="2">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        sig.Intercept()
                                        app.ShutDown()
                                        panic(r)</span>
                                }
                        }()
                        <span class="cov10" title="2">err := svr.ListenAndServe(sig)
                        if err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                                syslog.Errorf("server serve error: %s", err.Error())
                                sig.Intercept()
                                app.ShutDown()
                        }</span>
                })
        }

        <span class="cov1" title="1">sig.Wait()
        if sig.Intercepted() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">syslog.Infof("ready to serve requests")
        sig.Close()
        return nil</span>
}

// Stop gracefully shuts down the application, ensuring all servers and
// resources are properly closed.
func (app *App) Stop() <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), time.Second*15)
        defer cancel()

        waitChan := make(chan struct{})
        goutil.GoFunc(func() </span><span class="cov1" title="1">{
                for _, svr := range app.Servers </span><span class="cov10" title="2">{
                        goutil.GoFunc(func() </span><span class="cov10" title="2">{
                                if err := svr.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                                        syslog.Errorf("shutdown server failed: %s", err.Error())
                                }</span>
                        })
                }
                <span class="cov1" title="1">app.wg.Wait()
                app.C.Close()
                waitChan &lt;- struct{}{}</span>
        })

        <span class="cov1" title="1">select </span>{
        case &lt;-waitChan:<span class="cov1" title="1">
                syslog.Infof("shutdown complete")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                syslog.Infof("shutdown timeout")</span>
        }
}

// Exiting returns a boolean indicating whether the application is exiting.
func (app *App) Exiting() bool <span class="cov0" title="0">{
        return app.exiting.Load()
}</span>

// ShutDown gracefully terminates the application. This method should
// be called to trigger a proper shutdown process.
func (app *App) ShutDown() <span class="cov1" title="1">{
        app.exiting.Store(true)
        app.cancel()
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_app

import (
        "reflect"

        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/gs/internal/gs_conf"
        "github.com/go-spring/spring-core/gs/internal/gs_core"
)

// Boot defines the interface for application bootstrapping.
type Boot interface {
        Config() *gs_conf.BootConfig
        Object(i interface{}) *gs.RegisteredBean
        Provide(ctor interface{}, args ...gs.Arg) *gs.RegisteredBean
        Register(bd *gs.BeanDefinition) *gs.RegisteredBean
}

// boot is the bootstrapper of the application.
type boot struct {
        c *gs_core.Container
        p *gs_conf.BootConfig

        Runners []gs.Runner `autowire:"${spring.boot.runners:=*?}"`
}

// NewBoot creates a new Boot instance.
func NewBoot() Boot <span class="cov8" title="1">{
        return &amp;boot{
                c: gs_core.New(),
                p: gs_conf.NewBootConfig(),
        }
}</span>

// Config returns the boot configuration.
func (b *boot) Config() *gs_conf.BootConfig <span class="cov0" title="0">{
        return b.p
}</span>

// Object registers an object bean.
func (b *boot) Object(i interface{}) *gs.RegisteredBean <span class="cov8" title="1">{
        bd := gs_core.NewBean(reflect.ValueOf(i))
        return b.c.Register(bd)
}</span>

// Provide registers a bean using a constructor function.
func (b *boot) Provide(ctor interface{}, args ...gs.Arg) *gs.RegisteredBean <span class="cov0" title="0">{
        bd := gs_core.NewBean(ctor, args...)
        return b.c.Register(bd)
}</span>

// Register registers a BeanDefinition instance.
func (b *boot) Register(bd *gs.BeanDefinition) *gs.RegisteredBean <span class="cov0" title="0">{
        return b.c.Register(bd)
}</span>

// Run executes the application's boot process.
func (b *boot) Run() error <span class="cov8" title="1">{
        b.c.Object(b)

        // Refresh the boot configuration.
        p, err := b.p.Refresh()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Refresh properties in the container.
        <span class="cov8" title="1">err = b.c.RefreshProperties(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Refresh the container.
        <span class="cov8" title="1">err = b.c.Refresh()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Execute all registered runners.
        <span class="cov8" title="1">for _, r := range b.Runners </span><span class="cov8" title="1">{
                if err := r.Run(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">b.c.Close()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_app

import (
        "sync"
        "sync/atomic"
)

// ReadySignal is used to notify that the application is ready to serve requests.
type ReadySignal struct {
        wg sync.WaitGroup
        ch chan struct{}
        ct atomic.Bool
}

// NewReadySignal creates a new ReadySignal instance.
func NewReadySignal() *ReadySignal <span class="cov1" title="1">{
        return &amp;ReadySignal{
                ch: make(chan struct{}),
        }
}</span>

// Add increments the WaitGroup counter.
func (s *ReadySignal) Add() <span class="cov10" title="2">{
        s.wg.Add(1)
}</span>

// TriggerAndWait marks an operation as done by decrementing the WaitGroup counter,
// and then returns the readiness signal channel for waiting.
func (s *ReadySignal) TriggerAndWait() &lt;-chan struct{} <span class="cov10" title="2">{
        s.wg.Done()
        return s.ch
}</span>

// Intercepted returns true if the signal has been intercepted.
func (s *ReadySignal) Intercepted() bool <span class="cov1" title="1">{
        return s.ct.Load()
}</span>

// Intercept marks the signal as intercepted.
func (s *ReadySignal) Intercept() <span class="cov0" title="0">{
        s.ct.Store(true)
        s.wg.Done()
}</span>

// Wait blocks until all WaitGroup counters reach zero.
func (s *ReadySignal) Wait() <span class="cov1" title="1">{
        s.wg.Wait()
}</span>

// Close closes the signal channel, notifying all goroutines waiting on it.
func (s *ReadySignal) Close() <span class="cov1" title="1">{
        close(s.ch)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_arg

import (
        "errors"
        "fmt"
        "reflect"
        "runtime"

        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/util"
        "github.com/go-spring/spring-core/util/errutil"
)

// TagArg represents an argument that has a tag for binding or autowiring.
type TagArg struct {
        Tag string
}

// Tag creates a TagArg with the given tag.
func Tag(tag string) gs.Arg <span class="cov4" title="2">{
        return TagArg{Tag: tag}
}</span>

// GetArgValue returns the value of the argument based on its type.
func (arg TagArg) GetArgValue(ctx gs.ArgContext, t reflect.Type) (reflect.Value, error) <span class="cov9" title="5">{

        // Binds property values based on the argument type.
        if util.IsPropBindingTarget(t) </span><span class="cov4" title="2">{
                v := reflect.New(t).Elem()
                if err := ctx.Bind(v, arg.Tag); err != nil </span><span class="cov0" title="0">{
                        return reflect.Value{}, err
                }</span>
                <span class="cov4" title="2">return v, nil</span>
        }

        // Wires dependent beans based on the argument type.
        <span class="cov6" title="3">if util.IsBeanInjectionTarget(t) </span><span class="cov6" title="3">{
                v := reflect.New(t).Elem()
                if err := ctx.Wire(v, arg.Tag); err != nil </span><span class="cov0" title="0">{
                        return reflect.Value{}, err
                }</span>
                <span class="cov6" title="3">return v, nil</span>
        }

        // If none of the conditions match, return an error.
        <span class="cov0" title="0">err := fmt.Errorf("error type %s", t.String())
        return reflect.Value{}, errutil.WrapError(err, "get arg error: %v", arg.Tag)</span>
}

// IndexArg represents an argument that has an index.
type IndexArg struct {
        Idx int    // Index of the argument.
        Arg gs.Arg // The actual argument value.
}

// Index creates an IndexArg with the given index and argument.
func Index(n int, arg gs.Arg) gs.Arg <span class="cov1" title="1">{
        return IndexArg{Idx: n, Arg: arg}
}</span>

// GetArgValue is not implemented for IndexArg, it panics if called.
func (arg IndexArg) GetArgValue(ctx gs.ArgContext, t reflect.Type) (reflect.Value, error) <span class="cov0" title="0">{
        panic(util.UnimplementedMethod)</span>
}

// ValueArg represents an argument with a fixed value.
type ValueArg struct {
        v interface{} // The fixed value associated with this argument.
}

// Nil returns a ValueArg with a value of nil.
func Nil() gs.Arg <span class="cov0" title="0">{
        return ValueArg{v: nil}
}</span>

// Value returns a ValueArg with the specified value.
func Value(v interface{}) gs.Arg <span class="cov0" title="0">{
        return ValueArg{v: v}
}</span>

// GetArgValue returns the value of the fixed argument.
func (arg ValueArg) GetArgValue(ctx gs.ArgContext, t reflect.Type) (reflect.Value, error) <span class="cov0" title="0">{
        if arg.v == nil </span><span class="cov0" title="0">{
                return reflect.Zero(t), nil
        }</span>
        <span class="cov0" title="0">return reflect.ValueOf(arg.v), nil</span>
}

// ArgList represents a list of arguments for a function.
type ArgList struct {
        fnType reflect.Type // Type of the function to be invoked.
        args   []gs.Arg     // List of arguments for the function.
}

// NewArgList creates and validates an ArgList for the specified function.
func NewArgList(fnType reflect.Type, args []gs.Arg) (*ArgList, error) <span class="cov6" title="3">{

        // Calculates the number of fixed arguments in the function.
        fixedArgCount := fnType.NumIn()
        if fnType.IsVariadic() </span><span class="cov0" title="0">{
                fixedArgCount--
        }</span>

        // Determines if the arguments use indexing.
        <span class="cov6" title="3">shouldIndex := func() bool </span><span class="cov6" title="3">{
                if len(args) == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov6" title="3">_, ok := args[0].(IndexArg)
                return ok</span>
        }()

        <span class="cov6" title="3">fnArgs := make([]gs.Arg, fixedArgCount)

        // Processes the first argument separately to determine its type.
        if len(args) &gt; 0 </span><span class="cov6" title="3">{
                if args[0] == nil </span><span class="cov0" title="0">{
                        err := errors.New("the first arg must not be nil")
                        return nil, errutil.WrapError(err, "%v", args)
                }</span>
                <span class="cov6" title="3">switch arg := args[0].(type) </span>{
                case *OptionArg:<span class="cov0" title="0">
                        fnArgs = append(fnArgs, arg)</span>
                case IndexArg:<span class="cov1" title="1">
                        if arg.Idx &lt; 0 || arg.Idx &gt;= fixedArgCount </span><span class="cov0" title="0">{
                                err := fmt.Errorf("arg index %d exceeds max index %d", arg.Idx, fixedArgCount)
                                return nil, errutil.WrapError(err, "%v", args)
                        }</span> else<span class="cov1" title="1"> {
                                fnArgs[arg.Idx] = arg.Arg
                        }</span>
                default:<span class="cov4" title="2">
                        if fixedArgCount &gt; 0 </span><span class="cov4" title="2">{
                                fnArgs[0] = arg
                        }</span> else<span class="cov0" title="0"> if fnType.IsVariadic() </span><span class="cov0" title="0">{
                                fnArgs = append(fnArgs, arg)
                        }</span> else<span class="cov0" title="0"> {
                                err := fmt.Errorf("function has no args but given %d", len(args))
                                return nil, errutil.WrapError(err, "%v", args)
                        }</span>
                }
        }

        // Processes the remaining arguments.
        <span class="cov6" title="3">for i := 1; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                switch arg := args[i].(type) </span>{
                case *OptionArg:<span class="cov0" title="0">
                        fnArgs = append(fnArgs, arg)</span>
                case IndexArg:<span class="cov0" title="0">
                        if !shouldIndex </span><span class="cov0" title="0">{
                                err := fmt.Errorf("the Args must have or have no index")
                                return nil, errutil.WrapError(err, "%v", args)
                        }</span>
                        <span class="cov0" title="0">if arg.Idx &lt; 0 || arg.Idx &gt;= fixedArgCount </span><span class="cov0" title="0">{
                                err := fmt.Errorf("arg index %d exceeds max index %d", arg.Idx, fixedArgCount)
                                return nil, errutil.WrapError(err, "%v", args)
                        }</span> else<span class="cov0" title="0"> if fnArgs[arg.Idx] != nil </span><span class="cov0" title="0">{
                                err := fmt.Errorf("found same index %d", arg.Idx)
                                return nil, errutil.WrapError(err, "%v", args)
                        }</span> else<span class="cov0" title="0"> {
                                fnArgs[arg.Idx] = arg.Arg
                        }</span>
                default:<span class="cov0" title="0">
                        if shouldIndex </span><span class="cov0" title="0">{
                                err := fmt.Errorf("the Args must have or have no index")
                                return nil, errutil.WrapError(err, "%v", args)
                        }</span>
                        <span class="cov0" title="0">if i &lt; fixedArgCount </span><span class="cov0" title="0">{
                                fnArgs[i] = arg
                        }</span> else<span class="cov0" title="0"> if fnType.IsVariadic() </span><span class="cov0" title="0">{
                                fnArgs = append(fnArgs, arg)
                        }</span> else<span class="cov0" title="0"> {
                                err := fmt.Errorf("the count %d of Args exceeds max index %d", len(args), fixedArgCount)
                                return nil, errutil.WrapError(err, "%v", args)
                        }</span>
                }
        }

        // Fills any unassigned fixed arguments with default values.
        <span class="cov6" title="3">for i := 0; i &lt; fixedArgCount; i++ </span><span class="cov9" title="5">{
                if fnArgs[i] == nil </span><span class="cov4" title="2">{
                        fnArgs[i] = Tag("")
                }</span>
        }

        <span class="cov6" title="3">return &amp;ArgList{fnType: fnType, args: fnArgs}, nil</span>
}

// get returns the processed argument values for the function call.
func (r *ArgList) get(ctx gs.ArgContext) ([]reflect.Value, error) <span class="cov6" title="3">{

        fnType := r.fnType
        numIn := fnType.NumIn()
        variadic := fnType.IsVariadic()
        result := make([]reflect.Value, 0)

        // Processes each argument and converts it to a [reflect.Value].
        for idx, arg := range r.args </span><span class="cov9" title="5">{

                var t reflect.Type
                if variadic &amp;&amp; idx &gt;= numIn-1 </span><span class="cov0" title="0">{
                        t = fnType.In(numIn - 1).Elem()
                }</span> else<span class="cov9" title="5"> {
                        t = fnType.In(idx)
                }</span>

                <span class="cov9" title="5">v, err := arg.GetArgValue(ctx, t)
                if err != nil </span><span class="cov0" title="0">{
                        err = errutil.WrapError(err, "returns error when getting %d arg", idx)
                        return nil, errutil.WrapError(err, "get arg list error: %v", arg)
                }</span>
                <span class="cov9" title="5">if v.IsValid() </span><span class="cov9" title="5">{
                        result = append(result, v)
                }</span>
        }
        <span class="cov6" title="3">return result, nil</span>
}

// CallableFunc is a function that can be called.
type CallableFunc = interface{}

// OptionArg represents a binding for an option function argument.
type OptionArg struct {
        r *Callable
        c []gs.Condition
}

// Option creates a binding for an option function argument.
func Option(fn CallableFunc, args ...gs.Arg) *OptionArg <span class="cov0" title="0">{
        t := reflect.TypeOf(fn)
        if t.Kind() != reflect.Func || t.NumOut() != 1 </span><span class="cov0" title="0">{
                panic(errors.New("invalid option func"))</span>
        }

        <span class="cov0" title="0">_, file, line, _ := runtime.Caller(1)
        r := MustBind(fn, args...)
        r.SetFileLine(file, line)
        return &amp;OptionArg{r: r}</span>
}

// Condition sets a condition for invoking the option function.
func (arg *OptionArg) Condition(conditions ...gs.Condition) *OptionArg <span class="cov0" title="0">{
        arg.c = append(arg.c, conditions...)
        return arg
}</span>

// GetArgValue retrieves the function's return value if conditions are met.
func (arg *OptionArg) GetArgValue(ctx gs.ArgContext, t reflect.Type) (reflect.Value, error) <span class="cov0" title="0">{

        // Checks if the condition is met.
        for _, c := range arg.c </span><span class="cov0" title="0">{
                ok, err := ctx.Matches(c)
                if err != nil </span><span class="cov0" title="0">{
                        return reflect.Value{}, err
                }</span> else<span class="cov0" title="0"> if !ok </span><span class="cov0" title="0">{
                        return reflect.Value{}, nil
                }</span>
        }

        // Calls the function and returns its result.
        <span class="cov0" title="0">out, err := arg.r.Call(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return reflect.Value{}, err
        }</span>
        <span class="cov0" title="0">return out[0], nil</span>
}

// Callable wraps a function and its binding arguments.
type Callable struct {
        fn       CallableFunc
        fnType   reflect.Type
        argList  *ArgList
        fileLine string
}

// MustBind binds arguments to a function and panics if an error occurs.
func MustBind(fn CallableFunc, args ...gs.Arg) *Callable <span class="cov6" title="3">{
        r, err := Bind(fn, args)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov6" title="3">_, file, line, _ := runtime.Caller(2)
        r.SetFileLine(file, line)
        return r</span>
}

// Bind creates a Callable by binding arguments to a function.
func Bind(fn CallableFunc, args []gs.Arg) (*Callable, error) <span class="cov6" title="3">{
        fnType := reflect.TypeOf(fn)
        argList, err := NewArgList(fnType, args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="3">return &amp;Callable{fn: fn, fnType: fnType, argList: argList}, nil</span>
}

// SetFileLine sets the file and line number of the function call.
func (r *Callable) SetFileLine(file string, line int) <span class="cov10" title="6">{
        r.fileLine = fmt.Sprintf("%s:%d", file, line)
}</span>

// Call invokes the function with its bound arguments processed in the IoC container.
func (r *Callable) Call(ctx gs.ArgContext) ([]reflect.Value, error) <span class="cov6" title="3">{
        in, err := r.argList.get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">out := reflect.ValueOf(r.fn).Call(in)
        n := len(out)
        if n == 0 </span><span class="cov0" title="0">{
                return out, nil
        }</span>

        <span class="cov6" title="3">o := out[n-1]
        if util.IsErrorType(o.Type()) </span><span class="cov0" title="0">{
                if i := o.Interface(); i != nil </span><span class="cov0" title="0">{
                        return out[:n-1], i.(error)
                }</span>
                <span class="cov0" title="0">return out[:n-1], nil</span>
        }
        <span class="cov6" title="3">return out, nil</span>
}

// GetArgValue retrieves the result of calling the function.
func (r *Callable) GetArgValue(ctx gs.ArgContext, t reflect.Type) (reflect.Value, error) <span class="cov0" title="0">{
        if results, err := r.Call(ctx); err != nil </span><span class="cov0" title="0">{
                return reflect.Value{}, err
        }</span> else<span class="cov0" title="0"> if len(results) &lt; 1 </span><span class="cov0" title="0">{
                return reflect.Value{}, errors.New("xxx")
        }</span> else<span class="cov0" title="0"> {
                return results[0], nil
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_bean

import (
        "fmt"
        "reflect"
        "runtime"
        "slices"
        "strings"

        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/gs/internal/gs_arg"
        "github.com/go-spring/spring-core/gs/internal/gs_cond"
        "github.com/go-spring/spring-core/util"
)

// BeanStatus represents the different lifecycle statuses of a bean.
type BeanStatus int8

const (
        StatusDeleted   = BeanStatus(-1)   // Bean has been deleted.
        StatusDefault   = BeanStatus(iota) // Default status of the bean.
        StatusResolving                    // Bean is being resolved.
        StatusResolved                     // Bean has been resolved.
        StatusCreating                     // Bean is being created.
        StatusCreated                      // Bean has been created.
        StatusWired                        // Bean has been wired.
)

// String returns a human-readable string of the bean status.
func (status BeanStatus) String() string <span class="cov0" title="0">{
        switch status </span>{
        case StatusDeleted:<span class="cov0" title="0">
                return "deleted"</span>
        case StatusDefault:<span class="cov0" title="0">
                return "default"</span>
        case StatusResolving:<span class="cov0" title="0">
                return "resolving"</span>
        case StatusResolved:<span class="cov0" title="0">
                return "resolved"</span>
        case StatusCreating:<span class="cov0" title="0">
                return "creating"</span>
        case StatusCreated:<span class="cov0" title="0">
                return "created"</span>
        case StatusWired:<span class="cov0" title="0">
                return "wired"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// refreshableType is the [reflect.Type] of the [gs.Refreshable] interface.
var refreshableType = reflect.TypeFor[gs.Refreshable]()

// BeanMetadata holds the metadata information of a bean.
type BeanMetadata struct {
        f          *gs_arg.Callable
        init       gs.BeanInitFunc
        destroy    gs.BeanDestroyFunc
        dependsOn  []gs.BeanSelector
        exports    []reflect.Type
        conditions []gs.Condition
        status     BeanStatus

        file string
        line int

        configurationBean  bool
        configurationParam gs.ConfigurationParam

        refreshable bool
        refreshTag  string
}

// validLifeCycleFunc checks whether the provided function is a valid lifecycle function.
func validLifeCycleFunc(fnType reflect.Type, beanType reflect.Type) bool <span class="cov2" title="3">{
        if !util.IsFuncType(fnType) || fnType.NumIn() != 1 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="3">if t := fnType.In(0); t.Kind() == reflect.Interface </span><span class="cov0" title="0">{
                if !beanType.Implements(t) </span><span class="cov0" title="0">{
                        return false
                }</span>
        } else<span class="cov2" title="3"> if t != beanType </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="3">return util.ReturnNothing(fnType) || util.ReturnOnlyError(fnType)</span>
}

// Init returns the initialization function of the bean.
func (d *BeanMetadata) Init() gs.BeanInitFunc <span class="cov5" title="13">{
        return d.init
}</span>

// Destroy returns the destruction function of the bean.
func (d *BeanMetadata) Destroy() gs.BeanDestroyFunc <span class="cov6" title="27">{
        return d.destroy
}</span>

// DependsOn returns the list of dependencies for the bean.
func (d *BeanMetadata) DependsOn() []gs.BeanSelector <span class="cov5" title="13">{
        return d.dependsOn
}</span>

// SetDependsOn sets the list of dependencies for the bean.
func (d *BeanMetadata) SetDependsOn(selectors ...gs.BeanSelector) <span class="cov0" title="0">{
        d.dependsOn = append(d.dependsOn, selectors...)
}</span>

// Exports returns the list of exported types for the bean.
func (d *BeanMetadata) Exports() []reflect.Type <span class="cov7" title="48">{
        return d.exports
}</span>

// Conditions returns the list of conditions for the bean.
func (d *BeanMetadata) Conditions() []gs.Condition <span class="cov5" title="13">{
        return d.conditions
}</span>

// SetCondition adds a condition to the list of conditions for the bean.
func (d *BeanMetadata) SetCondition(conditions ...gs.Condition) <span class="cov2" title="3">{
        d.conditions = append(d.conditions, conditions...)
}</span>

// ConfigurationBean returns whether the bean is a configuration bean.
func (d *BeanMetadata) ConfigurationBean() bool <span class="cov5" title="13">{
        return d.configurationBean
}</span>

// ConfigurationParam returns the configuration parameters for the bean.
func (d *BeanMetadata) ConfigurationParam() gs.ConfigurationParam <span class="cov0" title="0">{
        return d.configurationParam
}</span>

// SetConfiguration sets the configuration flag and parameters for the bean.
func (d *BeanDefinition) SetConfiguration(param ...gs.ConfigurationParam) <span class="cov0" title="0">{
        d.configurationBean = true
        if len(param) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">x := param[0]
        if len(x.Includes) &gt; 0 </span><span class="cov0" title="0">{
                d.configurationParam.Includes = x.Includes
        }</span>
        <span class="cov0" title="0">if len(x.Excludes) &gt; 0 </span><span class="cov0" title="0">{
                d.configurationParam.Excludes = x.Excludes
        }</span>
}

// Refreshable returns whether the bean is refreshable.
func (d *BeanMetadata) Refreshable() bool <span class="cov5" title="13">{
        return d.refreshable
}</span>

// RefreshTag returns the refresh tag of the bean.
func (d *BeanMetadata) RefreshTag() string <span class="cov0" title="0">{
        return d.refreshTag
}</span>

// SetCaller sets the caller for the bean.
func (d *BeanMetadata) SetCaller(skip int) <span class="cov0" title="0">{
        _, file, line, _ := runtime.Caller(skip)
        if d.f != nil </span><span class="cov0" title="0">{
                d.f.SetFileLine(file, line)
        }</span>
        <span class="cov0" title="0">d.file, d.line = file, line</span>
}

// FileLine returns the file and line number for the bean.
func (d *BeanMetadata) FileLine() (string, int) <span class="cov0" title="0">{
        return d.file, d.line
}</span>

// SetFileLine sets the file and line number for the bean.
func (d *BeanMetadata) SetFileLine(file string, line int) <span class="cov5" title="13">{
        d.file, d.line = file, line
}</span>

// BeanRuntime holds runtime information about the bean.
type BeanRuntime struct {
        v    reflect.Value // The value of the bean.
        t    reflect.Type  // The type of the bean.
        name string        // The name of the bean.
}

// Name returns the name of the bean.
func (d *BeanRuntime) Name() string <span class="cov8" title="85">{
        return d.name
}</span>

// Type returns the type of the bean.
func (d *BeanRuntime) Type() reflect.Type <span class="cov8" title="81">{
        return d.t
}</span>

// Value returns the value of the bean as [reflect.Value].
func (d *BeanRuntime) Value() reflect.Value <span class="cov6" title="33">{
        return d.v
}</span>

// Interface returns the underlying value of the bean.
func (d *BeanRuntime) Interface() interface{} <span class="cov0" title="0">{
        return d.v.Interface()
}</span>

// Callable returns the callable for the bean.
func (d *BeanRuntime) Callable() *gs_arg.Callable <span class="cov0" title="0">{
        return nil
}</span>

// Status returns the current status of the bean.
func (d *BeanRuntime) Status() BeanStatus <span class="cov0" title="0">{
        return StatusWired
}</span>

// String returns a string representation of the bean.
func (d *BeanRuntime) String() string <span class="cov0" title="0">{
        return d.name
}</span>

// BeanDefinition contains both metadata and runtime information of a bean.
type BeanDefinition struct {
        *BeanMetadata
        *BeanRuntime
}

// NewBean creates a new bean definition.
func NewBean(t reflect.Type, v reflect.Value, f *gs_arg.Callable, name string) *BeanDefinition <span class="cov5" title="13">{
        return &amp;BeanDefinition{
                BeanMetadata: &amp;BeanMetadata{
                        f:      f,
                        status: StatusDefault,
                },
                BeanRuntime: &amp;BeanRuntime{
                        t:    t,
                        v:    v,
                        name: name,
                },
        }
}</span>

// SetMock sets the mock object for the bean, replacing its runtime information.
func (d *BeanDefinition) SetMock(obj interface{}) <span class="cov0" title="0">{
        *d = BeanDefinition{
                BeanMetadata: &amp;BeanMetadata{
                        exports: d.exports,
                },
                BeanRuntime: &amp;BeanRuntime{
                        t:    reflect.TypeOf(obj),
                        v:    reflect.ValueOf(obj),
                        name: d.name,
                },
        }
}</span>

// Callable returns the callable for the bean.
func (d *BeanDefinition) Callable() *gs_arg.Callable <span class="cov5" title="16">{
        return d.f
}</span>

// SetName sets the name of the bean.
func (d *BeanDefinition) SetName(name string) <span class="cov2" title="3">{
        d.name = name
}</span>

// Status returns the current status of the bean.
func (d *BeanDefinition) Status() BeanStatus <span class="cov10" title="225">{
        return d.status
}</span>

// SetStatus sets the current status of the bean.
func (d *BeanDefinition) SetStatus(status BeanStatus) <span class="cov7" title="65">{
        d.status = status
}</span>

// SetInit sets the initialization function for the bean.
func (d *BeanDefinition) SetInit(fn gs.BeanInitFunc) <span class="cov0" title="0">{
        if validLifeCycleFunc(reflect.TypeOf(fn), d.Type()) </span><span class="cov0" title="0">{
                d.init = fn
                return
        }</span>
        <span class="cov0" title="0">panic("init should be func(bean) or func(bean)error")</span>
}

// SetDestroy sets the destruction function for the bean.
func (d *BeanDefinition) SetDestroy(fn gs.BeanDestroyFunc) <span class="cov2" title="3">{
        if validLifeCycleFunc(reflect.TypeOf(fn), d.Type()) </span><span class="cov2" title="3">{
                d.destroy = fn
                return
        }</span>
        <span class="cov0" title="0">panic("destroy should be func(bean) or func(bean)error")</span>
}

// SetInitMethod sets the initialization function for the bean by method name.
func (d *BeanDefinition) SetInitMethod(method string) <span class="cov0" title="0">{
        m, ok := d.t.MethodByName(method)
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("method %s not found on type %s", method, d.t))</span>
        }
        <span class="cov0" title="0">d.SetInit(m.Func.Interface())</span>
}

// SetDestroyMethod sets the destruction function for the bean by method name.
func (d *BeanDefinition) SetDestroyMethod(method string) <span class="cov0" title="0">{
        m, ok := d.t.MethodByName(method)
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("method %s not found on type %s", method, d.t))</span>
        }
        <span class="cov0" title="0">d.SetDestroy(m.Func.Interface())</span>
}

// SetExport sets the exported interfaces for the bean.
func (d *BeanDefinition) SetExport(exports ...reflect.Type) <span class="cov3" title="5">{
        for _, t := range exports </span><span class="cov3" title="5">{
                if t.Kind() != reflect.Interface </span><span class="cov0" title="0">{
                        panic("only interface type can be exported")</span>
                }
                <span class="cov3" title="5">exported := false
                for _, export := range d.exports </span><span class="cov0" title="0">{
                        if t == export </span><span class="cov0" title="0">{
                                exported = true
                                break</span>
                        }
                }
                <span class="cov3" title="5">if exported </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov3" title="5">d.exports = append(d.exports, t)</span>
        }
}

// SetRefreshable sets the refreshable flag and tag for the bean.
func (d *BeanDefinition) SetRefreshable(tag string) <span class="cov0" title="0">{
        if !d.Type().Implements(refreshableType) </span><span class="cov0" title="0">{
                panic("must implement gs.Refreshable interface")</span>
        }
        <span class="cov0" title="0">d.refreshable = true
        d.refreshTag = tag</span>
}

// OnProfiles sets the conditions for the bean based on the active profiles.
func (d *BeanDefinition) OnProfiles(profiles string) <span class="cov1" title="1">{
        c := gs_cond.OnFunc(func(ctx gs.CondContext) (bool, error) </span><span class="cov1" title="1">{
                val := strings.TrimSpace(ctx.Prop("spring.profiles.active"))
                if val == "" </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov1" title="1">ss := strings.Split(strings.TrimSpace(profiles), ",")
                for s := range slices.Values(strings.Split(val, ",")) </span><span class="cov1" title="1">{
                        for _, x := range ss </span><span class="cov1" title="1">{
                                if s == x </span><span class="cov1" title="1">{
                                        return true, nil
                                }</span>
                        }
                }
                <span class="cov0" title="0">return false, nil</span>
        })
        <span class="cov1" title="1">d.conditions = append(d.conditions, c)</span>
}

// TypeAndName returns the type and name of the bean.
func (d *BeanDefinition) TypeAndName() (reflect.Type, string) <span class="cov0" title="0">{
        return d.Type(), d.Name()
}</span>

// String returns a string representation of the bean.
func (d *BeanDefinition) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("name:%q %s:%d", d.name, d.file, d.line)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_cond

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/util"
        "github.com/go-spring/spring-core/util/errutil"
)

/********************************* OnFunc ************************************/

// onFunc is an implementation of [gs.Condition] that wraps a function.
// It allows a condition to be evaluated based on the result of a function.
type onFunc struct {
        fn gs.CondFunc
}

// OnFunc creates a Conditional that evaluates using a custom function.
func OnFunc(fn gs.CondFunc) gs.Condition <span class="cov1" title="1">{
        return &amp;onFunc{fn: fn}
}</span>

// Matches checks if the condition is met according to the provided context.
func (c *onFunc) Matches(ctx gs.CondContext) (bool, error) <span class="cov1" title="1">{
        ok, err := c.fn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return false, errutil.WrapError(err, "condition matches error: %s", c)
        }</span>
        <span class="cov1" title="1">return ok, nil</span>
}

func (c *onFunc) String() string <span class="cov0" title="0">{
        _, _, fnName := util.FileLine(c.fn)
        return fmt.Sprintf("OnFunc(fn=%s)", fnName)
}</span>

/******************************* OnProperty **********************************/

// OnPropertyInterface defines the methods for evaluating a condition based on a property.
// This interface provides flexibility for matching missing properties and checking their values.
type OnPropertyInterface interface {
        gs.Condition
        MatchIfMissing() OnPropertyInterface
        HavingValue(s string) OnPropertyInterface
}

// onProperty evaluates a condition based on the existence and value of a property
// in the context. It allows for complex matching behaviors such as matching missing
// properties or evaluating expressions.
type onProperty struct {
        name           string // The name of the property to check.
        havingValue    string // The expected value or expression to match.
        matchIfMissing bool   // Whether to match if the property is missing.
}

// OnProperty creates a condition based on the presence and value of a specified property.
func OnProperty(name string) OnPropertyInterface <span class="cov10" title="2">{
        return &amp;onProperty{name: name}
}</span>

// MatchIfMissing sets the condition to match if the property is missing.
func (c *onProperty) MatchIfMissing() OnPropertyInterface <span class="cov1" title="1">{
        c.matchIfMissing = true
        return c
}</span>

// HavingValue sets the expected value or expression to match.
func (c *onProperty) HavingValue(s string) OnPropertyInterface <span class="cov10" title="2">{
        c.havingValue = s
        return c
}</span>

// Matches checks if the condition is met according to the provided context.
func (c *onProperty) Matches(ctx gs.CondContext) (bool, error) <span class="cov10" title="2">{

        // If the context doesn't have the property, handle accordingly.
        if !ctx.Has(c.name) </span><span class="cov1" title="1">{
                return c.matchIfMissing, nil
        }</span>

        // If there's no expected value to match, simply return true (property exists).
        <span class="cov1" title="1">if c.havingValue == "" </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        // Retrieve the property's value and compare it with the expected value.
        <span class="cov1" title="1">val := ctx.Prop(c.name)
        if !strings.HasPrefix(c.havingValue, "expr:") </span><span class="cov1" title="1">{
                return val == c.havingValue, nil
        }</span>

        <span class="cov0" title="0">getValue := func(val string) interface{} </span><span class="cov0" title="0">{
                if b, err := strconv.ParseBool(val); err == nil </span><span class="cov0" title="0">{
                        return b
                }</span>
                <span class="cov0" title="0">if i, err := strconv.ParseInt(val, 10, 64); err == nil </span><span class="cov0" title="0">{
                        return i
                }</span>
                <span class="cov0" title="0">if u, err := strconv.ParseUint(val, 10, 64); err == nil </span><span class="cov0" title="0">{
                        return u
                }</span>
                <span class="cov0" title="0">if f, err := strconv.ParseFloat(val, 64); err == nil </span><span class="cov0" title="0">{
                        return f
                }</span>
                <span class="cov0" title="0">return val</span>
        }

        // Evaluate the expression and return the result.
        <span class="cov0" title="0">ok, err := EvalExpr(c.havingValue[5:], getValue(val))
        if err != nil </span><span class="cov0" title="0">{
                return false, errutil.WrapError(err, "condition matches error: %s", c)
        }</span>
        <span class="cov0" title="0">return ok, nil</span>
}

func (c *onProperty) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString("OnProperty(name=")
        sb.WriteString(c.name)
        if c.havingValue != "" </span><span class="cov0" title="0">{
                sb.WriteString(", havingValue=")
                sb.WriteString(c.havingValue)
        }</span>
        <span class="cov0" title="0">if c.matchIfMissing </span><span class="cov0" title="0">{
                sb.WriteString(", matchIfMissing=true")
        }</span>
        <span class="cov0" title="0">sb.WriteString(")")
        return sb.String()</span>
}

/*************************** OnMissingProperty *******************************/

// onMissingProperty is a condition that matches when a specified property is
// absent from the context.
type onMissingProperty struct {
        name string // The name of the property to check for absence.
}

// OnMissingProperty creates a condition that matches if the specified property is missing.
func OnMissingProperty(name string) gs.Condition <span class="cov0" title="0">{
        return &amp;onMissingProperty{name: name}
}</span>

// Matches checks if the condition is met according to the provided context.
func (c *onMissingProperty) Matches(ctx gs.CondContext) (bool, error) <span class="cov0" title="0">{
        return !ctx.Has(c.name), nil
}</span>

func (c *onMissingProperty) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("OnMissingProperty(name=%s)", c.name)
}</span>

/********************************* OnBean ************************************/

// onBean checks for the existence of beans that match a selector.
// It returns true if at least one bean matches the selector, and false otherwise.
type onBean struct {
        s gs.BeanSelector // The selector used to match beans in the context.
}

// OnBean creates a condition that evaluates to true if at least one bean
// matches the specified type and name.
func OnBean[T any](name ...string) gs.Condition <span class="cov1" title="1">{
        return &amp;onBean{s: gs.BeanSelectorFor[T](name...)}
}</span>

// OnBeanSelector creates a condition that evaluates to true if at least one
// bean matches the provided selector.
func OnBeanSelector(s gs.BeanSelector) gs.Condition <span class="cov0" title="0">{
        return &amp;onBean{s: s}
}</span>

// Matches checks if the condition is met according to the provided context.
func (c *onBean) Matches(ctx gs.CondContext) (bool, error) <span class="cov1" title="1">{
        beans, err := ctx.Find(c.s)
        if err != nil </span><span class="cov0" title="0">{
                return false, errutil.WrapError(err, "condition matches error: %s", c)
        }</span>
        <span class="cov1" title="1">return len(beans) &gt; 0, nil</span>
}

func (c *onBean) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("OnBean(selector=%s)", c.s)
}</span>

/***************************** OnMissingBean *********************************/

// onMissingBean checks for the absence of beans matching a selector.
// It returns true if no beans match the selector, and false otherwise.
type onMissingBean struct {
        s gs.BeanSelector // The selector used to find beans.
}

// OnMissingBean creates a condition that evaluates to true if no beans match
// the specified type and name.
func OnMissingBean[T any](name ...string) gs.Condition <span class="cov0" title="0">{
        return &amp;onMissingBean{s: gs.BeanSelectorFor[T](name...)}
}</span>

// OnMissingBeanSelector creates a condition that evaluates to true if no beans
// match the provided selector.
func OnMissingBeanSelector(s gs.BeanSelector) gs.Condition <span class="cov0" title="0">{
        return &amp;onMissingBean{s: s}
}</span>

// Matches checks if the condition is met according to the provided context.
func (c *onMissingBean) Matches(ctx gs.CondContext) (bool, error) <span class="cov0" title="0">{
        beans, err := ctx.Find(c.s)
        if err != nil </span><span class="cov0" title="0">{
                return false, errutil.WrapError(err, "condition matches error: %s", c)
        }</span>
        <span class="cov0" title="0">return len(beans) == 0, nil</span>
}

func (c *onMissingBean) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("OnMissingBean(selector=%s)", c.s)
}</span>

/***************************** OnSingleBean **********************************/

// onSingleBean checks if exactly one matching bean exists in the context.
// It returns true if exactly one bean matches the selector, and false otherwise.
type onSingleBean struct {
        s gs.BeanSelector // The selector used to find beans.
}

// OnSingleBean creates a condition that evaluates to true if exactly one bean
// matches the specified type and name.
func OnSingleBean[T any](name ...string) gs.Condition <span class="cov0" title="0">{
        return &amp;onSingleBean{s: gs.BeanSelectorFor[T](name...)}
}</span>

// OnSingleBeanSelector creates a condition that evaluates to true if exactly
// one bean matches the provided selector.
func OnSingleBeanSelector(s gs.BeanSelector) gs.Condition <span class="cov0" title="0">{
        return &amp;onSingleBean{s: s}
}</span>

// Matches checks if the condition is met according to the provided context.
func (c *onSingleBean) Matches(ctx gs.CondContext) (bool, error) <span class="cov0" title="0">{
        beans, err := ctx.Find(c.s)
        if err != nil </span><span class="cov0" title="0">{
                return false, errutil.WrapError(err, "condition matches error: %s", c)
        }</span>
        <span class="cov0" title="0">return len(beans) == 1, nil</span>
}

func (c *onSingleBean) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("OnSingleBean(selector=%s)", c.s)
}</span>

/***************************** OnExpression **********************************/

// onExpression evaluates a custom expression within the context. The expression should
// return true or false, and the evaluation is expected to happen within the context.
type onExpression struct {
        expression string // The string expression to evaluate.
}

// OnExpression creates a condition that evaluates based on a custom string expression.
// The expression is expected to return true or false.
func OnExpression(expression string) gs.Condition <span class="cov0" title="0">{
        return &amp;onExpression{expression: expression}
}</span>

// Matches checks if the condition is met according to the provided context.
func (c *onExpression) Matches(ctx gs.CondContext) (bool, error) <span class="cov0" title="0">{
        err := util.UnimplementedMethod
        return false, errutil.WrapError(err, "condition matches error: %s", c)
}</span>

func (c *onExpression) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("OnExpression(expression=%s)", c.expression)
}</span>

/********************************** Not ***************************************/

// onNot is a condition that negates another condition. It returns true if the wrapped
// condition evaluates to false, and false if the wrapped condition evaluates to true.
type onNot struct {
        c gs.Condition // The condition to negate.
}

// Not creates a condition that inverts the result of the provided condition.
func Not(c gs.Condition) gs.Condition <span class="cov0" title="0">{
        return &amp;onNot{c: c}
}</span>

// Matches checks if the condition is met according to the provided context.
func (c *onNot) Matches(ctx gs.CondContext) (bool, error) <span class="cov0" title="0">{
        ok, err := c.c.Matches(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return false, errutil.WrapError(err, "condition matches error: %s", c)
        }</span>
        <span class="cov0" title="0">return !ok, nil</span>
}

func (c *onNot) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Not(%s)", c.c)
}</span>

/********************************** Or ***************************************/

// onOr is a condition that combines multiple conditions with an OR operator.
// It evaluates to true if at least one condition is satisfied.
type onOr struct {
        conditions []gs.Condition // The list of conditions to evaluate with OR.
}

// Or combines multiple conditions with an OR operator, returning true if at
// least one condition is satisfied.
func Or(conditions ...gs.Condition) gs.Condition <span class="cov0" title="0">{
        if n := len(conditions); n == 0 </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> if n == 1 </span><span class="cov0" title="0">{
                return conditions[0]
        }</span>
        <span class="cov0" title="0">return &amp;onOr{conditions: conditions}</span>
}

// Matches checks if the condition is met according to the provided context.
func (g *onOr) Matches(ctx gs.CondContext) (bool, error) <span class="cov0" title="0">{
        for _, c := range g.conditions </span><span class="cov0" title="0">{
                if ok, err := c.Matches(ctx); err != nil </span><span class="cov0" title="0">{
                        return false, errutil.WrapError(err, "condition matches error: %s", g)
                }</span> else<span class="cov0" title="0"> if ok </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

func (g *onOr) String() string <span class="cov0" title="0">{
        return FormatGroup("Or", g.conditions)
}</span>

/********************************* And ***************************************/

// onAnd is a condition that combines multiple conditions with an AND operator.
// It evaluates to true only if all conditions are satisfied.
type onAnd struct {
        conditions []gs.Condition // The list of conditions to evaluate with AND.
}

// And combines multiple conditions with an AND operator, returning true if
// all conditions are satisfied.
func And(conditions ...gs.Condition) gs.Condition <span class="cov0" title="0">{
        if n := len(conditions); n == 0 </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> if n == 1 </span><span class="cov0" title="0">{
                return conditions[0]
        }</span>
        <span class="cov0" title="0">return &amp;onAnd{conditions: conditions}</span>
}

// Matches checks if the condition is met according to the provided context.
func (g *onAnd) Matches(ctx gs.CondContext) (bool, error) <span class="cov0" title="0">{
        for _, c := range g.conditions </span><span class="cov0" title="0">{
                ok, err := c.Matches(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return false, errutil.WrapError(err, "condition matches error: %s", g)
                }</span> else<span class="cov0" title="0"> if !ok </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

func (g *onAnd) String() string <span class="cov0" title="0">{
        return FormatGroup("And", g.conditions)
}</span>

/********************************** None *************************************/

// onNone is a condition that combines multiple conditions with a NONE operator.
// It evaluates to true only if none of the conditions are satisfied.
type onNone struct {
        conditions []gs.Condition // The list of conditions to evaluate with NONE.
}

// None combines multiple conditions with a NONE operator, returning true if
// none of the conditions are satisfied.
func None(conditions ...gs.Condition) gs.Condition <span class="cov0" title="0">{
        if n := len(conditions); n == 0 </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> if n == 1 </span><span class="cov0" title="0">{
                return Not(conditions[0])
        }</span>
        <span class="cov0" title="0">return &amp;onNone{conditions: conditions}</span>
}

// Matches checks if the condition is met according to the provided context.
func (g *onNone) Matches(ctx gs.CondContext) (bool, error) <span class="cov0" title="0">{
        for _, c := range g.conditions </span><span class="cov0" title="0">{
                if ok, err := c.Matches(ctx); err != nil </span><span class="cov0" title="0">{
                        return false, errutil.WrapError(err, "condition matches error: %s", g)
                }</span> else<span class="cov0" title="0"> if ok </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

func (g *onNone) String() string <span class="cov0" title="0">{
        return FormatGroup("None", g.conditions)
}</span>

/******************************* utilities ***********************************/

// FormatGroup generates a formatted string for a group of conditions (AND, OR, NONE).
func FormatGroup(op string, conditions []gs.Condition) string <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString(op)
        sb.WriteString("(")
        for i, c := range conditions </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        sb.WriteString(", ")
                }</span>
                <span class="cov0" title="0">sb.WriteString(fmt.Sprint(c))</span>
        }
        <span class="cov0" title="0">sb.WriteString(")")
        return sb.String()</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_cond

import (
        "fmt"

        "github.com/expr-lang/expr"
)

// funcMap holds a map of function names to their implementations.
// These functions can be used within expressions passed to EvalExpr.
var funcMap = map[string]interface{}{}

// RegisterExpressFunc registers an express function with a specified name.
// The function can later be used in expressions evaluated by EvalExpr.
func RegisterExpressFunc(name string, fn interface{}) <span class="cov0" title="0">{
        funcMap[name] = fn
}</span>

// EvalExpr evaluates a given boolean expression (input) using the provided value (val).
// The `input` parameter is a string that represents an expression expected to return a
// boolean value. The `val` parameter is the data object that will be referred to as "$"
// within the expression context.
func EvalExpr(input string, val interface{}) (bool, error) <span class="cov0" title="0">{
        env := map[string]interface{}{"$": val}
        for k, v := range funcMap </span><span class="cov0" title="0">{
                env[k] = v
        }</span>
        <span class="cov0" title="0">r, err := expr.Eval(input, env)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("eval %q returns error, %w", input, err)
        }</span>
        <span class="cov0" title="0">ret, ok := r.(bool)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("eval %q doesn't return bool value", input)
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_conf

import (
        "fmt"
        "os"
        "strings"

        "github.com/go-spring/spring-core/conf"
)

// CommandArgsPrefix defines the environment variable name used to override
// the default option prefix. This allows users to customize the prefix used
// for command-line options if needed.
const CommandArgsPrefix = "GS_ARGS_PREFIX"

// CommandArgs represents a structure for handling command-line parameters.
type CommandArgs struct{}

// NewCommandArgs creates and returns a new CommandArgs instance.
func NewCommandArgs() *CommandArgs <span class="cov5" title="2">{
        return &amp;CommandArgs{}
}</span>

// CopyTo processes command-line parameters and sets them as key-value pairs
// in the provided conf.Properties. Parameters should be passed in the form
// of `-D key[=value/true]`.
func (c *CommandArgs) CopyTo(out *conf.Properties) error <span class="cov10" title="4">{
        if len(os.Args) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Default option prefix is "-D", but it can be overridden by the
        // environment variable `GS_ARGS_PREFIX`.
        <span class="cov10" title="4">option := "-D"
        if s := strings.TrimSpace(os.Getenv(CommandArgsPrefix)); s != "" </span><span class="cov0" title="0">{
                option = s
        }</span>

        <span class="cov10" title="4">cmdArgs := os.Args[1:]
        n := len(cmdArgs)
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                if cmdArgs[i] == option </span><span class="cov0" title="0">{
                        if i+1 &gt;= n </span><span class="cov0" title="0">{
                                return fmt.Errorf("cmd option %s needs arg", option)
                        }</span>
                        <span class="cov0" title="0">next := cmdArgs[i+1]
                        ss := strings.SplitN(next, "=", 2)
                        if len(ss) == 1 </span><span class="cov0" title="0">{
                                ss = append(ss, "true")
                        }</span>
                        <span class="cov0" title="0">if err := out.Set(ss[0], ss[1]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov10" title="4">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_conf

import (
        "fmt"
        "os"
        "strings"

        "github.com/go-spring/spring-core/conf"
        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/util/sysconf"
)

/******************************** AppConfig **********************************/

// AppConfig represents a layered application configuration.
type AppConfig struct {
        LocalFile   *PropertySources // Configuration sources from local files.
        RemoteFile  *PropertySources // Configuration sources from remote files.
        RemoteProp  gs.Properties    // Remote properties.
        Environment *Environment     // Environment variables as configuration source.
        CommandArgs *CommandArgs     // Command line arguments as configuration source.
}

// NewAppConfig creates a new instance of AppConfig.
func NewAppConfig() *AppConfig <span class="cov1" title="1">{
        return &amp;AppConfig{
                LocalFile:   NewPropertySources(ConfigTypeLocal, "app"),
                RemoteFile:  NewPropertySources(ConfigTypeRemote, "app"),
                Environment: NewEnvironment(),
                CommandArgs: NewCommandArgs(),
        }
}</span>

func merge(out *conf.Properties, sources ...interface {
        CopyTo(out *conf.Properties) error
}) error <span class="cov4" title="4">{
        for _, s := range sources </span><span class="cov7" title="10">{
                if s != nil </span><span class="cov7" title="9">{
                        if err := s.CopyTo(out); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov4" title="4">return nil</span>
}

// Refresh merges all layers of configurations into a read-only properties.
func (c *AppConfig) Refresh() (gs.Properties, error) <span class="cov1" title="1">{
        p := sysconf.Clone()
        err := merge(p, c.Environment, c.CommandArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">localFiles, err := c.LocalFile.loadFiles(p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">remoteFiles, err := c.RemoteFile.loadFiles(p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">var sources []interface {
                CopyTo(out *conf.Properties) error
        }
        for _, file := range localFiles </span><span class="cov1" title="1">{
                sources = append(sources, file)
        }</span>
        <span class="cov1" title="1">for _, file := range remoteFiles </span><span class="cov0" title="0">{
                sources = append(sources, file)
        }</span>
        <span class="cov1" title="1">sources = append(sources, c.RemoteProp)
        sources = append(sources, c.Environment)
        sources = append(sources, c.CommandArgs)

        p = sysconf.Clone()
        err = merge(p, sources...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return p, nil</span>
}

/******************************** BootConfig *********************************/

// BootConfig represents a layered boot configuration.
type BootConfig struct {
        LocalFile   *PropertySources // Configuration sources from local files.
        Environment *Environment     // Environment variables as configuration source.
        CommandArgs *CommandArgs     // Command line arguments as configuration source.
}

// NewBootConfig creates a new instance of BootConfig.
func NewBootConfig() *BootConfig <span class="cov1" title="1">{
        return &amp;BootConfig{
                LocalFile:   NewPropertySources(ConfigTypeLocal, "boot"),
                Environment: NewEnvironment(),
                CommandArgs: NewCommandArgs(),
        }
}</span>

// Refresh merges all layers of configurations into a read-only properties.
func (c *BootConfig) Refresh() (gs.Properties, error) <span class="cov1" title="1">{

        p := sysconf.Clone()
        err := merge(p, c.Environment, c.CommandArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">localFiles, err := c.LocalFile.loadFiles(p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">var sources []interface {
                CopyTo(out *conf.Properties) error
        }
        for _, file := range localFiles </span><span class="cov0" title="0">{
                sources = append(sources, file)
        }</span>
        <span class="cov1" title="1">sources = append(sources, c.Environment)
        sources = append(sources, c.CommandArgs)

        p = sysconf.Clone()
        err = merge(p, sources...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return p, nil</span>
}

/****************************** PropertySources ******************************/

// ConfigType defines the type of configuration: local or remote.
type ConfigType string

const (
        ConfigTypeLocal  ConfigType = "local"
        ConfigTypeRemote ConfigType = "remote"
)

// PropertySources is a collection of configuration files.
type PropertySources struct {
        configType ConfigType // Type of the configuration (local or remote).
        configName string     // Name of the configuration.
        extraDirs  []string   // Extra directories to be included in the configuration.
        extraFiles []string   // Extra files to be included in the configuration.
}

// NewPropertySources creates a new instance of PropertySources.
func NewPropertySources(configType ConfigType, configName string) *PropertySources <span class="cov4" title="3">{
        return &amp;PropertySources{
                configType: configType,
                configName: configName,
        }
}</span>

// Reset resets all the extra files.
func (p *PropertySources) Reset() <span class="cov0" title="0">{
        p.extraFiles = nil
}</span>

// AddDir adds a or more than one extra directories.
func (p *PropertySources) AddDir(dirs ...string) <span class="cov0" title="0">{
        for _, d := range dirs </span><span class="cov0" title="0">{
                info, err := os.Stat(d)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        panic("should be a directory")</span>
                }
        }
        <span class="cov0" title="0">p.extraDirs = append(p.extraDirs, dirs...)</span>
}

// AddFile adds a or more than one extra files.
func (p *PropertySources) AddFile(files ...string) <span class="cov0" title="0">{
        for _, f := range files </span><span class="cov0" title="0">{
                info, err := os.Stat(f)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        panic("should be a file")</span>
                }
        }
        <span class="cov0" title="0">p.extraFiles = append(p.extraFiles, files...)</span>
}

// getDefaultDir returns the default configuration directory based on the configuration type.
func (p *PropertySources) getDefaultDir(resolver *conf.Properties) (configDir string, err error) <span class="cov4" title="3">{
        if p.configType == ConfigTypeLocal </span><span class="cov2" title="2">{
                return resolver.Resolve("${spring.app.config.dir:=./conf}")
        }</span> else<span class="cov1" title="1"> if p.configType == ConfigTypeRemote </span><span class="cov1" title="1">{
                return resolver.Resolve("${spring.cloud.config.dir:=./conf/remote}")
        }</span> else<span class="cov0" title="0"> {
                return "", fmt.Errorf("unknown config type: %s", p.configType)
        }</span>
}

// getFiles returns the list of configuration files based on the configuration directory and active profiles.
func (p *PropertySources) getFiles(dir string, resolver *conf.Properties) (_ []string, err error) <span class="cov4" title="3">{

        files := []string{
                fmt.Sprintf("%s/%s.properties", dir, p.configName),
                fmt.Sprintf("%s/%s.yaml", dir, p.configName),
                fmt.Sprintf("%s/%s.toml", dir, p.configName),
                fmt.Sprintf("%s/%s.json", dir, p.configName),
        }

        activeProfiles, err := resolver.Resolve("${spring.profiles.active:=}")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="3">if activeProfiles = strings.TrimSpace(activeProfiles); activeProfiles != "" </span><span class="cov4" title="3">{
                ss := strings.Split(activeProfiles, ",")
                for _, s := range ss </span><span class="cov4" title="3">{
                        if s = strings.TrimSpace(s); s != "" </span><span class="cov4" title="3">{
                                files = append(files, []string{
                                        fmt.Sprintf("%s/%s-%s.properties", dir, p.configName, s),
                                        fmt.Sprintf("%s/%s-%s.yaml", dir, p.configName, s),
                                        fmt.Sprintf("%s/%s-%s.toml", dir, p.configName, s),
                                        fmt.Sprintf("%s/%s-%s.json", dir, p.configName, s),
                                }...)
                        }</span>
                }
        }
        <span class="cov4" title="3">return files, nil</span>
}

// loadFiles loads all configuration files and returns them as a list of Properties.
func (p *PropertySources) loadFiles(resolver *conf.Properties) ([]*conf.Properties, error) <span class="cov4" title="3">{
        var files []string
        </span><span class="cov4" title="3">{
                defaultDir, err := p.getDefaultDir(resolver)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov4" title="3">tempFiles, err := p.getFiles(defaultDir, resolver)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov4" title="3">files = append(files, tempFiles...)</span>
        }

        <span class="cov4" title="3">for _, dir := range p.extraDirs </span><span class="cov0" title="0">{
                tempFiles, err := p.getFiles(dir, resolver)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">files = append(files, tempFiles...)</span>
        }
        <span class="cov4" title="3">files = append(files, p.extraFiles...)

        var ret []*conf.Properties
        for _, s := range files </span><span class="cov10" title="24">{
                filename, err := resolver.Resolve(s)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov10" title="24">c, err := conf.Load(filename)
                if err != nil </span><span class="cov9" title="23">{
                        if os.IsNotExist(err) </span><span class="cov9" title="23">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov1" title="1">ret = append(ret, c)</span>
        }
        <span class="cov4" title="3">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_conf

import (
        "os"
        "regexp"
        "strings"

        "github.com/go-spring/spring-core/conf"
)

const (
        EnvironmentPrefix  = "GS_ENVS_PREFIX"
        IncludeEnvPatterns = "INCLUDE_ENV_PATTERNS"
        ExcludeEnvPatterns = "EXCLUDE_ENV_PATTERNS"
)

// Environment represents the environment configuration.
type Environment struct{}

// NewEnvironment initializes a new instance of Environment.
func NewEnvironment() *Environment <span class="cov1" title="2">{
        return &amp;Environment{}
}</span>

// lookupEnv searches for an environment variable by key in the environ slice.
func lookupEnv(environ []string, key string) (value string, found bool) <span class="cov3" title="8">{
        key = strings.TrimSpace(key) + "="
        for _, s := range environ </span><span class="cov8" title="296">{
                if strings.HasPrefix(s, key) </span><span class="cov0" title="0">{
                        v := strings.TrimPrefix(s, key)
                        return strings.TrimSpace(v), true
                }</span>
        }
        <span class="cov3" title="8">return "", false</span>
}

// CopyTo add environment variables that matches IncludeEnvPatterns and
// exclude environment variables that matches ExcludeEnvPatterns.
func (c *Environment) CopyTo(p *conf.Properties) error <span class="cov2" title="4">{
        environ := os.Environ()
        if len(environ) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov2" title="4">prefix := "GS_"
        if s := strings.TrimSpace(os.Getenv(EnvironmentPrefix)); s != "" </span><span class="cov0" title="0">{
                prefix = s
        }</span>

        <span class="cov2" title="4">toRex := func(patterns []string) ([]*regexp.Regexp, error) </span><span class="cov3" title="8">{
                var rex []*regexp.Regexp
                for _, v := range patterns </span><span class="cov2" title="4">{
                        exp, err := regexp.Compile(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov2" title="4">rex = append(rex, exp)</span>
                }
                <span class="cov3" title="8">return rex, nil</span>
        }

        <span class="cov2" title="4">includes := []string{".*"}
        if s, ok := lookupEnv(environ, IncludeEnvPatterns); ok </span><span class="cov0" title="0">{
                includes = strings.Split(s, ",")
        }</span>
        <span class="cov2" title="4">includeRex, err := toRex(includes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="4">var excludes []string
        if s, ok := lookupEnv(environ, ExcludeEnvPatterns); ok </span><span class="cov0" title="0">{
                excludes = strings.Split(s, ",")
        }</span>
        <span class="cov2" title="4">excludeRex, err := toRex(excludes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="4">matches := func(rex []*regexp.Regexp, s string) bool </span><span class="cov8" title="296">{
                for _, r := range rex </span><span class="cov7" title="148">{
                        if r.MatchString(s) </span><span class="cov7" title="148">{
                                return true
                        }</span>
                }
                <span class="cov7" title="148">return false</span>
        }

        <span class="cov2" title="4">for _, env := range environ </span><span class="cov7" title="148">{
                ss := strings.SplitN(env, "=", 2)
                k, v := ss[0], ""
                if len(ss) &gt; 1 </span><span class="cov7" title="148">{
                        v = ss[1]
                }</span>

                <span class="cov7" title="148">var propKey string
                if strings.HasPrefix(k, prefix) </span><span class="cov0" title="0">{
                        propKey = strings.TrimPrefix(k, prefix)
                }</span> else<span class="cov7" title="148"> if matches(includeRex, k) &amp;&amp; !matches(excludeRex, k) </span><span class="cov7" title="148">{
                        propKey = k
                }</span> else<span class="cov0" title="0"> {
                        continue</span>
                }

                <span class="cov7" title="148">propKey = strings.ToLower(replaceKey(propKey))
                if err = p.Set(propKey, v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov2" title="4">return nil</span>
}

// replaceKey replace '_' with '.'
func replaceKey(s string) string <span class="cov7" title="148">{
        var b strings.Builder

        right := len(s) - 1
        for </span><span class="cov7" title="148">{
                if s[right] != '_' </span><span class="cov7" title="148">{
                        break</span>
                }
                <span class="cov0" title="0">right--</span>
        }

        <span class="cov7" title="148">left := 0
        for </span><span class="cov7" title="164">{
                if s[left] != '_' </span><span class="cov7" title="148">{
                        break</span>
                }
                <span class="cov4" title="16">b.WriteByte('_')
                left++</span>
        }

        <span class="cov7" title="148">for i := left; i &lt;= right; i++ </span><span class="cov10" title="1464">{
                if s[i] == '_' </span><span class="cov6" title="96">{
                        b.WriteByte('.')
                        continue</span>
                }
                <span class="cov9" title="1368">b.WriteByte(s[i])</span>
        }

        <span class="cov7" title="148">for i := right + 1; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                b.WriteByte('_')
        }</span>
        <span class="cov7" title="148">return b.String()</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_core

import (
        "fmt"
        "reflect"
        "runtime"
        "strings"

        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/gs/internal/gs_arg"
        "github.com/go-spring/spring-core/gs/internal/gs_bean"
        "github.com/go-spring/spring-core/gs/internal/gs_cond"
        "github.com/go-spring/spring-core/util"
)

// NewBean 普通函数注册时需要使用 reflect.ValueOf(fn) 形式以避免和构造函数发生冲突。
func NewBean(objOrCtor interface{}, ctorArgs ...gs.Arg) *gs.BeanDefinition <span class="cov10" title="13">{

        var v reflect.Value
        var fromValue bool
        var name string
        var cond gs.Condition

        switch i := objOrCtor.(type) </span>{
        case reflect.Value:<span class="cov7" title="7">
                fromValue = true
                v = i</span>
        default:<span class="cov7" title="6">
                v = reflect.ValueOf(i)</span>
        }

        <span class="cov10" title="13">t := v.Type()
        if !util.IsBeanType(t) </span><span class="cov0" title="0">{
                panic("bean must be ref type")</span>
        }

        // Ensure the value is valid and not nil
        <span class="cov10" title="13">if !v.IsValid() || v.IsNil() </span><span class="cov0" title="0">{
                panic("bean can't be nil")</span>
        }

        <span class="cov10" title="13">var f *gs_arg.Callable
        _, file, line, _ := runtime.Caller(1)

        // If objOrCtor is a function (not from reflect.Value),
        // process it as a constructor
        if !fromValue &amp;&amp; t.Kind() == reflect.Func </span><span class="cov4" title="3">{

                if !util.IsConstructor(t) </span><span class="cov0" title="0">{
                        t1 := "func(...)bean"
                        t2 := "func(...)(bean, error)"
                        panic(fmt.Sprintf("constructor should be %s or %s", t1, t2))</span>
                }

                // Bind the constructor arguments
                <span class="cov4" title="3">f = gs_arg.MustBind(objOrCtor, ctorArgs...)
                f.SetFileLine(file, line)

                var in0 reflect.Type
                if t.NumIn() &gt; 0 </span><span class="cov4" title="3">{
                        in0 = t.In(0)
                }</span>

                // Obtain the return type of the constructor
                <span class="cov4" title="3">out0 := t.Out(0)
                v = reflect.New(out0)
                if util.IsBeanType(out0) </span><span class="cov4" title="3">{
                        v = v.Elem()
                }</span>

                <span class="cov4" title="3">t = v.Type()
                if !util.IsBeanType(t) </span><span class="cov0" title="0">{
                        panic("bean must be ref type")</span>
                }

                // Extract function name for naming the bean
                <span class="cov4" title="3">fnPtr := reflect.ValueOf(objOrCtor).Pointer()
                fnInfo := runtime.FuncForPC(fnPtr)
                funcName := fnInfo.Name()
                name = funcName[strings.LastIndex(funcName, "/")+1:]
                name = name[strings.Index(name, ".")+1:]
                if name[0] == '(' </span><span class="cov0" title="0">{
                        name = name[strings.Index(name, ".")+1:]
                }</span>

                // Check if the function is a method and set a condition if needed
                <span class="cov4" title="3">method := strings.LastIndexByte(fnInfo.Name(), ')') &gt; 0
                if method </span><span class="cov0" title="0">{
                        var s gs.BeanSelector = gs.BeanSelectorImpl{Type: in0}
                        if len(ctorArgs) &gt; 0 </span><span class="cov0" title="0">{
                                switch a := ctorArgs[0].(type) </span>{
                                case *gs.RegisteredBean:<span class="cov0" title="0">
                                        s = a</span>
                                case *gs.BeanDefinition:<span class="cov0" title="0">
                                        s = a</span>
                                case gs_arg.IndexArg:<span class="cov0" title="0">
                                        if a.Idx == 0 </span><span class="cov0" title="0">{
                                                switch x := a.Arg.(type) </span>{
                                                case *gs.RegisteredBean:<span class="cov0" title="0">
                                                        s = x</span>
                                                case *gs.BeanDefinition:<span class="cov0" title="0">
                                                        s = x</span>
                                                default:<span class="cov0" title="0">
                                                        panic("the arg of IndexArg[0] should be *RegisteredBean or *BeanDefinition")</span>
                                                }
                                        }
                                default:<span class="cov0" title="0">
                                        panic("ctorArgs[0] should be *RegisteredBean or *BeanDefinition or IndexArg[0]")</span>
                                }
                        }
                        <span class="cov0" title="0">cond = gs_cond.OnBeanSelector(s)</span>
                }
        }

        <span class="cov10" title="13">if t.Kind() == reflect.Ptr &amp;&amp; !util.IsPropBindingTarget(t.Elem()) </span><span class="cov0" title="0">{
                panic("bean should be *val but not *ref")</span>
        }

        // Type.String() 一般返回 *pkg.Type 形式的字符串，
        // 我们只取最后的类型名，如有需要请自定义 bean 名称。
        <span class="cov10" title="13">if name == "" </span><span class="cov9" title="10">{
                s := strings.Split(t.String(), ".")
                name = strings.TrimPrefix(s[len(s)-1], "*")
        }</span>

        <span class="cov10" title="13">d := gs_bean.NewBean(t, v, f, name)
        d.SetFileLine(file, line)

        bd := gs.NewBeanDefinition(d)
        if cond != nil </span><span class="cov0" title="0">{
                bd.Condition(cond)
        }</span>
        <span class="cov10" title="13">return bd</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_core

import (
        "errors"
        "reflect"
        "testing"
        "time"

        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/gs/internal/gs_bean"
        "github.com/go-spring/spring-core/gs/internal/gs_core/resolving"
        "github.com/go-spring/spring-core/gs/internal/gs_core/wiring"
        "github.com/go-spring/spring-core/util/syslog"
)

type refreshState int

const (
        RefreshDefault = refreshState(iota) // 未刷新
        RefreshInit                         // 准备刷新
        Refreshing                          // 正在刷新
        Refreshed                           // 已刷新
)

// Container 是 go-spring 框架的基石，实现了 Martin Fowler 在 &lt;&lt; Inversion
// of Control Containers and the Dependency Injection pattern &gt;&gt; 一文中
// 提及的依赖注入的概念。但原文的依赖注入仅仅是指对象之间的依赖关系处理，而有些 IoC
// 容器在实现时比如 Spring 还引入了对属性 property 的处理。通常大家会用依赖注入统
// 述上面两种概念，但实际上使用属性绑定来描述对 property 的处理会更加合适，因此
// go-spring 严格区分了这两种概念，在描述对 bean 的处理时要么单独使用依赖注入或属
// 性绑定，要么同时使用依赖注入和属性绑定。
type Container struct {
        state     refreshState
        resolving *resolving.Resolving
        wiring    *wiring.Wiring
}

// New 创建 IoC 容器。
func New() *Container <span class="cov3" title="2">{
        return &amp;Container{
                resolving: resolving.New(),
                wiring:    wiring.New(),
        }
}</span>

// Mock mocks the bean with the given object.
func (c *Container) Mock(obj interface{}, target gs.BeanSelector) <span class="cov0" title="0">{
        c.resolving.Mock(obj, target)
}</span>

// Object 注册对象形式的 bean ，需要注意的是该方法在注入开始后就不能再调用了。
func (c *Container) Object(i interface{}) *gs.RegisteredBean <span class="cov3" title="2">{
        b := NewBean(reflect.ValueOf(i))
        return c.Register(b)
}</span>

// Provide 注册构造函数形式的 bean ，需要注意的是该方法在注入开始后就不能再调用了。
func (c *Container) Provide(ctor interface{}, args ...gs.Arg) *gs.RegisteredBean <span class="cov0" title="0">{
        b := NewBean(ctor, args...)
        return c.Register(b)
}</span>

func (c *Container) Register(b *gs.BeanDefinition) *gs.RegisteredBean <span class="cov10" title="10">{
        x := b.BeanRegistration().(*gs_bean.BeanDefinition)
        r := gs.NewRegisteredBean(b.BeanRegistration())
        if c.state &lt; Refreshing </span><span class="cov10" title="10">{
                c.resolving.Register(x)
        }</span>
        <span class="cov10" title="10">return r</span>
}

func (c *Container) GroupRegister(fn resolving.GroupFunc) <span class="cov1" title="1">{
        c.resolving.GroupRegister(fn)
}</span>

// RefreshProperties updates the properties of the container.
func (c *Container) RefreshProperties(p gs.Properties) error <span class="cov3" title="2">{
        return c.wiring.RefreshProperties(p)
}</span>

// Refresh initializes and wires all beans in the container.
func (c *Container) Refresh() (err error) <span class="cov3" title="2">{
        if c.state != RefreshDefault </span><span class="cov0" title="0">{
                return errors.New("container is refreshing or refreshed")
        }</span>
        <span class="cov3" title="2">c.state = RefreshInit
        start := time.Now()

        err = c.resolving.RefreshInit(c.wiring.Properties())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">c.state = Refreshing

        beans, err := c.resolving.Refresh(c.wiring.Properties())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">err = c.wiring.Refresh(beans)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">c.resolving = nil
        c.state = Refreshed
        syslog.Debugf("container is refreshed successfully, %d beans cost %v",
                len(beans), time.Now().Sub(start))
        return nil</span>
}

// Wire wires the bean with the given object.
func (c *Container) Wire(obj interface{}) error <span class="cov0" title="0">{

        if !testing.Testing() </span><span class="cov0" title="0">{
                return errors.New("not allowed to call Wire method in non-test mode")
        }</span>

        <span class="cov0" title="0">stack := wiring.NewStack()
        defer func() </span><span class="cov0" title="0">{
                if len(stack.Beans) &gt; 0 </span><span class="cov0" title="0">{
                        syslog.Infof("wiring path %s", stack.Path())
                }</span>
        }()

        <span class="cov0" title="0">t := reflect.TypeOf(obj)
        v := reflect.ValueOf(obj)
        return c.wiring.WireBeanValue(v, t, false, stack)</span>
}

// Close closes the container and cleans up resources.
func (c *Container) Close() <span class="cov3" title="2">{
        c.wiring.Close()
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package resolving

import (
        "fmt"
        "reflect"
        "regexp"

        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/gs/internal/gs_arg"
        "github.com/go-spring/spring-core/gs/internal/gs_bean"
        "github.com/go-spring/spring-core/gs/internal/gs_cond"
        "github.com/go-spring/spring-core/util"
)

type GroupFunc = func(p gs.Properties) ([]*gs.BeanDefinition, error)

type BeanMock struct {
        Object interface{}
        Target gs.BeanSelector
}

type Resolving struct {
        mocks []BeanMock
        beans []*gs_bean.BeanDefinition
        funcs []GroupFunc
}

func New() *Resolving <span class="cov3" title="2">{
        return &amp;Resolving{}
}</span>

func (c *Resolving) Mock(obj interface{}, target gs.BeanSelector) <span class="cov0" title="0">{
        x := BeanMock{Object: obj, Target: target}
        c.mocks = append(c.mocks, x)
}</span>

func (c *Resolving) Register(b *gs_bean.BeanDefinition) <span class="cov8" title="10">{
        c.beans = append(c.beans, b)
}</span>

func (c *Resolving) GroupRegister(fn GroupFunc) <span class="cov1" title="1">{
        c.funcs = append(c.funcs, fn)
}</span>

func (c *Resolving) RefreshInit(p gs.Properties) error <span class="cov3" title="2">{
        // processes all group functions to register beans.
        for _, fn := range c.funcs </span><span class="cov1" title="1">{
                beans, err := fn(p)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">for _, b := range beans </span><span class="cov4" title="3">{
                        d := b.BeanRegistration().(*gs_bean.BeanDefinition)
                        c.beans = append(c.beans, d)
                }</span>
        }

        // processes configuration beans to register beans.
        <span class="cov3" title="2">for _, b := range c.beans </span><span class="cov9" title="13">{
                if !b.ConfigurationBean() </span><span class="cov9" title="13">{
                        continue</span>
                }
                <span class="cov0" title="0">var foundMock BeanMock
                for _, x := range c.mocks </span><span class="cov0" title="0">{
                        t, s := x.Target.TypeAndName()
                        if t != b.Type() </span><span class="cov0" title="0">{ // type is not same
                                continue</span>
                        }
                        <span class="cov0" title="0">if s != "" &amp;&amp; s != b.Name() </span><span class="cov0" title="0">{ // name is not equal
                                continue</span>
                        }
                        <span class="cov0" title="0">foundMock = x
                        break</span>
                }
                <span class="cov0" title="0">if foundMock.Target != nil </span><span class="cov0" title="0">{
                        b.SetMock(foundMock.Object)
                        continue</span>
                }
                <span class="cov0" title="0">newBeans, err := c.scanConfiguration(b)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">c.beans = append(c.beans, newBeans...)</span>
        }

        <span class="cov3" title="2">for _, x := range c.mocks </span><span class="cov0" title="0">{
                var found []*gs_bean.BeanDefinition
                t, s := x.Target.TypeAndName()
                vt := reflect.TypeOf(x.Object)
                switch t.Kind() </span>{
                case reflect.Interface:<span class="cov0" title="0">
                        for _, b := range c.beans </span><span class="cov0" title="0">{
                                if b.Type().Kind() == reflect.Interface </span><span class="cov0" title="0">{
                                        if t != b.Type() </span><span class="cov0" title="0">{ // type is not same
                                                foundType := false
                                                for _, et := range b.Exports() </span><span class="cov0" title="0">{
                                                        if et == t </span><span class="cov0" title="0">{
                                                                foundType = true
                                                                break</span>
                                                        }
                                                }
                                                <span class="cov0" title="0">if foundType </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("found unimplemented interfaces")
                                                }</span>
                                                <span class="cov0" title="0">continue</span>
                                        }
                                        <span class="cov0" title="0">for _, et := range b.Exports() </span><span class="cov0" title="0">{
                                                if !vt.Implements(et) </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("found unimplemented interfaces")
                                                }</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        foundType := false
                                        for _, et := range b.Exports() </span><span class="cov0" title="0">{
                                                if et == t </span><span class="cov0" title="0">{
                                                        foundType = true
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if !foundType </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">if len(b.Exports()) &gt; 1 </span><span class="cov0" title="0">{
                                                return fmt.Errorf("found unimplemented interfaces")
                                        }</span>
                                }
                                <span class="cov0" title="0">if s != "" &amp;&amp; s != b.Name() </span><span class="cov0" title="0">{ // name is not equal
                                        continue</span>
                                }
                                <span class="cov0" title="0">found = append(found, b)</span>
                        }
                default:<span class="cov0" title="0">
                        for _, b := range c.beans </span><span class="cov0" title="0">{
                                if t != b.Type() </span><span class="cov0" title="0">{ // type is not same
                                        continue</span>
                                }
                                <span class="cov0" title="0">for _, et := range b.Exports() </span><span class="cov0" title="0">{
                                        if !vt.Implements(et) </span><span class="cov0" title="0">{
                                                return fmt.Errorf("found unimplemented interfaces")
                                        }</span>
                                }
                                <span class="cov0" title="0">if s != "" &amp;&amp; s != b.Name() </span><span class="cov0" title="0">{ // name is not equal
                                        continue</span>
                                }
                                <span class="cov0" title="0">found = append(found, b)</span>
                        }
                }
                <span class="cov0" title="0">if len(found) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if len(found) &gt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("found duplicate mocked beans")
                }</span>
                <span class="cov0" title="0">found[0].SetMock(x.Object)</span>
        }

        <span class="cov3" title="2">return nil</span>
}

func (c *Resolving) Refresh(p gs.Properties) ([]*gs_bean.BeanDefinition, error) <span class="cov3" title="2">{

        // resolves all beans on their condition.
        ctx := &amp;CondContext{p: p, c: c}
        for _, b := range c.beans </span><span class="cov9" title="13">{
                if err := ctx.resolveBean(b); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov3" title="2">type BeanID struct {
                s string
                t reflect.Type
        }

        // caches all beans by id and checks for duplicates.
        beansByID := make(map[BeanID]*gs_bean.BeanDefinition)
        for _, b := range c.beans </span><span class="cov9" title="13">{
                if b.Status() == gs_bean.StatusDeleted </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov9" title="13">if b.Status() != gs_bean.StatusResolved </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected status %d", b.Status())
                }</span>
                <span class="cov9" title="13">beanID := BeanID{b.Name(), b.Type()}
                if d, ok := beansByID[beanID]; ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("found duplicate beans [%s] [%s]", b, d)
                }</span>
                <span class="cov9" title="13">beansByID[beanID] = b</span>
        }
        <span class="cov3" title="2">return c.beans, nil</span>
}

func (c *Resolving) scanConfiguration(bd *gs_bean.BeanDefinition) ([]*gs_bean.BeanDefinition, error) <span class="cov0" title="0">{
        var (
                includes []*regexp.Regexp
                excludes []*regexp.Regexp
        )
        param := bd.ConfigurationParam()
        ss := param.Includes
        if len(ss) == 0 </span><span class="cov0" title="0">{
                ss = []string{"New*"}
        }</span>
        <span class="cov0" title="0">for _, s := range ss </span><span class="cov0" title="0">{
                var x *regexp.Regexp
                x, err := regexp.Compile(s)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">includes = append(includes, x)</span>
        }
        <span class="cov0" title="0">ss = param.Excludes
        for _, s := range ss </span><span class="cov0" title="0">{
                var x *regexp.Regexp
                x, err := regexp.Compile(s)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">excludes = append(excludes, x)</span>
        }
        <span class="cov0" title="0">var newBeans []*gs_bean.BeanDefinition
        n := bd.Type().NumMethod()
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                m := bd.Type().Method(i)
                skip := false
                for _, x := range excludes </span><span class="cov0" title="0">{
                        if x.MatchString(m.Name) </span><span class="cov0" title="0">{
                                skip = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if skip </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for _, x := range includes </span><span class="cov0" title="0">{
                        if !x.MatchString(m.Name) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">fnType := m.Func.Type()
                        out0 := fnType.Out(0)
                        file, line, _ := util.FileLine(m.Func.Interface())
                        f, err := gs_arg.Bind(m.Func.Interface(), []gs.Arg{
                                gs_arg.Tag(bd.Name()),
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">f.SetFileLine(file, line)
                        v := reflect.New(out0)
                        if util.IsBeanType(out0) </span><span class="cov0" title="0">{
                                v = v.Elem()
                        }</span>
                        <span class="cov0" title="0">name := bd.Name() + "_" + m.Name
                        b := gs_bean.NewBean(v.Type(), v, f, name)
                        b.SetFileLine(file, line)
                        b.SetCondition(gs_cond.OnBeanSelector(bd))
                        newBeans = append(newBeans, b)
                        break</span>
                }
        }
        <span class="cov0" title="0">return newBeans, nil</span>
}

type CondContext struct {
        c *Resolving
        p gs.Properties
}

// resolveBean determines the validity of the bean.
func (c *CondContext) resolveBean(b *gs_bean.BeanDefinition) error <span class="cov10" title="14">{
        if b.Status() &gt;= gs_bean.StatusResolving </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov9" title="13">b.SetStatus(gs_bean.StatusResolving)
        for _, cond := range b.Conditions() </span><span class="cov5" title="4">{
                if ok, err := cond.Matches(c); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov5" title="4"> if !ok </span><span class="cov0" title="0">{
                        b.SetStatus(gs_bean.StatusDeleted)
                        return nil
                }</span>
        }
        <span class="cov9" title="13">b.SetStatus(gs_bean.StatusResolved)
        return nil</span>
}

func (c *CondContext) Has(key string) bool <span class="cov3" title="2">{
        return c.p.Has(key)
}</span>

func (c *CondContext) Prop(key string, def ...string) string <span class="cov3" title="2">{
        return c.p.Get(key, def...)
}</span>

// Find 查找符合条件的 bean 对象，注意该函数只能保证返回的 bean 是有效的，
// 即未被标记为删除的，而不能保证已经完成属性绑定和依赖注入。
func (c *CondContext) Find(s gs.BeanSelector) ([]gs.CondBean, error) <span class="cov1" title="1">{
        t, name := s.TypeAndName()
        var result []gs.CondBean
        for _, b := range c.c.beans </span><span class="cov9" title="11">{
                if b.Status() == gs_bean.StatusResolving || b.Status() == gs_bean.StatusDeleted </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov8" title="10">if t != nil </span><span class="cov8" title="10">{
                        if b.Type() != t </span><span class="cov8" title="9">{
                                foundType := false
                                for _, typ := range b.Exports() </span><span class="cov4" title="3">{
                                        if typ == t </span><span class="cov0" title="0">{
                                                foundType = true
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="9">if !foundType </span><span class="cov8" title="9">{
                                        continue</span>
                                }
                        }
                }
                <span class="cov1" title="1">if name != "" &amp;&amp; name != b.Name() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">if err := c.resolveBean(b); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">if b.Status() == gs_bean.StatusDeleted </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">result = append(result, b)</span>
        }
        <span class="cov1" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package wiring

import (
        "bytes"
        "container/list"
        "errors"
        "fmt"
        "reflect"
        "sort"
        "strings"
        "testing"

        "github.com/go-spring/spring-core/conf"
        "github.com/go-spring/spring-core/gs/internal/gs"
        "github.com/go-spring/spring-core/gs/internal/gs_arg"
        "github.com/go-spring/spring-core/gs/internal/gs_bean"
        "github.com/go-spring/spring-core/gs/internal/gs_dync"
        "github.com/go-spring/spring-core/gs/internal/gs_util"
        "github.com/go-spring/spring-core/util"
        "github.com/go-spring/spring-core/util/syslog"
        "github.com/spf13/cast"
)

type BeanRuntime interface {
        Name() string
        Type() reflect.Type
        Value() reflect.Value
        Interface() interface{}
        Callable() *gs_arg.Callable
        Status() gs_bean.BeanStatus
        String() string
}

type refreshState int

const (
        RefreshDefault = refreshState(iota) // 未刷新
        Refreshing                          // 正在刷新
        Refreshed                           // 已刷新
)

/************************************ destroyer ******************************/

// destroyer stores beans with destroy functions and their call order.
type destroyer struct {
        current *gs_bean.BeanDefinition   // The current bean being processed.
        earlier []*gs_bean.BeanDefinition // Beans that must be destroyed before the current bean.
}

// foundEarlier checks if a bean is already in the earlier list.
func (d *destroyer) foundEarlier(b *gs_bean.BeanDefinition) bool <span class="cov7" title="9">{
        for _, c := range d.earlier </span><span class="cov0" title="0">{
                if c == b </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov7" title="9">return false</span>
}

// after adds a bean to the earlier list, ensuring it is destroyed before the current bean.
func (d *destroyer) after(b *gs_bean.BeanDefinition) <span class="cov0" title="0">{
        if d.foundEarlier(b) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">d.earlier = append(d.earlier, b)</span>
}

// getBeforeDestroyers retrieves destroyers that should be processed before a given one for sorting purposes.
func getBeforeDestroyers(destroyers *list.List, i interface{}) (*list.List, error) <span class="cov4" title="3">{
        d := i.(*destroyer)
        result := list.New()
        for e := destroyers.Front(); e != nil; e = e.Next() </span><span class="cov7" title="9">{
                c := e.Value.(*destroyer)
                if d.foundEarlier(c.current) </span><span class="cov0" title="0">{
                        result.PushBack(c)
                }</span>
        }
        <span class="cov4" title="3">return result, nil</span>
}

/******************************* wiring stack ********************************/

// lazyField represents a lazy-injected field with metadata.
type lazyField struct {
        v    reflect.Value // The value to be injected.
        path string        // Path for the field in the injection hierarchy.
        tag  string        // Associated tag for the field.
}

// Stack tracks the injection path of beans and their destroyers.
type Stack struct {
        destroyers   *list.List
        destroyerMap map[string]*destroyer
        Beans        []*gs_bean.BeanDefinition
        lazyFields   []lazyField
}

// NewStack creates a new Stack instance.
func NewStack() *Stack <span class="cov2" title="2">{
        return &amp;Stack{
                destroyers:   list.New(),
                destroyerMap: make(map[string]*destroyer),
        }
}</span>

// pushBack adds a bean to the injection path.
func (s *Stack) pushBack(b *gs_bean.BeanDefinition) <span class="cov9" title="24">{
        syslog.Debugf("push %s %s", b, b.Status())
        s.Beans = append(s.Beans, b)
}</span>

// popBack removes the last bean from the injection path.
func (s *Stack) popBack() <span class="cov9" title="24">{
        n := len(s.Beans)
        b := s.Beans[n-1]
        s.Beans = s.Beans[:n-1]
        syslog.Debugf("pop %s %s", b, b.Status())
}</span>

// Path returns the injection path as a string.
func (s *Stack) Path() (path string) <span class="cov0" title="0">{
        for _, b := range s.Beans </span><span class="cov0" title="0">{
                path += fmt.Sprintf("=&gt; %s ↩\n", b)
        }</span>
        <span class="cov0" title="0">return path[:len(path)-1]</span> // Remove the trailing newline.
}

// saveDestroyer tracks a bean with a destroy function, ensuring no duplicates.
func (s *Stack) saveDestroyer(b *gs_bean.BeanDefinition) *destroyer <span class="cov5" title="6">{
        d, ok := s.destroyerMap[b.Name()] // todo
        if !ok </span><span class="cov4" title="3">{
                d = &amp;destroyer{current: b}
                s.destroyerMap[b.Name()] = d
        }</span>
        <span class="cov5" title="6">return d</span>
}

// getSortedDestroyers sorts beans with destroy functions by dependency order.
func (s *Stack) getSortedDestroyers() ([]func(), error) <span class="cov2" title="2">{

        destroy := func(v reflect.Value, fn interface{}) func() </span><span class="cov4" title="3">{
                return func() </span><span class="cov4" title="3">{
                        fnValue := reflect.ValueOf(fn)
                        out := fnValue.Call([]reflect.Value{v})
                        if len(out) &gt; 0 &amp;&amp; !out[0].IsNil() </span><span class="cov0" title="0">{
                                syslog.Errorf("%s", out[0].Interface().(error).Error())
                        }</span>
                }
        }

        <span class="cov2" title="2">destroyers := list.New()
        for _, d := range s.destroyerMap </span><span class="cov4" title="3">{
                destroyers.PushBack(d)
        }</span>
        <span class="cov2" title="2">destroyers, err := gs_util.TripleSort(destroyers, getBeforeDestroyers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">var ret []func()
        for e := destroyers.Front(); e != nil; e = e.Next() </span><span class="cov4" title="3">{
                d := e.Value.(*destroyer).current
                ret = append(ret, destroy(d.Value(), d.Destroy()))
        }</span>
        <span class="cov2" title="2">return ret, nil</span>
}

/************************************ arg ************************************/

// ArgContext holds a Container and a Stack to manage dependency injection.
type ArgContext struct {
        c     *Wiring
        stack *Stack
}

// NewArgContext creates a new ArgContext with a given Container and Stack.
func NewArgContext(c *Wiring, stack *Stack) *ArgContext <span class="cov4" title="3">{
        return &amp;ArgContext{c: c, stack: stack}
}</span>

func (a *ArgContext) Has(key string) bool <span class="cov0" title="0">{
        return a.c.p.Data().Has(key)
}</span>

func (a *ArgContext) Prop(key string, def ...string) string <span class="cov0" title="0">{
        return a.c.p.Data().Get(key, def...)
}</span>

func (a *ArgContext) Find(s gs.BeanSelector) ([]gs.CondBean, error) <span class="cov0" title="0">{
        beans, err := a.c.findBeans(s)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var ret []gs.CondBean
        for _, bean := range beans </span><span class="cov0" title="0">{
                ret = append(ret, bean)
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}

// Matches checks if a given condition matches the container.
func (a *ArgContext) Matches(c gs.Condition) (bool, error) <span class="cov0" title="0">{
        return c.Matches(a)
}</span>

// Bind binds a value to a specific tag in the container.
func (a *ArgContext) Bind(v reflect.Value, tag string) error <span class="cov2" title="2">{
        return a.c.p.Data().Bind(v, tag)
}</span>

// Wire wires a value based on a specific tag in the container.
func (a *ArgContext) Wire(v reflect.Value, tag string) error <span class="cov4" title="3">{
        return a.c.wireStructField(v, tag, a.stack)
}</span>

/************************************ wire ***********************************/

// wireTag represents a parsed injection tag in the format TypeName:BeanName?.
type wireTag struct {
        beanName string // Bean name for injection.
        nullable bool   // Whether the injection can be nil.
}

// String converts a wireTag back to its string representation.
func (tag wireTag) String() string <span class="cov0" title="0">{
        b := bytes.NewBuffer(nil)
        b.WriteString(tag.beanName)
        if tag.nullable </span><span class="cov0" title="0">{
                b.WriteString("?")
        }</span>
        <span class="cov0" title="0">return b.String()</span>
}

// toWireString converts a slice of wireTags to a comma-separated string.
func toWireString(tags []wireTag) string <span class="cov0" title="0">{
        var buf bytes.Buffer
        for i, tag := range tags </span><span class="cov0" title="0">{
                buf.WriteString(tag.String())
                if i &lt; len(tags)-1 </span><span class="cov0" title="0">{
                        buf.WriteByte(',')
                }</span>
        }
        <span class="cov0" title="0">return buf.String()</span>
}

// parseWireTag parses a wire tag string and returns a wireTag struct.
func parseWireTag(p gs.Properties, str string, needResolve bool) (tag wireTag, err error) <span class="cov7" title="11">{

        if str == "" </span><span class="cov4" title="4">{
                return
        }</span>

        <span class="cov6" title="7">if needResolve </span><span class="cov6" title="7">{
                if strings.HasPrefix(str, "${") </span><span class="cov4" title="4">{
                        str, err = p.Resolve(str)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }

        <span class="cov6" title="7">if n := len(str) - 1; str[n] == '?' </span><span class="cov4" title="4">{
                tag.nullable = true
                str = str[:n]
        }</span>

        <span class="cov6" title="7">tag.beanName = str
        return</span>
}

type Wiring struct {
        state refreshState

        beansByName map[string][]BeanRuntime // 用于查找未导出接口
        beansByType map[reflect.Type][]BeanRuntime

        p *gs_dync.Properties

        destroyers []func()

        allowCircularReferences bool
        forceAutowireIsNullable bool
}

func New() *Wiring <span class="cov2" title="2">{
        return &amp;Wiring{
                state:       RefreshDefault,
                p:           gs_dync.New(),
                beansByName: make(map[string][]BeanRuntime),
                beansByType: make(map[reflect.Type][]BeanRuntime),
        }
}</span>

func (c *Wiring) Properties() gs.Properties <span class="cov4" title="4">{
        return c.p.Data()
}</span>

func (c *Wiring) RefreshProperties(p gs.Properties) error <span class="cov2" title="2">{
        return c.p.Refresh(p)
}</span>

// Close closes the container and cleans up resources.
func (c *Wiring) Close() <span class="cov2" title="2">{
        for _, f := range c.destroyers </span><span class="cov4" title="3">{
                f()
        }</span>
}

func (c *Wiring) Refresh(inputBeans []*gs_bean.BeanDefinition) (err error) <span class="cov2" title="2">{

        c.allowCircularReferences = cast.ToBool(c.p.Data().Get("spring.allow-circular-references"))
        c.forceAutowireIsNullable = cast.ToBool(c.p.Data().Get("spring.force-autowire-is-nullable"))

        // registers all beans
        var beans []*gs_bean.BeanDefinition
        for _, b := range inputBeans </span><span class="cov8" title="13">{
                if b.Status() == gs_bean.StatusDeleted </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="13">c.beansByName[b.Name()] = append(c.beansByName[b.Name()], b)
                c.beansByType[b.Type()] = append(c.beansByType[b.Type()], b)
                for _, t := range b.Exports() </span><span class="cov5" title="5">{
                        c.beansByType[t] = append(c.beansByType[t], b)
                }</span>
                <span class="cov8" title="13">beans = append(beans, b)</span>
        }

        <span class="cov2" title="2">stack := NewStack()
        defer func() </span><span class="cov2" title="2">{
                if err != nil || len(stack.Beans) &gt; 0 </span><span class="cov0" title="0">{
                        err = fmt.Errorf("%s ↩\n%s", err, stack.Path())
                        syslog.Errorf("%s", err.Error())
                }</span>
        }()

        // injects all beans
        <span class="cov2" title="2">c.state = Refreshing
        for _, b := range beans </span><span class="cov8" title="13">{
                if err = c.wireBean(b, stack); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov2" title="2">c.state = Refreshed

        if c.allowCircularReferences </span><span class="cov0" title="0">{
                // processes the bean fields that are marked for lazy injection.
                for _, f := range stack.lazyFields </span><span class="cov0" title="0">{
                        tag := strings.TrimSuffix(f.tag, ",lazy")
                        if err = c.wireStructField(f.v, tag, stack); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%q wired error: %s", f.path, err.Error())
                        }</span>
                }
        } else<span class="cov2" title="2"> if len(stack.lazyFields) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New("found circular references in beans")
        }</span>

        <span class="cov2" title="2">c.destroyers, err = stack.getSortedDestroyers()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // registers all beans
        <span class="cov2" title="2">c.beansByName = make(map[string][]BeanRuntime)
        c.beansByType = make(map[reflect.Type][]BeanRuntime)
        for _, b := range inputBeans </span><span class="cov8" title="13">{
                if b.Status() == gs_bean.StatusDeleted </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="13">c.beansByName[b.Name()] = append(c.beansByName[b.Name()], b.BeanRuntime)
                c.beansByType[b.Type()] = append(c.beansByType[b.Type()], b.BeanRuntime)
                for _, t := range b.Exports() </span><span class="cov5" title="5">{
                        c.beansByType[t] = append(c.beansByType[t], b.BeanRuntime)
                }</span>
        }

        <span class="cov2" title="2">if !testing.Testing() </span><span class="cov2" title="2">{
                if c.p.ObjectsCount() == 0 </span><span class="cov2" title="2">{
                        c.p = nil
                }</span>
                <span class="cov2" title="2">c.beansByName = nil
                c.beansByType = nil</span>
        }
        <span class="cov2" title="2">return nil</span>
}

// findBeans finds beans based on a given selector.
func (c *Wiring) findBeans(s gs.BeanSelector) ([]BeanRuntime, error) <span class="cov0" title="0">{
        t, name := s.TypeAndName()
        var beans []BeanRuntime
        if t != nil </span><span class="cov0" title="0">{
                beans = c.beansByType[t]
        }</span>
        <span class="cov0" title="0">if name != "" </span><span class="cov0" title="0">{
                if beans == nil </span><span class="cov0" title="0">{
                        beans = c.beansByName[name]
                }</span>
                <span class="cov0" title="0">var ret []BeanRuntime
                for _, b := range beans </span><span class="cov0" title="0">{
                        if name == b.Name() </span><span class="cov0" title="0">{
                                ret = append(ret, b)
                        }</span>
                }
                <span class="cov0" title="0">beans = ret</span>
        }
        <span class="cov0" title="0">return beans, nil</span>
}

// getSingleBean retrieves the bean corresponding to the specified tag and assigns it to `v`.
// `v` should be an uninitialized value.
func (c *Wiring) getBean(t reflect.Type, tag wireTag, stack *Stack) (BeanRuntime, error) <span class="cov6" title="7">{

        // Check if the type of `v` is a valid bean receiver type.
        if !util.IsBeanInjectionTarget(t) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s is not a valid receiver type", t.String())
        }</span>

        <span class="cov6" title="7">var foundBeans []BeanRuntime
        // Iterate through all beans of the given type and match against the tag.
        for _, b := range c.beansByType[t] </span><span class="cov8" title="13">{
                if b.Status() == gs_bean.StatusDeleted </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="13">if tag.beanName == "" || tag.beanName == b.Name() </span><span class="cov6" title="7">{
                        foundBeans = append(foundBeans, b)
                }</span>
        }

        // When a specific bean name is provided, find it by name.
        <span class="cov6" title="7">if t.Kind() == reflect.Interface &amp;&amp; tag.beanName != "" </span><span class="cov0" title="0">{
                for _, b := range c.beansByName[tag.beanName] </span><span class="cov0" title="0">{
                        if b.Status() == gs_bean.StatusDeleted </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if !b.Type().AssignableTo(t) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if tag.beanName != "" &amp;&amp; tag.beanName != b.Name() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Deduplicate the results.
                        <span class="cov0" title="0">found := false
                        for _, r := range foundBeans </span><span class="cov0" title="0">{
                                if r == b </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                foundBeans = append(foundBeans, b)
                                syslog.Warnf("you should call Export() on %s", b)
                        }</span>
                }
        }

        // If no matching beans are found and the tag allows nullable beans, return nil.
        <span class="cov6" title="7">if len(foundBeans) == 0 </span><span class="cov0" title="0">{
                if tag.nullable </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("can't find bean, bean:%q type:%q", tag, t)</span>
        }

        // If more than one matching bean is found, return an error.
        <span class="cov6" title="7">if len(foundBeans) &gt; 1 </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("found %d beans, bean:%q type:%q [", len(foundBeans), tag, t)
                for _, b := range foundBeans </span><span class="cov0" title="0">{
                        msg += "( " + b.String() + " ), "
                }</span>
                <span class="cov0" title="0">msg = msg[:len(msg)-2] + "]"
                return nil, errors.New(msg)</span>
        }

        // Retrieve the single matching bean.
        <span class="cov6" title="7">b := foundBeans[0]

        // Ensure the found bean has completed dependency injection.
        switch c.state </span>{
        case Refreshing:<span class="cov6" title="7">
                if err := c.wireBean(b.(*gs_bean.BeanDefinition), stack); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        case Refreshed:<span class="cov0" title="0">
                if b.Status() != gs_bean.StatusWired </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected bean status %d", b.Status())
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("state is invalid for wiring")</span>
        }
        <span class="cov6" title="7">return b, nil</span>
}

// getMultiBeans collects beans into the given slice or map value `v`.
// It supports dependency injection by resolving matching beans based on tags.
func (c *Wiring) getBeans(t reflect.Type, tags []wireTag, nullable bool, stack *Stack) ([]BeanRuntime, error) <span class="cov4" title="4">{

        if t.Kind() != reflect.Slice &amp;&amp; t.Kind() != reflect.Map </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("should be slice or map in collection mode")
        }</span>

        <span class="cov4" title="4">et := t.Elem()
        if !util.IsBeanInjectionTarget(et) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s is not a valid receiver type", t.String())
        }</span>

        <span class="cov4" title="4">var beans []BeanRuntime
        beans = c.beansByType[et]

        // Filter out deleted beans
        </span><span class="cov4" title="4">{
                var arr []BeanRuntime
                for _, b := range beans </span><span class="cov4" title="4">{
                        if b.Status() == gs_bean.StatusDeleted </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov4" title="4">arr = append(arr, b)</span>
                }
                <span class="cov4" title="4">beans = arr</span>
        }

        // Process bean tags to filter and order beans
        <span class="cov4" title="4">if len(tags) &gt; 0 </span><span class="cov4" title="4">{
                var (
                        anyBeans  []BeanRuntime
                        afterAny  []BeanRuntime
                        beforeAny []BeanRuntime
                )
                foundAny := false
                for _, item := range tags </span><span class="cov4" title="4">{

                        // 是否遇到了"无序"标记
                        if item.beanName == "*" </span><span class="cov4" title="4">{
                                if foundAny </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("more than one * in collection %q", tags)
                                }</span>
                                <span class="cov4" title="4">foundAny = true
                                continue</span>
                        }

                        <span class="cov0" title="0">var founds []int
                        for i, b := range beans </span><span class="cov0" title="0">{
                                if item.beanName == b.Name() </span><span class="cov0" title="0">{
                                        founds = append(founds, i)
                                }</span>
                        }
                        <span class="cov0" title="0">if len(founds) &gt; 1 </span><span class="cov0" title="0">{
                                msg := fmt.Sprintf("found %d beans, bean:%q type:%q [", len(founds), item, t)
                                for _, i := range founds </span><span class="cov0" title="0">{
                                        msg += "( " + beans[i].String() + " ), "
                                }</span>
                                <span class="cov0" title="0">msg = msg[:len(msg)-2] + "]"
                                return nil, errors.New(msg)</span>
                        }
                        <span class="cov0" title="0">if len(founds) == 0 </span><span class="cov0" title="0">{
                                if item.nullable </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">return nil, fmt.Errorf("can't find bean, bean:%q type:%q", item, t)</span>
                        }

                        <span class="cov0" title="0">index := founds[0]
                        if foundAny </span><span class="cov0" title="0">{
                                afterAny = append(afterAny, beans[index])
                        }</span> else<span class="cov0" title="0"> {
                                beforeAny = append(beforeAny, beans[index])
                        }</span>

                        <span class="cov0" title="0">tmpBeans := append([]BeanRuntime{}, beans[:index]...)
                        beans = append(tmpBeans, beans[index+1:]...)</span>
                }

                <span class="cov4" title="4">if foundAny </span><span class="cov4" title="4">{
                        anyBeans = append(anyBeans, beans...)
                }</span>

                <span class="cov4" title="4">n := len(beforeAny) + len(anyBeans) + len(afterAny)
                arr := make([]BeanRuntime, 0, n)
                arr = append(arr, beforeAny...)
                arr = append(arr, anyBeans...)
                arr = append(arr, afterAny...)
                beans = arr</span>
        }

        // Handle empty beans
        <span class="cov4" title="4">if len(beans) == 0 &amp;&amp; !nullable </span><span class="cov1" title="1">{
                if len(tags) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no beans collected for %q", toWireString(tags))
                }</span>
                <span class="cov1" title="1">for _, tag := range tags </span><span class="cov1" title="1">{
                        if !tag.nullable </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("no beans collected for %q", toWireString(tags))
                        }</span>
                }
                <span class="cov1" title="1">return nil, nil</span>
        }

        // Wire the beans based on the current state of the container
        <span class="cov4" title="3">for _, b := range beans </span><span class="cov4" title="4">{
                switch c.state </span>{
                case Refreshing:<span class="cov4" title="4">
                        if err := c.wireBean(b.(*gs_bean.BeanDefinition), stack); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case Refreshed:<span class="cov0" title="0">
                        if b.Status() != gs_bean.StatusWired </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected bean status %d", b.Status())
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("state is error for wiring")</span>
                }
        }
        <span class="cov4" title="3">return beans, nil</span>
}

// wireBean performs property binding and dependency injection for the specified bean.
// It also tracks its injection path. If the bean has an initialization function, it
// is executed after the injection is completed. If the bean depends on other beans,
// it attempts to instantiate and inject those dependencies first.
func (c *Wiring) wireBean(b *gs_bean.BeanDefinition, stack *Stack) error <span class="cov9" title="24">{

        // Check if the bean is deleted.
        if b.Status() == gs_bean.StatusDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("bean:%q has been deleted", b.String())
        }</span>

        // If the container is refreshed and the bean is already wired, do nothing.
        <span class="cov9" title="24">if c.state == Refreshed &amp;&amp; b.Status() == gs_bean.StatusWired </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov9" title="24">haveDestroy := false

        // Ensure destroy functions are cleaned up in case of failure.
        defer func() </span><span class="cov9" title="24">{
                if haveDestroy </span><span class="cov5" title="6">{
                        stack.destroyers.Remove(stack.destroyers.Back())
                }</span>
        }()

        // Record the destroy function for the bean, if it exists.
        <span class="cov9" title="24">if b.Destroy() != nil </span><span class="cov5" title="6">{
                haveDestroy = true
                d := stack.saveDestroyer(b)
                if i := stack.destroyers.Back(); i != nil </span><span class="cov0" title="0">{
                        d.after(i.Value.(*gs_bean.BeanDefinition))
                }</span>
                <span class="cov5" title="6">stack.destroyers.PushBack(b)</span>
        }

        <span class="cov9" title="24">stack.pushBack(b)

        // Detect circular dependency.
        if b.Status() == gs_bean.StatusCreating &amp;&amp; b.Callable() != nil </span><span class="cov0" title="0">{
                prev := stack.Beans[len(stack.Beans)-2]
                if prev.Status() == gs_bean.StatusCreating </span><span class="cov0" title="0">{
                        return errors.New("found circular autowire")
                }</span>
        }

        // If the bean is already being created, return early.
        <span class="cov9" title="24">if b.Status() &gt;= gs_bean.StatusCreating </span><span class="cov7" title="11">{
                stack.popBack()
                return nil
        }</span>

        // Mark the bean as being created.
        <span class="cov8" title="13">b.SetStatus(gs_bean.StatusCreating)

        // Inject dependencies for the current bean.
        for _, s := range b.DependsOn() </span><span class="cov0" title="0">{
                beans, err := c.findBeans(s) // todo 唯一
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, d := range beans </span><span class="cov0" title="0">{
                        err = c.wireBean(d.(*gs_bean.BeanDefinition), stack)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // Get the value of the current bean.
        <span class="cov8" title="13">v, err := c.getBeanValue(b, stack)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="13">b.SetStatus(gs_bean.StatusCreated)

        // Validate that the bean exports the appropriate interfaces.
        t := v.Type()
        for _, typ := range b.Exports() </span><span class="cov5" title="5">{
                if !t.Implements(typ) </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s doesn't implement interface %s", b, typ)
                }</span>
        }

        <span class="cov8" title="13">watchRefresh := true

        // If the bean is refreshable, add it to the refreshable list.
        if b.Refreshable() </span><span class="cov0" title="0">{
                i := b.Interface().(gs.Refreshable)
                var param conf.BindParam
                err = param.BindTag(b.RefreshTag(), "")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err = c.p.RefreshBean(i, param, true); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">watchRefresh = false</span>
        }

        // Wire the value of the bean.
        <span class="cov8" title="13">err = c.WireBeanValue(v, t, watchRefresh, stack)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Execute the bean's initialization function, if it exists.
        <span class="cov8" title="13">if b.Init() != nil </span><span class="cov0" title="0">{
                fnValue := reflect.ValueOf(b.Init())
                out := fnValue.Call([]reflect.Value{b.Value()})
                if len(out) &gt; 0 &amp;&amp; !out[0].IsNil() </span><span class="cov0" title="0">{
                        return out[0].Interface().(error)
                }</span>
        }

        // Mark the bean as wired and pop it from the stack.
        <span class="cov8" title="13">b.SetStatus(gs_bean.StatusWired)
        stack.popBack()
        return nil</span>
}

// getBeanValue retrieves the value of a bean. If it is a constructor bean,
// it executes the constructor and returns the result.
func (c *Wiring) getBeanValue(b BeanRuntime, stack *Stack) (reflect.Value, error) <span class="cov8" title="13">{

        // If the bean has no callable function, return its value directly.
        if b.Callable() == nil </span><span class="cov7" title="10">{
                return b.Value(), nil
        }</span>

        // Call the bean's constructor and handle errors.
        <span class="cov4" title="3">out, err := b.Callable().Call(NewArgContext(c, stack))
        if err != nil </span><span class="cov0" title="0">{
                return reflect.Value{}, err /* fmt.Errorf("%s:%s return error: %v", b.getClass(), b.ID(), err) */
        }</span>

        // If the return value is of bean type, handle it accordingly.
        <span class="cov4" title="3">if val := out[0]; util.IsBeanType(val.Type()) </span><span class="cov4" title="3">{
                // If it's a non-pointer value type, convert it into a pointer and set it.
                if !val.IsNil() &amp;&amp; val.Kind() == reflect.Interface &amp;&amp; util.IsPropBindingTarget(val.Elem().Type()) </span><span class="cov0" title="0">{
                        v := reflect.New(val.Elem().Type())
                        v.Elem().Set(val.Elem())
                        b.Value().Set(v)
                }</span> else<span class="cov4" title="3"> {
                        b.Value().Set(val)
                }</span>
        } else<span class="cov0" title="0"> {
                b.Value().Elem().Set(val)
        }</span>

        // Return an error if the value is nil.
        <span class="cov4" title="3">if b.Value().IsNil() </span><span class="cov0" title="0">{
                return reflect.Value{}, fmt.Errorf("%s return nil", b.String()) // b.GetClass(), b.FileLine())
        }</span>

        <span class="cov4" title="3">v := b.Value()
        // If the result is an interface, extract the original value.
        if b.Type().Kind() == reflect.Interface </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>
        <span class="cov4" title="3">return v, nil</span>
}

// WireBeanValue binds properties and injects dependencies into the value v. v should already be initialized.
func (c *Wiring) WireBeanValue(v reflect.Value, t reflect.Type, watchRefresh bool, stack *Stack) error <span class="cov8" title="13">{

        // Dereference pointer types and adjust the target type.
        if v.Kind() == reflect.Ptr </span><span class="cov8" title="13">{
                v = v.Elem()
                t = t.Elem()
        }</span>

        // If v is not a struct type, no injection is needed.
        <span class="cov8" title="13">if v.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="13">typeName := t.Name()
        if typeName == "" </span><span class="cov0" title="0">{
                // Simple types don't have names, use their string representation.
                typeName = t.String()
        }</span>

        <span class="cov8" title="13">param := conf.BindParam{Path: typeName}
        return c.wireStruct(v, t, watchRefresh, param, stack)</span>
}

// wireStruct performs dependency injection for a struct.
func (c *Wiring) wireStruct(v reflect.Value, t reflect.Type, watchRefresh bool, opt conf.BindParam, stack *Stack) error <span class="cov8" title="14">{
        // Loop through each field of the struct.
        for i := 0; i &lt; t.NumField(); i++ </span><span class="cov10" title="27">{
                ft := t.Field(i)
                fv := v.Field(i)

                // If the field is unexported, try to patch it.
                if !fv.CanInterface() </span><span class="cov8" title="14">{
                        fv = util.PatchValue(fv)
                        if !fv.CanInterface() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov10" title="27">fieldPath := opt.Path + "." + ft.Name

                // Check for autowire or inject tags.
                tag, ok := ft.Tag.Lookup("autowire")
                if !ok </span><span class="cov9" title="19">{
                        tag, ok = ft.Tag.Lookup("inject")
                }</span>
                <span class="cov10" title="27">if ok </span><span class="cov6" title="8">{
                        // Handle lazy injection.
                        if strings.HasSuffix(tag, ",lazy") </span><span class="cov0" title="0">{
                                f := lazyField{v: fv, path: fieldPath, tag: tag}
                                stack.lazyFields = append(stack.lazyFields, f)
                        }</span> else<span class="cov6" title="8"> {
                                if err := c.wireStructField(fv, tag, stack); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("%q wired error: %w", fieldPath, err)
                                }</span>
                        }
                        <span class="cov6" title="8">continue</span>
                }

                <span class="cov9" title="19">subParam := conf.BindParam{
                        Key:  opt.Key,
                        Path: fieldPath,
                }

                // Bind values if the field has a "value" tag.
                if tag, ok = ft.Tag.Lookup("value"); ok </span><span class="cov0" title="0">{
                        if err := subParam.BindTag(tag, ft.Tag); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if ft.Anonymous </span><span class="cov0" title="0">{
                                // Recursively wire anonymous structs.
                                err := c.wireStruct(fv, ft.Type, watchRefresh, subParam, stack)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Refresh field value if needed.
                                err := c.p.RefreshField(fv.Addr(), subParam, watchRefresh)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // Recursively wire anonymous struct fields.
                <span class="cov9" title="19">if ft.Anonymous &amp;&amp; ft.Type.Kind() == reflect.Struct </span><span class="cov1" title="1">{
                        if err := c.wireStruct(fv, ft.Type, watchRefresh, subParam, stack); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="14">return nil</span>
}

// wireField performs dependency injection by tag.
func (c *Wiring) wireStructField(v reflect.Value, str string, stack *Stack) error <span class="cov7" title="11">{
        switch v.Kind() </span>{
        case reflect.Map, reflect.Slice, reflect.Array:<span class="cov4" title="4">
                </span><span class="cov4" title="4">{
                        var tags []wireTag
                        if str != "" &amp;&amp; str != "?" </span><span class="cov4" title="4">{
                                for _, s := range strings.Split(str, ",") </span><span class="cov4" title="4">{
                                        g, err := parseWireTag(c.p.Data(), s, true)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov4" title="4">tags = append(tags, g)</span>
                                }
                        }
                        <span class="cov4" title="4">nullable := str == "?"
                        if c.forceAutowireIsNullable </span><span class="cov0" title="0">{
                                for i := 0; i &lt; len(tags); i++ </span><span class="cov0" title="0">{
                                        tags[i].nullable = true
                                }</span>
                                <span class="cov0" title="0">nullable = true</span>
                        }
                        <span class="cov4" title="4">beans, err := c.getBeans(v.Type(), tags, nullable, stack)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // Populate the slice or map with the resolved beans
                        <span class="cov4" title="4">switch v.Kind() </span>{
                        case reflect.Slice:<span class="cov4" title="4">
                                sort.Slice(beans, func(i, j int) bool </span><span class="cov1" title="1">{
                                        return beans[i].Name() &lt; beans[j].Name()
                                }</span>)
                                <span class="cov4" title="4">ret := reflect.MakeSlice(v.Type(), 0, 0)
                                for _, b := range beans </span><span class="cov4" title="4">{
                                        ret = reflect.Append(ret, b.Value())
                                }</span>
                                <span class="cov4" title="4">v.Set(ret)</span>
                        case reflect.Map:<span class="cov0" title="0">
                                ret := reflect.MakeMap(v.Type())
                                for _, b := range beans </span><span class="cov0" title="0">{
                                        ret.SetMapIndex(reflect.ValueOf(b.Name()), b.Value())
                                }</span>
                                <span class="cov0" title="0">v.Set(ret)</span>
                        default:<span class="cov0" title="0"></span>
                        }
                        <span class="cov4" title="4">return nil</span>
                }
        default:<span class="cov6" title="7">
                tag, err := parseWireTag(c.p.Data(), str, true)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="7">if c.forceAutowireIsNullable </span><span class="cov0" title="0">{
                        tag.nullable = true
                }</span>
                // Ensure the provided value `v` is valid.
                <span class="cov6" title="7">if !v.IsValid() </span><span class="cov0" title="0">{
                        return fmt.Errorf("receiver must be a reference type, bean:%q", str)
                }</span>
                <span class="cov6" title="7">b, err := c.getBean(v.Type(), tag, stack)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="7">if b != nil </span><span class="cov6" title="7">{
                        v.Set(b.Value())
                }</span>
                <span class="cov6" title="7">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_dync

import (
        "encoding/json"
        "fmt"
        "reflect"
        "sort"
        "strings"
        "sync"
        "sync/atomic"

        "github.com/go-spring/spring-core/conf"
        "github.com/go-spring/spring-core/gs/internal/gs"
)

// Value represents a thread-safe object that can dynamically refresh its value.
type Value[T any] struct {
        v atomic.Value
}

// Value retrieves the current value stored in the object.
// If no value is set, it returns the zero value for the type T.
func (r *Value[T]) Value() T <span class="cov0" title="0">{
        v, ok := r.v.Load().(T)
        if !ok </span><span class="cov0" title="0">{
                var zero T
                return zero
        }</span>
        <span class="cov0" title="0">return v</span>
}

// OnRefresh refreshes the value of the object by binding new properties.
func (r *Value[T]) OnRefresh(prop gs.Properties, param conf.BindParam) error <span class="cov0" title="0">{
        var o T
        v := reflect.ValueOf(&amp;o).Elem()
        err := conf.BindValue(prop, v, v.Type(), param, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">r.v.Store(o)
        return nil</span>
}

// MarshalJSON serializes the stored value as JSON.
func (r *Value[T]) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(r.v.Load())
}</span>

// refreshObject represents an object bound to dynamic properties that can be refreshed.
type refreshObject struct {
        target gs.Refreshable // The refreshable object.
        param  conf.BindParam // Parameters used for refreshing.
}

// Properties manages dynamic properties and refreshable objects.
type Properties struct {
        prop    gs.Properties    // The current properties.
        lock    sync.RWMutex     // A read-write lock for thread-safe access.
        objects []*refreshObject // List of refreshable objects bound to the properties.
}

// New creates and returns a new Properties instance.
func New() *Properties <span class="cov3" title="2">{
        return &amp;Properties{
                prop: conf.New(),
        }
}</span>

// Data returns the current properties.
func (p *Properties) Data() gs.Properties <span class="cov10" title="21">{
        p.lock.RLock()
        defer p.lock.RUnlock()
        return p.prop
}</span>

// ObjectsCount returns the number of registered refreshable objects.
func (p *Properties) ObjectsCount() int <span class="cov3" title="2">{
        p.lock.RLock()
        defer p.lock.RUnlock()
        return len(p.objects)
}</span>

// Refresh updates the properties and refreshes all bound objects as necessary.
func (p *Properties) Refresh(prop gs.Properties) (err error) <span class="cov3" title="2">{
        p.lock.Lock()
        defer p.lock.Unlock()

        if len(p.objects) == 0 </span><span class="cov3" title="2">{
                p.prop = prop
                return nil
        }</span>

        <span class="cov0" title="0">old := p.prop
        p.prop = prop

        oldKeys := old.Keys()
        newKeys := prop.Keys()

        changes := make(map[string]struct{})
        </span><span class="cov0" title="0">{
                for _, k := range newKeys </span><span class="cov0" title="0">{
                        if !old.Has(k) || old.Get(k) != prop.Get(k) </span><span class="cov0" title="0">{
                                changes[k] = struct{}{}
                        }</span>
                }
                <span class="cov0" title="0">for _, k := range oldKeys </span><span class="cov0" title="0">{
                        if _, ok := changes[k]; !ok </span><span class="cov0" title="0">{
                                changes[k] = struct{}{}
                        }</span>
                }
        }

        <span class="cov0" title="0">keys := make([]string, 0, len(changes))
        for k := range changes </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)
        return p.refreshKeys(keys)</span>
}

// refreshKeys refreshes objects bound by the specified keys.
func (p *Properties) refreshKeys(keys []string) (err error) <span class="cov0" title="0">{
        updateIndexes := make(map[int]*refreshObject)
        for _, key := range keys </span><span class="cov0" title="0">{
                for index, o := range p.objects </span><span class="cov0" title="0">{
                        s := strings.TrimPrefix(key, o.param.Key)
                        if len(s) == len(key) </span><span class="cov0" title="0">{ // Check if the key starts with the parameter key.
                                continue</span>
                        }
                        <span class="cov0" title="0">if len(s) == 0 || s[0] == '.' || s[0] == '[' </span><span class="cov0" title="0">{
                                if _, ok := updateIndexes[index]; !ok </span><span class="cov0" title="0">{
                                        updateIndexes[index] = o
                                }</span>
                        }
                }
        }

        // Sort and collect objects that need updating.
        <span class="cov0" title="0">updateObjects := make([]*refreshObject, 0, len(updateIndexes))
        </span><span class="cov0" title="0">{
                ints := make([]int, 0, len(updateIndexes))
                for k := range updateIndexes </span><span class="cov0" title="0">{
                        ints = append(ints, k)
                }</span>
                <span class="cov0" title="0">sort.Ints(ints)
                for _, k := range ints </span><span class="cov0" title="0">{
                        updateObjects = append(updateObjects, updateIndexes[k])
                }</span>
        }

        <span class="cov0" title="0">if len(updateObjects) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return p.refreshObjects(updateObjects)</span>
}

// Errors represents a collection of errors.
type Errors struct {
        arr []error
}

// Len returns the number of errors.
func (e *Errors) Len() int <span class="cov0" title="0">{
        return len(e.arr)
}</span>

// Append adds an error to the collection if it is non-nil.
func (e *Errors) Append(err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                e.arr = append(e.arr, err)
        }</span>
}

// Error concatenates all errors into a single string.
func (e *Errors) Error() string <span class="cov0" title="0">{
        var sb strings.Builder
        for i, err := range e.arr </span><span class="cov0" title="0">{
                sb.WriteString(err.Error())
                if i &lt; len(e.arr)-1 </span><span class="cov0" title="0">{
                        sb.WriteString("\n")
                }</span>
        }
        <span class="cov0" title="0">return sb.String()</span>
}

// refreshObjects refreshes all provided objects and aggregates errors.
func (p *Properties) refreshObjects(objects []*refreshObject) error <span class="cov0" title="0">{
        ret := &amp;Errors{}
        for _, obj := range objects </span><span class="cov0" title="0">{
                err := p.safeRefreshObject(obj)
                ret.Append(err)
        }</span>
        <span class="cov0" title="0">if ret.Len() == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return ret</span>
}

// safeRefreshObject refreshes an object and recovers from panics.
func (p *Properties) safeRefreshObject(obj *refreshObject) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("panic: %v", r)
                }</span>
        }()
        <span class="cov0" title="0">return obj.target.OnRefresh(p.prop, obj.param)</span>
}

// RefreshBean refreshes a single refreshable object.
// Optionally registers the object as refreshable if watch is true.
func (p *Properties) RefreshBean(v gs.Refreshable, param conf.BindParam, watch bool) error <span class="cov0" title="0">{
        p.lock.Lock()
        defer p.lock.Unlock()
        return p.doRefresh(v, param, watch)
}</span>

// doRefresh performs the refresh operation and registers the object if watch is enabled.
func (p *Properties) doRefresh(v gs.Refreshable, param conf.BindParam, watch bool) error <span class="cov0" title="0">{
        if watch </span><span class="cov0" title="0">{
                p.objects = append(p.objects, &amp;refreshObject{
                        target: v,
                        param:  param,
                })
        }</span>
        <span class="cov0" title="0">return v.OnRefresh(p.prop, param)</span>
}

// filter is used to selectively refresh objects and fields.
type filter struct {
        *Properties
        watch bool // Whether to register objects as refreshable.
}

// Do attempts to refresh a single object if it implements the [gs.Refreshable] interface.
func (f *filter) Do(i interface{}, param conf.BindParam) (bool, error) <span class="cov0" title="0">{
        v, ok := i.(gs.Refreshable)
        if !ok </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, f.doRefresh(v, param, f.watch)</span>
}

// RefreshField refreshes a field of a bean, optionally registering it as refreshable.
func (p *Properties) RefreshField(v reflect.Value, param conf.BindParam, watch bool) error <span class="cov0" title="0">{
        p.lock.Lock()
        defer p.lock.Unlock()
        f := &amp;filter{Properties: p, watch: watch}
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                ok, err := f.Do(v.Interface(), param)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return conf.BindValue(p.prop, v.Elem(), v.Elem().Type(), param, f)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs_util

import (
        "container/list"
        "errors"
)

// GetBeforeItems is a function type that returns a list of items
// that must appear before the given current item in the sorting order.
type GetBeforeItems func(sorting *list.List, current interface{}) (*list.List, error)

// TripleSort performs a three-way sort (processing, toSort, sorted)
// to resolve dependencies and return a sorted list.
// The input `sorting` is a list of all items to be sorted, and `fn` determines dependencies.
func TripleSort(sorting *list.List, fn GetBeforeItems) (*list.List, error) <span class="cov4" title="2">{
        toSort := list.New()     // List of items that still need to be sorted.
        sorted := list.New()     // List of items that have been fully sorted.
        processing := list.New() // List of items currently being processed.

        // Initialize the toSort list with all elements from the input sorting list.
        toSort.PushBackList(sorting)

        // Process items in the toSort list until all items are sorted.
        for toSort.Len() &gt; 0 </span><span class="cov6" title="3">{
                // Recursively sort the dependency chain starting with the next item in `toSort`.
                err := tripleSortByAfter(sorting, toSort, sorted, processing, nil, fn)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov4" title="2">return sorted, nil</span>
}

// searchInList searches for an element `v` in the list `l`.
// If the element exists, it returns a pointer to the list element. Otherwise, it returns nil.
func searchInList(l *list.List, v interface{}) *list.Element <span class="cov10" title="6">{
        for e := l.Front(); e != nil; e = e.Next() </span><span class="cov10" title="6">{
                if e.Value == v </span><span class="cov6" title="3">{
                        return e
                }</span>
        }
        <span class="cov6" title="3">return nil</span>
}

// tripleSortByAfter recursively processes an item's dependency chain and adds it to the sorted list.
// Parameters:
// - sorting: The original list of items.
// - toSort: The list of items to be sorted.
// - sorted: The list of items that have been sorted.
// - processing: The list of items currently being processed (to detect cycles).
// - current: The current item being processed (nil for the first item).
// - fn: A function that retrieves the list of items that must appear before the current item.
func tripleSortByAfter(sorting *list.List, toSort *list.List, sorted *list.List,
        processing *list.List, current interface{}, fn GetBeforeItems) error <span class="cov6" title="3">{

        // If no current item is specified, remove and process the first item in the `toSort` list.
        if current == nil </span><span class="cov6" title="3">{
                current = toSort.Remove(toSort.Front())
        }</span>

        // Retrieve dependencies for the current item.
        <span class="cov6" title="3">l, err := fn(sorting, current)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add the current item to the processing list to mark it as being processed.
        <span class="cov6" title="3">processing.PushBack(current)

        // Process dependencies for the current item.
        for e := l.Front(); e != nil; e = e.Next() </span><span class="cov0" title="0">{
                c := e.Value

                // Detect circular dependencies by checking if `c` is already being processed.
                if searchInList(processing, c) != nil </span><span class="cov0" title="0">{
                        return errors.New("found sorting cycle") // todo: more details
                }</span>

                // Check if the dependency `c` is already sorted or still in the toSort list.
                <span class="cov0" title="0">inSorted := searchInList(sorted, c) != nil
                inToSort := searchInList(toSort, c) != nil

                // If the dependency is not sorted but still needs sorting, process it recursively.
                if !inSorted &amp;&amp; inToSort </span><span class="cov0" title="0">{
                        err = tripleSortByAfter(sorting, toSort, sorted, processing, c, fn)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // Remove the current item from the processing list.
        <span class="cov6" title="3">if e := searchInList(processing, current); e != nil </span><span class="cov6" title="3">{
                processing.Remove(e)
        }</span>

        // Remove the current item from the toSort list (if it is still there).
        <span class="cov6" title="3">if e := searchInList(toSort, current); e != nil </span><span class="cov0" title="0">{
                toSort.Remove(e)
        }</span>

        // Add the current item to the sorted list to mark it as fully processed.
        <span class="cov6" title="3">sorted.PushBack(current)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs

import (
        "net/http"
        "net/http/pprof"
)

func init() <span class="cov8" title="1">{
        Provide(NewSimplePProfServer, TagArg("${pprof.server.addr:=0.0.0.0:9981}")).Condition(
                OnProperty(EnableSimplePProfServerProp).HavingValue("true"),
        ).AsServer()
}</span>

// SimplePProfServer is a simple pprof server.
type SimplePProfServer struct {
        *SimpleHttpServer
}

// NewSimplePProfServer creates a new SimplePProfServer.
func NewSimplePProfServer(addr string) *SimplePProfServer <span class="cov8" title="1">{
        mux := http.NewServeMux()
        mux.HandleFunc("GET /debug/pprof/", pprof.Index)
        mux.HandleFunc("GET /debug/pprof/cmdline", pprof.Cmdline)
        mux.HandleFunc("GET /debug/pprof/profile", pprof.Profile)
        mux.HandleFunc("GET /debug/pprof/symbol", pprof.Symbol)
        mux.HandleFunc("GET /debug/pprof/trace", pprof.Trace)
        return &amp;SimplePProfServer{
                SimpleHttpServer: NewSimpleHttpServer(addr, mux),
        }
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gs

import (
        "github.com/go-spring/spring-core/util/sysconf"
)

const (
        AllowCircularReferencesProp = "spring.allow-circular-references"
        ForceAutowireIsNullableProp = "spring.force-autowire-is-nullable"
        ActiveProfilesProp          = "spring.profiles.active"
        EnableSimpleHttpServerProp  = "spring.enable.simple-http-server"
        EnableSimplePProfServerProp = "spring.enable.simple-pprof-server"
)

// AllowCircularReferences enables or disables circular references between beans.
func AllowCircularReferences(enable bool) <span class="cov0" title="0">{
        err := sysconf.Set(AllowCircularReferencesProp, enable)
        _ = err // Ignore error
}</span>

// ForceAutowireIsNullable forces autowire to be nullable.
func ForceAutowireIsNullable(enable bool) <span class="cov0" title="0">{
        err := sysconf.Set(ForceAutowireIsNullableProp, enable)
        _ = err // Ignore error
}</span>

// SetActiveProfiles sets the active profiles for the app.
func SetActiveProfiles(profiles string) <span class="cov8" title="1">{
        err := sysconf.Set(ActiveProfilesProp, profiles)
        _ = err // Ignore error
}</span>

// EnableSimpleHttpServer enables or disables the simple HTTP server.
func EnableSimpleHttpServer(enable bool) <span class="cov0" title="0">{
        err := sysconf.Set(EnableSimpleHttpServerProp, enable)
        _ = err // Ignore error
}</span>

// EnableSimplePProfServer enables or disables the simple pprof server.
func EnableSimplePProfServer(enable bool) <span class="cov8" title="1">{
        err := sysconf.Set(EnableSimplePProfServerProp, enable)
        _ = err // Ignore error
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package errutil

import (
        "fmt"
)

// LineBreak defines the separator used between errors with hierarchical relationships.
var LineBreak = " &lt;&lt; "

// WrapError wraps an existing error, creating a new error with hierarchical relationships.
func WrapError(err error, format string, args ...interface{}) error <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, args...)
        return fmt.Errorf("%s%s%w", msg, LineBreak, err)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package util

import (
        "fmt"
        "reflect"

        "github.com/spf13/cast"
)

// FlattenMap flattens a nested map, array, or slice into a single-level map
// with string keys and string values. It recursively processes each element
// of the input map and adds its flattened representation to the result map.
func FlattenMap(m map[string]interface{}) map[string]string <span class="cov1" title="1">{
        result := make(map[string]string)
        for key, val := range m </span><span class="cov4" title="7">{
                FlattenValue(key, val, result)
        }</span>
        <span class="cov1" title="1">return result</span>
}

// FlattenValue flattens a single value (which can be a map, array, slice,
// or other types) into the result map.
func FlattenValue(key string, val interface{}, result map[string]string) <span class="cov10" title="157">{
        if val == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="157">switch v := reflect.ValueOf(val); v.Kind() </span>{
        case reflect.Map:<span class="cov0" title="0">
                if v.Len() == 0 </span><span class="cov0" title="0">{
                        result[key] = ""
                        return
                }</span>
                <span class="cov0" title="0">for _, k := range v.MapKeys() </span><span class="cov0" title="0">{
                        mapKey := cast.ToString(k.Interface())
                        mapValue := v.MapIndex(k).Interface()
                        FlattenValue(key+"."+mapKey, mapValue, result)
                }</span>
        case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                if v.Len() == 0 </span><span class="cov0" title="0">{
                        result[key] = ""
                        return
                }</span>
                <span class="cov0" title="0">for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                        subKey := fmt.Sprintf("%s[%d]", key, i)
                        subValue := v.Index(i).Interface()
                        // If an element is nil, treat it as an empty value and assign an empty string.
                        // Note: We do not remove the nil element to avoid changing the array's size.
                        if subValue == nil </span><span class="cov0" title="0">{
                                result[subKey] = ""
                                continue</span>
                        }
                        <span class="cov0" title="0">FlattenValue(subKey, subValue, result)</span>
                }
        default:<span class="cov10" title="157">
                result[key] = cast.ToString(val)</span>
        }
}
</pre>
		
		<pre class="file" id="file42" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package goutil

import (
        "context"
        "errors"
        "runtime/debug"
        "sync"

        "github.com/go-spring/spring-core/util/syslog"
)

// OnPanic is a global callback function triggered when a panic occurs.
var OnPanic = func(r interface{}) <span class="cov0" title="0">{
        syslog.Errorf("panic: %v\n%s", r, debug.Stack())
}</span>

/********************************** go ***************************************/

// Status provides a mechanism to wait for a goroutine to finish.
type Status struct {
        wg sync.WaitGroup
}

// newStatus creates and initializes a new Status object.
func newStatus() *Status <span class="cov10" title="6">{
        s := &amp;Status{}
        s.wg.Add(1)
        return s
}</span>

// done marks the goroutine as finished.
func (s *Status) done() <span class="cov10" title="6">{
        s.wg.Done()
}</span>

// Wait waits for the goroutine to finish.
func (s *Status) Wait() <span class="cov0" title="0">{
        s.wg.Wait()
}</span>

// Go runs a goroutine safely with context support and panic recovery.
// It ensures the process does not crash due to an uncaught panic in the goroutine.
func Go(ctx context.Context, f func(ctx context.Context)) *Status <span class="cov0" title="0">{
        s := newStatus()
        go func() </span><span class="cov0" title="0">{
                defer s.done()
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                if OnPanic != nil </span><span class="cov0" title="0">{
                                        OnPanic(r)
                                }</span>
                        }
                }()
                <span class="cov0" title="0">f(ctx)</span>
        }()
        <span class="cov0" title="0">return s</span>
}

// GoFunc runs a goroutine safely with panic recovery.
// It ensures the process does not crash due to an uncaught panic in the goroutine.
func GoFunc(f func()) *Status <span class="cov10" title="6">{
        s := newStatus()
        go func() </span><span class="cov10" title="6">{
                defer s.done()
                defer func() </span><span class="cov10" title="6">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                if OnPanic != nil </span><span class="cov0" title="0">{
                                        OnPanic(r)
                                }</span>
                        }
                }()
                <span class="cov10" title="6">f()</span>
        }()
        <span class="cov10" title="6">return s</span>
}

/******************************* go with value *******************************/

// ValueStatus provides a mechanism to wait for a goroutine that returns a value and an error.
type ValueStatus[T any] struct {
        wg  sync.WaitGroup
        val T
        err error
}

// newValueStatus creates and initializes a new ValueStatus object.
func newValueStatus[T any]() *ValueStatus[T] <span class="cov0" title="0">{
        s := &amp;ValueStatus[T]{}
        s.wg.Add(1)
        return s
}</span>

// done marks the goroutine as finished.
func (s *ValueStatus[T]) done() <span class="cov0" title="0">{
        s.wg.Done()
}</span>

// Wait blocks until the goroutine finishes and returns its result and error.
func (s *ValueStatus[T]) Wait() (T, error) <span class="cov0" title="0">{
        s.wg.Wait()
        return s.val, s.err
}</span>

// GoValue runs a goroutine safely with context support and panic recovery and
// returns its result and error.
// It ensures the process does not crash due to an uncaught panic in the goroutine.
func GoValue[T any](ctx context.Context, f func(ctx context.Context) (T, error)) *ValueStatus[T] <span class="cov0" title="0">{
        s := newValueStatus[T]()
        go func() </span><span class="cov0" title="0">{
                defer s.done()
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                if OnPanic != nil </span><span class="cov0" title="0">{
                                        OnPanic(r)
                                }</span>
                                <span class="cov0" title="0">s.err = errors.New("panic occurred")</span>
                        }
                }()
                <span class="cov0" title="0">s.val, s.err = f(ctx)</span>
        }()
        <span class="cov0" title="0">return s</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package util

import (
        "cmp"
        "slices"
)

// MapKeys returns the keys of the map m.
func MapKeys[M ~map[K]V, K comparable, V any](m M) []K <span class="cov1" title="1">{
        r := make([]K, 0, len(m))
        for k := range m </span><span class="cov10" title="3">{
                r = append(r, k)
        }</span>
        <span class="cov1" title="1">return r</span>
}

// OrderedMapKeys returns the keys of the map m in sorted order.
func OrderedMapKeys[M ~map[K]V, K cmp.Ordered, V any](m M) []K <span class="cov1" title="1">{
        r := MapKeys(m)
        slices.Sort(r)
        return r
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sysconf

import (
        "sync"

        "github.com/go-spring/spring-core/conf"
)

var (
        prop = conf.New()
        lock sync.Mutex
)

// Get returns the property of the key.
func Get(key string) string <span class="cov0" title="0">{
        lock.Lock()
        defer lock.Unlock()
        return prop.Get(key)
}</span>

// MustGet returns the property of the key, if not exist, returns the default value.
func MustGet(key string, def string) string <span class="cov0" title="0">{
        lock.Lock()
        defer lock.Unlock()
        return prop.Get(key, def)
}</span>

// Set sets the property of the key.
func Set(key string, val interface{}) error <span class="cov5" title="2">{
        lock.Lock()
        defer lock.Unlock()
        return prop.Set(key, val)
}</span>

// Delete removes the property.
func Delete(key string) <span class="cov0" title="0">{
        lock.Lock()
        defer lock.Unlock()
}</span>

// Clear clears all properties.
func Clear() <span class="cov0" title="0">{
        lock.Lock()
        defer lock.Unlock()
        prop = conf.New()
}</span>

// Clone copies all properties into another properties.
func Clone() *conf.Properties <span class="cov10" title="4">{
        lock.Lock()
        defer lock.Unlock()
        p := conf.New()
        err := prop.CopyTo(p)
        _ = err // should no error
        return p
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package syslog

import (
        "context"
        "fmt"
        "log"
        "log/slog"
        "os"
        "runtime"
        "time"
)

func init() <span class="cov1" title="1">{
        log.SetOutput(os.Stdout)
        log.SetFlags(log.Flags() | log.Lshortfile)
}</span>

// Debugf logs a debug-level message using slog.
func Debugf(format string, a ...any) <span class="cov9" title="50">{
        logMsg(slog.LevelDebug, format, a...)
}</span>

// Infof logs an info-level message using slog.
func Infof(format string, a ...any) <span class="cov2" title="2">{
        logMsg(slog.LevelInfo, format, a...)
}</span>

// Warnf logs a warning-level message using slog.
func Warnf(format string, a ...any) <span class="cov0" title="0">{
        logMsg(slog.LevelWarn, format, a...)
}</span>

// Errorf logs an error-level message using slog.
func Errorf(format string, a ...any) <span class="cov0" title="0">{
        logMsg(slog.LevelError, format, a...)
}</span>

// logMsg constructs and logs a message at the specified log level.
func logMsg(level slog.Level, format string, a ...any) <span class="cov10" title="52">{
        ctx := context.Background()
        if !slog.Default().Enabled(ctx, level) </span><span class="cov9" title="50">{
                return
        }</span>

        // skip [runtime.Callers, syslog.logMsg, syslog.*f]
        <span class="cov2" title="2">var pcs [1]uintptr
        runtime.Callers(3, pcs[:])

        msg := fmt.Sprintf(format, a...)
        r := slog.NewRecord(time.Now(), level, msg, pcs[0])
        err := slog.Default().Handler().Handle(ctx, r)
        _ = err</span> // ignore error
}
</pre>
		
		<pre class="file" id="file46" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package util

import (
        "reflect"
)

// errorType is the [reflect.Type] of the error interface.
var errorType = reflect.TypeOf((*error)(nil)).Elem()

// IsFuncType returns true if the provided type t is a function type.
func IsFuncType(t reflect.Type) bool <span class="cov5" title="6">{
        return t.Kind() == reflect.Func
}</span>

// IsErrorType returns true if the provided type t is an error type,
// either directly (error) or via an implementation (i.e., implements the error interface).
func IsErrorType(t reflect.Type) bool <span class="cov5" title="6">{
        return t == errorType || t.Implements(errorType)
}</span>

// ReturnNothing returns true if the provided function type t has no return values.
func ReturnNothing(t reflect.Type) bool <span class="cov3" title="3">{
        return t.NumOut() == 0
}</span>

// ReturnOnlyError returns true if the provided function type t returns only one value,
// and that value is an error.
func ReturnOnlyError(t reflect.Type) bool <span class="cov0" title="0">{
        return t.NumOut() == 1 &amp;&amp; IsErrorType(t.Out(0))
}</span>

// IsConstructor returns true if the provided function type t is a constructor.
// A constructor is defined as a function that returns one or two values.
// If it returns two values, the second value must be an error.
func IsConstructor(t reflect.Type) bool <span class="cov3" title="3">{
        if !IsFuncType(t) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="3">switch t.NumOut() </span>{
        case 1:<span class="cov3" title="3">
                return !IsErrorType(t.Out(0))</span>
        case 2:<span class="cov0" title="0">
                return IsErrorType(t.Out(1))</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// IsPrimitiveValueType returns true if the provided type t is a primitive value type,
// such as int, uint, float, bool, or string.
func IsPrimitiveValueType(t reflect.Type) bool <span class="cov9" title="30">{
        switch t.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                return true</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return true</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return true</span>
        case reflect.String:<span class="cov6" title="10">
                return true</span>
        case reflect.Bool:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov8" title="20">
                return false</span>
        }
}

// IsPropBindingTarget returns true if the provided type t is a valid target for property binding.
// This includes primitive value types or composite types (such as array, slice, map, or struct)
// where the elements are primitive value types.
func IsPropBindingTarget(t reflect.Type) bool <span class="cov9" title="30">{
        switch t.Kind() </span>{
        case reflect.Map, reflect.Slice, reflect.Array:<span class="cov1" title="1">
                t = t.Elem()</span> // for collection types, check the element type
        default:<span class="cov9" title="29"></span>
                // do nothing
        }
        <span class="cov9" title="30">return IsPrimitiveValueType(t) || t.Kind() == reflect.Struct</span>
}

// IsBeanType returns true if the provided type t is considered a "bean" type.
// A "bean" type includes a channel, function, interface, or a pointer to a struct.
func IsBeanType(t reflect.Type) bool <span class="cov10" title="36">{
        switch t.Kind() </span>{
        case reflect.Chan, reflect.Func, reflect.Interface:<span class="cov6" title="9">
                return true</span>
        case reflect.Ptr:<span class="cov9" title="27">
                return t.Elem().Kind() == reflect.Struct</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// IsBeanInjectionTarget returns true if the provided type t is a valid target for bean injection.
// This includes maps, slices, arrays, or any other bean type (including pointers to structs).
func IsBeanInjectionTarget(t reflect.Type) bool <span class="cov7" title="14">{
        switch t.Kind() </span>{
        case reflect.Map, reflect.Slice, reflect.Array:<span class="cov0" title="0">
                t = t.Elem()</span> // for collection types, check the element type
        default:<span class="cov7" title="14"></span>
                // do nothing
        }
        <span class="cov7" title="14">return IsBeanType(t)</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package util

import (
        "reflect"
        "runtime"
        "strings"
        "unsafe"
)

const (
        flagStickyRO = 1 &lt;&lt; 5
        flagEmbedRO  = 1 &lt;&lt; 6
        flagRO       = flagStickyRO | flagEmbedRO
)

// PatchValue modifies an unexported field to make it assignable by modifying the internal flag.
// It takes a [reflect.Value] and returns the patched value that can be written to.
// This is typically used to manipulate unexported fields in struct types.
func PatchValue(v reflect.Value) reflect.Value <span class="cov10" title="14">{
        rv := reflect.ValueOf(&amp;v)
        flag := rv.Elem().FieldByName("flag")
        ptrFlag := (*uintptr)(unsafe.Pointer(flag.UnsafeAddr()))
        *ptrFlag = *ptrFlag &amp;^ flagRO
        return v
}</span>

// FileLine returns the file, line number, and function name for a given function.
// It uses reflection and runtime information to extract these details.
// 'fn' is expected to be a function or method value.
func FileLine(fn interface{}) (file string, line int, fnName string) <span class="cov0" title="0">{

        fnPtr := reflect.ValueOf(fn).Pointer()
        fnInfo := runtime.FuncForPC(fnPtr)
        file, line = fnInfo.FileLine(fnPtr)

        s := fnInfo.Name()
        i := strings.LastIndex(s, "/")
        if i &gt; 0 </span><span class="cov0" title="0">{
                s = s[i+1:]
        }</span>

        // method values are printed as "T.m-fm"
        <span class="cov0" title="0">s = strings.TrimRight(s, "-fm")
        return file, line, s</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
